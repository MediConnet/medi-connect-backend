
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model appointments
 * 
 */
export type appointments = $Result.DefaultSelection<Prisma.$appointmentsPayload>
/**
 * Model cities
 * 
 */
export type cities = $Result.DefaultSelection<Prisma.$citiesPayload>
/**
 * Model medical_history
 * 
 */
export type medical_history = $Result.DefaultSelection<Prisma.$medical_historyPayload>
/**
 * Model notifications
 * 
 */
export type notifications = $Result.DefaultSelection<Prisma.$notificationsPayload>
/**
 * Model patient_favorites
 * 
 */
export type patient_favorites = $Result.DefaultSelection<Prisma.$patient_favoritesPayload>
/**
 * Model patients
 * 
 */
export type patients = $Result.DefaultSelection<Prisma.$patientsPayload>
/**
 * Model payments
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model payouts
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type payouts = $Result.DefaultSelection<Prisma.$payoutsPayload>
/**
 * Model provider_ads
 * 
 */
export type provider_ads = $Result.DefaultSelection<Prisma.$provider_adsPayload>
/**
 * Model provider_bank_details
 * 
 */
export type provider_bank_details = $Result.DefaultSelection<Prisma.$provider_bank_detailsPayload>
/**
 * Model provider_branches
 * 
 */
export type provider_branches = $Result.DefaultSelection<Prisma.$provider_branchesPayload>
/**
 * Model provider_catalog
 * 
 */
export type provider_catalog = $Result.DefaultSelection<Prisma.$provider_catalogPayload>
/**
 * Model provider_schedules
 * 
 */
export type provider_schedules = $Result.DefaultSelection<Prisma.$provider_schedulesPayload>
/**
 * Model providers
 * 
 */
export type providers = $Result.DefaultSelection<Prisma.$providersPayload>
/**
 * Model reviews
 * 
 */
export type reviews = $Result.DefaultSelection<Prisma.$reviewsPayload>
/**
 * Model service_categories
 * 
 */
export type service_categories = $Result.DefaultSelection<Prisma.$service_categoriesPayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const enum_appt_status: {
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type enum_appt_status = (typeof enum_appt_status)[keyof typeof enum_appt_status]


export const enum_notif_types: {
  REMINDER: 'REMINDER',
  SYSTEM: 'SYSTEM',
  BOOKING: 'BOOKING',
  cita: 'cita',
  laboratorio: 'laboratorio',
  farmacia: 'farmacia',
  ambulancia: 'ambulancia',
  insumo: 'insumo',
  sistema: 'sistema'
};

export type enum_notif_types = (typeof enum_notif_types)[keyof typeof enum_notif_types]


export const enum_roles: {
  admin: 'admin',
  user: 'user',
  provider: 'provider',
  patient: 'patient'
};

export type enum_roles = (typeof enum_roles)[keyof typeof enum_roles]


export const enum_verification: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type enum_verification = (typeof enum_verification)[keyof typeof enum_verification]

}

export type enum_appt_status = $Enums.enum_appt_status

export const enum_appt_status: typeof $Enums.enum_appt_status

export type enum_notif_types = $Enums.enum_notif_types

export const enum_notif_types: typeof $Enums.enum_notif_types

export type enum_roles = $Enums.enum_roles

export const enum_roles: typeof $Enums.enum_roles

export type enum_verification = $Enums.enum_verification

export const enum_verification: typeof $Enums.enum_verification

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Appointments
 * const appointments = await prisma.appointments.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Appointments
   * const appointments = await prisma.appointments.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.appointments`: Exposes CRUD operations for the **appointments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointments.findMany()
    * ```
    */
  get appointments(): Prisma.appointmentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cities`: Exposes CRUD operations for the **cities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.cities.findMany()
    * ```
    */
  get cities(): Prisma.citiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.medical_history`: Exposes CRUD operations for the **medical_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medical_histories
    * const medical_histories = await prisma.medical_history.findMany()
    * ```
    */
  get medical_history(): Prisma.medical_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notifications`: Exposes CRUD operations for the **notifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notifications.findMany()
    * ```
    */
  get notifications(): Prisma.notificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patient_favorites`: Exposes CRUD operations for the **patient_favorites** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patient_favorites
    * const patient_favorites = await prisma.patient_favorites.findMany()
    * ```
    */
  get patient_favorites(): Prisma.patient_favoritesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.patients`: Exposes CRUD operations for the **patients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patients.findMany()
    * ```
    */
  get patients(): Prisma.patientsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payouts`: Exposes CRUD operations for the **payouts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payouts
    * const payouts = await prisma.payouts.findMany()
    * ```
    */
  get payouts(): Prisma.payoutsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider_ads`: Exposes CRUD operations for the **provider_ads** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provider_ads
    * const provider_ads = await prisma.provider_ads.findMany()
    * ```
    */
  get provider_ads(): Prisma.provider_adsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider_bank_details`: Exposes CRUD operations for the **provider_bank_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provider_bank_details
    * const provider_bank_details = await prisma.provider_bank_details.findMany()
    * ```
    */
  get provider_bank_details(): Prisma.provider_bank_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider_branches`: Exposes CRUD operations for the **provider_branches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provider_branches
    * const provider_branches = await prisma.provider_branches.findMany()
    * ```
    */
  get provider_branches(): Prisma.provider_branchesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider_catalog`: Exposes CRUD operations for the **provider_catalog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provider_catalogs
    * const provider_catalogs = await prisma.provider_catalog.findMany()
    * ```
    */
  get provider_catalog(): Prisma.provider_catalogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.provider_schedules`: Exposes CRUD operations for the **provider_schedules** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Provider_schedules
    * const provider_schedules = await prisma.provider_schedules.findMany()
    * ```
    */
  get provider_schedules(): Prisma.provider_schedulesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providers`: Exposes CRUD operations for the **providers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.providers.findMany()
    * ```
    */
  get providers(): Prisma.providersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviews`: Exposes CRUD operations for the **reviews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.reviews.findMany()
    * ```
    */
  get reviews(): Prisma.reviewsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service_categories`: Exposes CRUD operations for the **service_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Service_categories
    * const service_categories = await prisma.service_categories.findMany()
    * ```
    */
  get service_categories(): Prisma.service_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    appointments: 'appointments',
    cities: 'cities',
    medical_history: 'medical_history',
    notifications: 'notifications',
    patient_favorites: 'patient_favorites',
    patients: 'patients',
    payments: 'payments',
    payouts: 'payouts',
    provider_ads: 'provider_ads',
    provider_bank_details: 'provider_bank_details',
    provider_branches: 'provider_branches',
    provider_catalog: 'provider_catalog',
    provider_schedules: 'provider_schedules',
    providers: 'providers',
    reviews: 'reviews',
    service_categories: 'service_categories',
    sessions: 'sessions',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "appointments" | "cities" | "medical_history" | "notifications" | "patient_favorites" | "patients" | "payments" | "payouts" | "provider_ads" | "provider_bank_details" | "provider_branches" | "provider_catalog" | "provider_schedules" | "providers" | "reviews" | "service_categories" | "sessions" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      appointments: {
        payload: Prisma.$appointmentsPayload<ExtArgs>
        fields: Prisma.appointmentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.appointmentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.appointmentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          findFirst: {
            args: Prisma.appointmentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.appointmentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          findMany: {
            args: Prisma.appointmentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>[]
          }
          create: {
            args: Prisma.appointmentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          createMany: {
            args: Prisma.appointmentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.appointmentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>[]
          }
          delete: {
            args: Prisma.appointmentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          update: {
            args: Prisma.appointmentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          deleteMany: {
            args: Prisma.appointmentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.appointmentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.appointmentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>[]
          }
          upsert: {
            args: Prisma.appointmentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$appointmentsPayload>
          }
          aggregate: {
            args: Prisma.AppointmentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointments>
          }
          groupBy: {
            args: Prisma.appointmentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.appointmentsCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentsCountAggregateOutputType> | number
          }
        }
      }
      cities: {
        payload: Prisma.$citiesPayload<ExtArgs>
        fields: Prisma.citiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.citiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.citiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          findFirst: {
            args: Prisma.citiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.citiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          findMany: {
            args: Prisma.citiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>[]
          }
          create: {
            args: Prisma.citiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          createMany: {
            args: Prisma.citiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.citiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>[]
          }
          delete: {
            args: Prisma.citiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          update: {
            args: Prisma.citiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          deleteMany: {
            args: Prisma.citiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.citiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.citiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>[]
          }
          upsert: {
            args: Prisma.citiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          aggregate: {
            args: Prisma.CitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCities>
          }
          groupBy: {
            args: Prisma.citiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.citiesCountArgs<ExtArgs>
            result: $Utils.Optional<CitiesCountAggregateOutputType> | number
          }
        }
      }
      medical_history: {
        payload: Prisma.$medical_historyPayload<ExtArgs>
        fields: Prisma.medical_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.medical_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.medical_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload>
          }
          findFirst: {
            args: Prisma.medical_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.medical_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload>
          }
          findMany: {
            args: Prisma.medical_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload>[]
          }
          create: {
            args: Prisma.medical_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload>
          }
          createMany: {
            args: Prisma.medical_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.medical_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload>[]
          }
          delete: {
            args: Prisma.medical_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload>
          }
          update: {
            args: Prisma.medical_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload>
          }
          deleteMany: {
            args: Prisma.medical_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.medical_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.medical_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload>[]
          }
          upsert: {
            args: Prisma.medical_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$medical_historyPayload>
          }
          aggregate: {
            args: Prisma.Medical_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedical_history>
          }
          groupBy: {
            args: Prisma.medical_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Medical_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.medical_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Medical_historyCountAggregateOutputType> | number
          }
        }
      }
      notifications: {
        payload: Prisma.$notificationsPayload<ExtArgs>
        fields: Prisma.notificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findFirst: {
            args: Prisma.notificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          findMany: {
            args: Prisma.notificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          create: {
            args: Prisma.notificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          createMany: {
            args: Prisma.notificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          delete: {
            args: Prisma.notificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          update: {
            args: Prisma.notificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          deleteMany: {
            args: Prisma.notificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>[]
          }
          upsert: {
            args: Prisma.notificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notificationsPayload>
          }
          aggregate: {
            args: Prisma.NotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotifications>
          }
          groupBy: {
            args: Prisma.notificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.notificationsCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationsCountAggregateOutputType> | number
          }
        }
      }
      patient_favorites: {
        payload: Prisma.$patient_favoritesPayload<ExtArgs>
        fields: Prisma.patient_favoritesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patient_favoritesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patient_favoritesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload>
          }
          findFirst: {
            args: Prisma.patient_favoritesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patient_favoritesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload>
          }
          findMany: {
            args: Prisma.patient_favoritesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload>[]
          }
          create: {
            args: Prisma.patient_favoritesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload>
          }
          createMany: {
            args: Prisma.patient_favoritesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.patient_favoritesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload>[]
          }
          delete: {
            args: Prisma.patient_favoritesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload>
          }
          update: {
            args: Prisma.patient_favoritesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload>
          }
          deleteMany: {
            args: Prisma.patient_favoritesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patient_favoritesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.patient_favoritesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload>[]
          }
          upsert: {
            args: Prisma.patient_favoritesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patient_favoritesPayload>
          }
          aggregate: {
            args: Prisma.Patient_favoritesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient_favorites>
          }
          groupBy: {
            args: Prisma.patient_favoritesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Patient_favoritesGroupByOutputType>[]
          }
          count: {
            args: Prisma.patient_favoritesCountArgs<ExtArgs>
            result: $Utils.Optional<Patient_favoritesCountAggregateOutputType> | number
          }
        }
      }
      patients: {
        payload: Prisma.$patientsPayload<ExtArgs>
        fields: Prisma.patientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.patientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.patientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          findFirst: {
            args: Prisma.patientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.patientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          findMany: {
            args: Prisma.patientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          create: {
            args: Prisma.patientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          createMany: {
            args: Prisma.patientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.patientsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          delete: {
            args: Prisma.patientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          update: {
            args: Prisma.patientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          deleteMany: {
            args: Prisma.patientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.patientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.patientsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>[]
          }
          upsert: {
            args: Prisma.patientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$patientsPayload>
          }
          aggregate: {
            args: Prisma.PatientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatients>
          }
          groupBy: {
            args: Prisma.patientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.patientsCountArgs<ExtArgs>
            result: $Utils.Optional<PatientsCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      payouts: {
        payload: Prisma.$payoutsPayload<ExtArgs>
        fields: Prisma.payoutsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.payoutsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.payoutsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload>
          }
          findFirst: {
            args: Prisma.payoutsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.payoutsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload>
          }
          findMany: {
            args: Prisma.payoutsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload>[]
          }
          create: {
            args: Prisma.payoutsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload>
          }
          createMany: {
            args: Prisma.payoutsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.payoutsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload>[]
          }
          delete: {
            args: Prisma.payoutsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload>
          }
          update: {
            args: Prisma.payoutsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload>
          }
          deleteMany: {
            args: Prisma.payoutsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.payoutsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.payoutsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload>[]
          }
          upsert: {
            args: Prisma.payoutsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$payoutsPayload>
          }
          aggregate: {
            args: Prisma.PayoutsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayouts>
          }
          groupBy: {
            args: Prisma.payoutsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayoutsGroupByOutputType>[]
          }
          count: {
            args: Prisma.payoutsCountArgs<ExtArgs>
            result: $Utils.Optional<PayoutsCountAggregateOutputType> | number
          }
        }
      }
      provider_ads: {
        payload: Prisma.$provider_adsPayload<ExtArgs>
        fields: Prisma.provider_adsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.provider_adsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.provider_adsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload>
          }
          findFirst: {
            args: Prisma.provider_adsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.provider_adsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload>
          }
          findMany: {
            args: Prisma.provider_adsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload>[]
          }
          create: {
            args: Prisma.provider_adsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload>
          }
          createMany: {
            args: Prisma.provider_adsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.provider_adsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload>[]
          }
          delete: {
            args: Prisma.provider_adsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload>
          }
          update: {
            args: Prisma.provider_adsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload>
          }
          deleteMany: {
            args: Prisma.provider_adsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.provider_adsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.provider_adsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload>[]
          }
          upsert: {
            args: Prisma.provider_adsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_adsPayload>
          }
          aggregate: {
            args: Prisma.Provider_adsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider_ads>
          }
          groupBy: {
            args: Prisma.provider_adsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Provider_adsGroupByOutputType>[]
          }
          count: {
            args: Prisma.provider_adsCountArgs<ExtArgs>
            result: $Utils.Optional<Provider_adsCountAggregateOutputType> | number
          }
        }
      }
      provider_bank_details: {
        payload: Prisma.$provider_bank_detailsPayload<ExtArgs>
        fields: Prisma.provider_bank_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.provider_bank_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.provider_bank_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload>
          }
          findFirst: {
            args: Prisma.provider_bank_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.provider_bank_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload>
          }
          findMany: {
            args: Prisma.provider_bank_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload>[]
          }
          create: {
            args: Prisma.provider_bank_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload>
          }
          createMany: {
            args: Prisma.provider_bank_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.provider_bank_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload>[]
          }
          delete: {
            args: Prisma.provider_bank_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload>
          }
          update: {
            args: Prisma.provider_bank_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload>
          }
          deleteMany: {
            args: Prisma.provider_bank_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.provider_bank_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.provider_bank_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload>[]
          }
          upsert: {
            args: Prisma.provider_bank_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_bank_detailsPayload>
          }
          aggregate: {
            args: Prisma.Provider_bank_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider_bank_details>
          }
          groupBy: {
            args: Prisma.provider_bank_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Provider_bank_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.provider_bank_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Provider_bank_detailsCountAggregateOutputType> | number
          }
        }
      }
      provider_branches: {
        payload: Prisma.$provider_branchesPayload<ExtArgs>
        fields: Prisma.provider_branchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.provider_branchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.provider_branchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload>
          }
          findFirst: {
            args: Prisma.provider_branchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.provider_branchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload>
          }
          findMany: {
            args: Prisma.provider_branchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload>[]
          }
          create: {
            args: Prisma.provider_branchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload>
          }
          createMany: {
            args: Prisma.provider_branchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.provider_branchesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload>[]
          }
          delete: {
            args: Prisma.provider_branchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload>
          }
          update: {
            args: Prisma.provider_branchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload>
          }
          deleteMany: {
            args: Prisma.provider_branchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.provider_branchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.provider_branchesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload>[]
          }
          upsert: {
            args: Prisma.provider_branchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_branchesPayload>
          }
          aggregate: {
            args: Prisma.Provider_branchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider_branches>
          }
          groupBy: {
            args: Prisma.provider_branchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Provider_branchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.provider_branchesCountArgs<ExtArgs>
            result: $Utils.Optional<Provider_branchesCountAggregateOutputType> | number
          }
        }
      }
      provider_catalog: {
        payload: Prisma.$provider_catalogPayload<ExtArgs>
        fields: Prisma.provider_catalogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.provider_catalogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.provider_catalogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload>
          }
          findFirst: {
            args: Prisma.provider_catalogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.provider_catalogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload>
          }
          findMany: {
            args: Prisma.provider_catalogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload>[]
          }
          create: {
            args: Prisma.provider_catalogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload>
          }
          createMany: {
            args: Prisma.provider_catalogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.provider_catalogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload>[]
          }
          delete: {
            args: Prisma.provider_catalogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload>
          }
          update: {
            args: Prisma.provider_catalogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload>
          }
          deleteMany: {
            args: Prisma.provider_catalogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.provider_catalogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.provider_catalogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload>[]
          }
          upsert: {
            args: Prisma.provider_catalogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_catalogPayload>
          }
          aggregate: {
            args: Prisma.Provider_catalogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider_catalog>
          }
          groupBy: {
            args: Prisma.provider_catalogGroupByArgs<ExtArgs>
            result: $Utils.Optional<Provider_catalogGroupByOutputType>[]
          }
          count: {
            args: Prisma.provider_catalogCountArgs<ExtArgs>
            result: $Utils.Optional<Provider_catalogCountAggregateOutputType> | number
          }
        }
      }
      provider_schedules: {
        payload: Prisma.$provider_schedulesPayload<ExtArgs>
        fields: Prisma.provider_schedulesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.provider_schedulesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.provider_schedulesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload>
          }
          findFirst: {
            args: Prisma.provider_schedulesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.provider_schedulesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload>
          }
          findMany: {
            args: Prisma.provider_schedulesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload>[]
          }
          create: {
            args: Prisma.provider_schedulesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload>
          }
          createMany: {
            args: Prisma.provider_schedulesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.provider_schedulesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload>[]
          }
          delete: {
            args: Prisma.provider_schedulesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload>
          }
          update: {
            args: Prisma.provider_schedulesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload>
          }
          deleteMany: {
            args: Prisma.provider_schedulesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.provider_schedulesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.provider_schedulesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload>[]
          }
          upsert: {
            args: Prisma.provider_schedulesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$provider_schedulesPayload>
          }
          aggregate: {
            args: Prisma.Provider_schedulesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider_schedules>
          }
          groupBy: {
            args: Prisma.provider_schedulesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Provider_schedulesGroupByOutputType>[]
          }
          count: {
            args: Prisma.provider_schedulesCountArgs<ExtArgs>
            result: $Utils.Optional<Provider_schedulesCountAggregateOutputType> | number
          }
        }
      }
      providers: {
        payload: Prisma.$providersPayload<ExtArgs>
        fields: Prisma.providersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.providersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.providersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          findFirst: {
            args: Prisma.providersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.providersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          findMany: {
            args: Prisma.providersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>[]
          }
          create: {
            args: Prisma.providersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          createMany: {
            args: Prisma.providersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.providersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>[]
          }
          delete: {
            args: Prisma.providersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          update: {
            args: Prisma.providersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          deleteMany: {
            args: Prisma.providersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.providersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.providersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>[]
          }
          upsert: {
            args: Prisma.providersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          aggregate: {
            args: Prisma.ProvidersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviders>
          }
          groupBy: {
            args: Prisma.providersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvidersGroupByOutputType>[]
          }
          count: {
            args: Prisma.providersCountArgs<ExtArgs>
            result: $Utils.Optional<ProvidersCountAggregateOutputType> | number
          }
        }
      }
      reviews: {
        payload: Prisma.$reviewsPayload<ExtArgs>
        fields: Prisma.reviewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reviewsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reviewsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findFirst: {
            args: Prisma.reviewsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reviewsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          findMany: {
            args: Prisma.reviewsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          create: {
            args: Prisma.reviewsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          createMany: {
            args: Prisma.reviewsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reviewsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          delete: {
            args: Prisma.reviewsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          update: {
            args: Prisma.reviewsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          deleteMany: {
            args: Prisma.reviewsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reviewsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reviewsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>[]
          }
          upsert: {
            args: Prisma.reviewsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reviewsPayload>
          }
          aggregate: {
            args: Prisma.ReviewsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviews>
          }
          groupBy: {
            args: Prisma.reviewsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.reviewsCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewsCountAggregateOutputType> | number
          }
        }
      }
      service_categories: {
        payload: Prisma.$service_categoriesPayload<ExtArgs>
        fields: Prisma.service_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.service_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.service_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload>
          }
          findFirst: {
            args: Prisma.service_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.service_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload>
          }
          findMany: {
            args: Prisma.service_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload>[]
          }
          create: {
            args: Prisma.service_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload>
          }
          createMany: {
            args: Prisma.service_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.service_categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload>[]
          }
          delete: {
            args: Prisma.service_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload>
          }
          update: {
            args: Prisma.service_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.service_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.service_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.service_categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload>[]
          }
          upsert: {
            args: Prisma.service_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$service_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Service_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService_categories>
          }
          groupBy: {
            args: Prisma.service_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Service_categoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.service_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Service_categoriesCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    appointments?: appointmentsOmit
    cities?: citiesOmit
    medical_history?: medical_historyOmit
    notifications?: notificationsOmit
    patient_favorites?: patient_favoritesOmit
    patients?: patientsOmit
    payments?: paymentsOmit
    payouts?: payoutsOmit
    provider_ads?: provider_adsOmit
    provider_bank_details?: provider_bank_detailsOmit
    provider_branches?: provider_branchesOmit
    provider_catalog?: provider_catalogOmit
    provider_schedules?: provider_schedulesOmit
    providers?: providersOmit
    reviews?: reviewsOmit
    service_categories?: service_categoriesOmit
    sessions?: sessionsOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AppointmentsCountOutputType
   */

  export type AppointmentsCountOutputType = {
    payments: number
    reviews: number
  }

  export type AppointmentsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | AppointmentsCountOutputTypeCountPaymentsArgs
    reviews?: boolean | AppointmentsCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * AppointmentsCountOutputType without action
   */
  export type AppointmentsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentsCountOutputType
     */
    select?: AppointmentsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentsCountOutputType without action
   */
  export type AppointmentsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * AppointmentsCountOutputType without action
   */
  export type AppointmentsCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }


  /**
   * Count Type CitiesCountOutputType
   */

  export type CitiesCountOutputType = {
    provider_branches: number
  }

  export type CitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | CitiesCountOutputTypeCountProvider_branchesArgs
  }

  // Custom InputTypes
  /**
   * CitiesCountOutputType without action
   */
  export type CitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitiesCountOutputType
     */
    select?: CitiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CitiesCountOutputType without action
   */
  export type CitiesCountOutputTypeCountProvider_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_branchesWhereInput
  }


  /**
   * Count Type PatientsCountOutputType
   */

  export type PatientsCountOutputType = {
    appointments: number
    medical_history: number
    notifications: number
    patient_favorites: number
    reviews: number
  }

  export type PatientsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PatientsCountOutputTypeCountAppointmentsArgs
    medical_history?: boolean | PatientsCountOutputTypeCountMedical_historyArgs
    notifications?: boolean | PatientsCountOutputTypeCountNotificationsArgs
    patient_favorites?: boolean | PatientsCountOutputTypeCountPatient_favoritesArgs
    reviews?: boolean | PatientsCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientsCountOutputType
     */
    select?: PatientsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountMedical_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medical_historyWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountPatient_favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_favoritesWhereInput
  }

  /**
   * PatientsCountOutputType without action
   */
  export type PatientsCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }


  /**
   * Count Type PayoutsCountOutputType
   */

  export type PayoutsCountOutputType = {
    payments: number
  }

  export type PayoutsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | PayoutsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * PayoutsCountOutputType without action
   */
  export type PayoutsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayoutsCountOutputType
     */
    select?: PayoutsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayoutsCountOutputType without action
   */
  export type PayoutsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type Provider_branchesCountOutputType
   */

  export type Provider_branchesCountOutputType = {
    appointments: number
    patient_favorites: number
    provider_schedules: number
    reviews: number
  }

  export type Provider_branchesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Provider_branchesCountOutputTypeCountAppointmentsArgs
    patient_favorites?: boolean | Provider_branchesCountOutputTypeCountPatient_favoritesArgs
    provider_schedules?: boolean | Provider_branchesCountOutputTypeCountProvider_schedulesArgs
    reviews?: boolean | Provider_branchesCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * Provider_branchesCountOutputType without action
   */
  export type Provider_branchesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider_branchesCountOutputType
     */
    select?: Provider_branchesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Provider_branchesCountOutputType without action
   */
  export type Provider_branchesCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }

  /**
   * Provider_branchesCountOutputType without action
   */
  export type Provider_branchesCountOutputTypeCountPatient_favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_favoritesWhereInput
  }

  /**
   * Provider_branchesCountOutputType without action
   */
  export type Provider_branchesCountOutputTypeCountProvider_schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_schedulesWhereInput
  }

  /**
   * Provider_branchesCountOutputType without action
   */
  export type Provider_branchesCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
  }


  /**
   * Count Type ProvidersCountOutputType
   */

  export type ProvidersCountOutputType = {
    appointments: number
    medical_history: number
    payouts: number
    provider_ads: number
    provider_bank_details: number
    provider_branches: number
    provider_catalog: number
  }

  export type ProvidersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | ProvidersCountOutputTypeCountAppointmentsArgs
    medical_history?: boolean | ProvidersCountOutputTypeCountMedical_historyArgs
    payouts?: boolean | ProvidersCountOutputTypeCountPayoutsArgs
    provider_ads?: boolean | ProvidersCountOutputTypeCountProvider_adsArgs
    provider_bank_details?: boolean | ProvidersCountOutputTypeCountProvider_bank_detailsArgs
    provider_branches?: boolean | ProvidersCountOutputTypeCountProvider_branchesArgs
    provider_catalog?: boolean | ProvidersCountOutputTypeCountProvider_catalogArgs
  }

  // Custom InputTypes
  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProvidersCountOutputType
     */
    select?: ProvidersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
  }

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountMedical_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medical_historyWhereInput
  }

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountPayoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payoutsWhereInput
  }

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountProvider_adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_adsWhereInput
  }

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountProvider_bank_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_bank_detailsWhereInput
  }

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountProvider_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_branchesWhereInput
  }

  /**
   * ProvidersCountOutputType without action
   */
  export type ProvidersCountOutputTypeCountProvider_catalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_catalogWhereInput
  }


  /**
   * Count Type Service_categoriesCountOutputType
   */

  export type Service_categoriesCountOutputType = {
    providers: number
  }

  export type Service_categoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | Service_categoriesCountOutputTypeCountProvidersArgs
  }

  // Custom InputTypes
  /**
   * Service_categoriesCountOutputType without action
   */
  export type Service_categoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service_categoriesCountOutputType
     */
    select?: Service_categoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Service_categoriesCountOutputType without action
   */
  export type Service_categoriesCountOutputTypeCountProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: providersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    patients: number
    providers: number
    sessions: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | UsersCountOutputTypeCountPatientsArgs
    providers?: boolean | UsersCountOutputTypeCountProvidersArgs
    sessions?: boolean | UsersCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patientsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: providersWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model appointments
   */

  export type AggregateAppointments = {
    _count: AppointmentsCountAggregateOutputType | null
    _min: AppointmentsMinAggregateOutputType | null
    _max: AppointmentsMaxAggregateOutputType | null
  }

  export type AppointmentsMinAggregateOutputType = {
    id: string | null
    patient_id: string | null
    branch_id: string | null
    provider_id: string | null
    scheduled_for: Date | null
    status: string | null
    reason: string | null
    is_paid: boolean | null
  }

  export type AppointmentsMaxAggregateOutputType = {
    id: string | null
    patient_id: string | null
    branch_id: string | null
    provider_id: string | null
    scheduled_for: Date | null
    status: string | null
    reason: string | null
    is_paid: boolean | null
  }

  export type AppointmentsCountAggregateOutputType = {
    id: number
    patient_id: number
    branch_id: number
    provider_id: number
    scheduled_for: number
    status: number
    reason: number
    is_paid: number
    _all: number
  }


  export type AppointmentsMinAggregateInputType = {
    id?: true
    patient_id?: true
    branch_id?: true
    provider_id?: true
    scheduled_for?: true
    status?: true
    reason?: true
    is_paid?: true
  }

  export type AppointmentsMaxAggregateInputType = {
    id?: true
    patient_id?: true
    branch_id?: true
    provider_id?: true
    scheduled_for?: true
    status?: true
    reason?: true
    is_paid?: true
  }

  export type AppointmentsCountAggregateInputType = {
    id?: true
    patient_id?: true
    branch_id?: true
    provider_id?: true
    scheduled_for?: true
    status?: true
    reason?: true
    is_paid?: true
    _all?: true
  }

  export type AppointmentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointments to aggregate.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned appointments
    **/
    _count?: true | AppointmentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentsMaxAggregateInputType
  }

  export type GetAppointmentsAggregateType<T extends AppointmentsAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointments[P]>
      : GetScalarType<T[P], AggregateAppointments[P]>
  }




  export type appointmentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithAggregationInput | appointmentsOrderByWithAggregationInput[]
    by: AppointmentsScalarFieldEnum[] | AppointmentsScalarFieldEnum
    having?: appointmentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentsCountAggregateInputType | true
    _min?: AppointmentsMinAggregateInputType
    _max?: AppointmentsMaxAggregateInputType
  }

  export type AppointmentsGroupByOutputType = {
    id: string
    patient_id: string | null
    branch_id: string | null
    provider_id: string | null
    scheduled_for: Date | null
    status: string | null
    reason: string | null
    is_paid: boolean | null
    _count: AppointmentsCountAggregateOutputType | null
    _min: AppointmentsMinAggregateOutputType | null
    _max: AppointmentsMaxAggregateOutputType | null
  }

  type GetAppointmentsGroupByPayload<T extends appointmentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentsGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentsGroupByOutputType[P]>
        }
      >
    >


  export type appointmentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    provider_id?: boolean
    scheduled_for?: boolean
    status?: boolean
    reason?: boolean
    is_paid?: boolean
    provider_branches?: boolean | appointments$provider_branchesArgs<ExtArgs>
    patients?: boolean | appointments$patientsArgs<ExtArgs>
    providers?: boolean | appointments$providersArgs<ExtArgs>
    payments?: boolean | appointments$paymentsArgs<ExtArgs>
    reviews?: boolean | appointments$reviewsArgs<ExtArgs>
    _count?: boolean | AppointmentsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointments"]>

  export type appointmentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    provider_id?: boolean
    scheduled_for?: boolean
    status?: boolean
    reason?: boolean
    is_paid?: boolean
    provider_branches?: boolean | appointments$provider_branchesArgs<ExtArgs>
    patients?: boolean | appointments$patientsArgs<ExtArgs>
    providers?: boolean | appointments$providersArgs<ExtArgs>
  }, ExtArgs["result"]["appointments"]>

  export type appointmentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    provider_id?: boolean
    scheduled_for?: boolean
    status?: boolean
    reason?: boolean
    is_paid?: boolean
    provider_branches?: boolean | appointments$provider_branchesArgs<ExtArgs>
    patients?: boolean | appointments$patientsArgs<ExtArgs>
    providers?: boolean | appointments$providersArgs<ExtArgs>
  }, ExtArgs["result"]["appointments"]>

  export type appointmentsSelectScalar = {
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    provider_id?: boolean
    scheduled_for?: boolean
    status?: boolean
    reason?: boolean
    is_paid?: boolean
  }

  export type appointmentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "branch_id" | "provider_id" | "scheduled_for" | "status" | "reason" | "is_paid", ExtArgs["result"]["appointments"]>
  export type appointmentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | appointments$provider_branchesArgs<ExtArgs>
    patients?: boolean | appointments$patientsArgs<ExtArgs>
    providers?: boolean | appointments$providersArgs<ExtArgs>
    payments?: boolean | appointments$paymentsArgs<ExtArgs>
    reviews?: boolean | appointments$reviewsArgs<ExtArgs>
    _count?: boolean | AppointmentsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type appointmentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | appointments$provider_branchesArgs<ExtArgs>
    patients?: boolean | appointments$patientsArgs<ExtArgs>
    providers?: boolean | appointments$providersArgs<ExtArgs>
  }
  export type appointmentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | appointments$provider_branchesArgs<ExtArgs>
    patients?: boolean | appointments$patientsArgs<ExtArgs>
    providers?: boolean | appointments$providersArgs<ExtArgs>
  }

  export type $appointmentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "appointments"
    objects: {
      provider_branches: Prisma.$provider_branchesPayload<ExtArgs> | null
      patients: Prisma.$patientsPayload<ExtArgs> | null
      providers: Prisma.$providersPayload<ExtArgs> | null
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      reviews: Prisma.$reviewsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patient_id: string | null
      branch_id: string | null
      provider_id: string | null
      scheduled_for: Date | null
      status: string | null
      reason: string | null
      is_paid: boolean | null
    }, ExtArgs["result"]["appointments"]>
    composites: {}
  }

  type appointmentsGetPayload<S extends boolean | null | undefined | appointmentsDefaultArgs> = $Result.GetResult<Prisma.$appointmentsPayload, S>

  type appointmentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<appointmentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppointmentsCountAggregateInputType | true
    }

  export interface appointmentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['appointments'], meta: { name: 'appointments' } }
    /**
     * Find zero or one Appointments that matches the filter.
     * @param {appointmentsFindUniqueArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends appointmentsFindUniqueArgs>(args: SelectSubset<T, appointmentsFindUniqueArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Appointments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {appointmentsFindUniqueOrThrowArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends appointmentsFindUniqueOrThrowArgs>(args: SelectSubset<T, appointmentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindFirstArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends appointmentsFindFirstArgs>(args?: SelectSubset<T, appointmentsFindFirstArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Appointments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindFirstOrThrowArgs} args - Arguments to find a Appointments
     * @example
     * // Get one Appointments
     * const appointments = await prisma.appointments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends appointmentsFindFirstOrThrowArgs>(args?: SelectSubset<T, appointmentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointments.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentsWithIdOnly = await prisma.appointments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends appointmentsFindManyArgs>(args?: SelectSubset<T, appointmentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Appointments.
     * @param {appointmentsCreateArgs} args - Arguments to create a Appointments.
     * @example
     * // Create one Appointments
     * const Appointments = await prisma.appointments.create({
     *   data: {
     *     // ... data to create a Appointments
     *   }
     * })
     * 
     */
    create<T extends appointmentsCreateArgs>(args: SelectSubset<T, appointmentsCreateArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Appointments.
     * @param {appointmentsCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointments = await prisma.appointments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends appointmentsCreateManyArgs>(args?: SelectSubset<T, appointmentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {appointmentsCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointments = await prisma.appointments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentsWithIdOnly = await prisma.appointments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends appointmentsCreateManyAndReturnArgs>(args?: SelectSubset<T, appointmentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Appointments.
     * @param {appointmentsDeleteArgs} args - Arguments to delete one Appointments.
     * @example
     * // Delete one Appointments
     * const Appointments = await prisma.appointments.delete({
     *   where: {
     *     // ... filter to delete one Appointments
     *   }
     * })
     * 
     */
    delete<T extends appointmentsDeleteArgs>(args: SelectSubset<T, appointmentsDeleteArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Appointments.
     * @param {appointmentsUpdateArgs} args - Arguments to update one Appointments.
     * @example
     * // Update one Appointments
     * const appointments = await prisma.appointments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends appointmentsUpdateArgs>(args: SelectSubset<T, appointmentsUpdateArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Appointments.
     * @param {appointmentsDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends appointmentsDeleteManyArgs>(args?: SelectSubset<T, appointmentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointments = await prisma.appointments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends appointmentsUpdateManyArgs>(args: SelectSubset<T, appointmentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments and returns the data updated in the database.
     * @param {appointmentsUpdateManyAndReturnArgs} args - Arguments to update many Appointments.
     * @example
     * // Update many Appointments
     * const appointments = await prisma.appointments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Appointments and only return the `id`
     * const appointmentsWithIdOnly = await prisma.appointments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends appointmentsUpdateManyAndReturnArgs>(args: SelectSubset<T, appointmentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Appointments.
     * @param {appointmentsUpsertArgs} args - Arguments to update or create a Appointments.
     * @example
     * // Update or create a Appointments
     * const appointments = await prisma.appointments.upsert({
     *   create: {
     *     // ... data to create a Appointments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointments we want to update
     *   }
     * })
     */
    upsert<T extends appointmentsUpsertArgs>(args: SelectSubset<T, appointmentsUpsertArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointments.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends appointmentsCountArgs>(
      args?: Subset<T, appointmentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentsAggregateArgs>(args: Subset<T, AppointmentsAggregateArgs>): Prisma.PrismaPromise<GetAppointmentsAggregateType<T>>

    /**
     * Group by Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {appointmentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends appointmentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: appointmentsGroupByArgs['orderBy'] }
        : { orderBy?: appointmentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, appointmentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the appointments model
   */
  readonly fields: appointmentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for appointments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__appointmentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider_branches<T extends appointments$provider_branchesArgs<ExtArgs> = {}>(args?: Subset<T, appointments$provider_branchesArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patients<T extends appointments$patientsArgs<ExtArgs> = {}>(args?: Subset<T, appointments$patientsArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    providers<T extends appointments$providersArgs<ExtArgs> = {}>(args?: Subset<T, appointments$providersArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends appointments$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, appointments$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends appointments$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, appointments$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the appointments model
   */
  interface appointmentsFieldRefs {
    readonly id: FieldRef<"appointments", 'String'>
    readonly patient_id: FieldRef<"appointments", 'String'>
    readonly branch_id: FieldRef<"appointments", 'String'>
    readonly provider_id: FieldRef<"appointments", 'String'>
    readonly scheduled_for: FieldRef<"appointments", 'DateTime'>
    readonly status: FieldRef<"appointments", 'String'>
    readonly reason: FieldRef<"appointments", 'String'>
    readonly is_paid: FieldRef<"appointments", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * appointments findUnique
   */
  export type appointmentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments findUniqueOrThrow
   */
  export type appointmentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments findFirst
   */
  export type appointmentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments findFirstOrThrow
   */
  export type appointmentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of appointments.
     */
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments findMany
   */
  export type appointmentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter, which appointments to fetch.
     */
    where?: appointmentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of appointments to fetch.
     */
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing appointments.
     */
    cursor?: appointmentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` appointments.
     */
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * appointments create
   */
  export type appointmentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * The data needed to create a appointments.
     */
    data: XOR<appointmentsCreateInput, appointmentsUncheckedCreateInput>
  }

  /**
   * appointments createMany
   */
  export type appointmentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many appointments.
     */
    data: appointmentsCreateManyInput | appointmentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * appointments createManyAndReturn
   */
  export type appointmentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * The data used to create many appointments.
     */
    data: appointmentsCreateManyInput | appointmentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * appointments update
   */
  export type appointmentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * The data needed to update a appointments.
     */
    data: XOR<appointmentsUpdateInput, appointmentsUncheckedUpdateInput>
    /**
     * Choose, which appointments to update.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments updateMany
   */
  export type appointmentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update appointments.
     */
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyInput>
    /**
     * Filter which appointments to update
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to update.
     */
    limit?: number
  }

  /**
   * appointments updateManyAndReturn
   */
  export type appointmentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * The data used to update appointments.
     */
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyInput>
    /**
     * Filter which appointments to update
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * appointments upsert
   */
  export type appointmentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * The filter to search for the appointments to update in case it exists.
     */
    where: appointmentsWhereUniqueInput
    /**
     * In case the appointments found by the `where` argument doesn't exist, create a new appointments with this data.
     */
    create: XOR<appointmentsCreateInput, appointmentsUncheckedCreateInput>
    /**
     * In case the appointments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<appointmentsUpdateInput, appointmentsUncheckedUpdateInput>
  }

  /**
   * appointments delete
   */
  export type appointmentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    /**
     * Filter which appointments to delete.
     */
    where: appointmentsWhereUniqueInput
  }

  /**
   * appointments deleteMany
   */
  export type appointmentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which appointments to delete
     */
    where?: appointmentsWhereInput
    /**
     * Limit how many appointments to delete.
     */
    limit?: number
  }

  /**
   * appointments.provider_branches
   */
  export type appointments$provider_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    where?: provider_branchesWhereInput
  }

  /**
   * appointments.patients
   */
  export type appointments$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    where?: patientsWhereInput
  }

  /**
   * appointments.providers
   */
  export type appointments$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
  }

  /**
   * appointments.payments
   */
  export type appointments$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * appointments.reviews
   */
  export type appointments$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * appointments without action
   */
  export type appointmentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
  }


  /**
   * Model cities
   */

  export type AggregateCities = {
    _count: CitiesCountAggregateOutputType | null
    _min: CitiesMinAggregateOutputType | null
    _max: CitiesMaxAggregateOutputType | null
  }

  export type CitiesMinAggregateOutputType = {
    id: string | null
    name: string | null
    state: string | null
    country: string | null
  }

  export type CitiesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    state: string | null
    country: string | null
  }

  export type CitiesCountAggregateOutputType = {
    id: number
    name: number
    state: number
    country: number
    _all: number
  }


  export type CitiesMinAggregateInputType = {
    id?: true
    name?: true
    state?: true
    country?: true
  }

  export type CitiesMaxAggregateInputType = {
    id?: true
    name?: true
    state?: true
    country?: true
  }

  export type CitiesCountAggregateInputType = {
    id?: true
    name?: true
    state?: true
    country?: true
    _all?: true
  }

  export type CitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cities to aggregate.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities
    **/
    _count?: true | CitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitiesMaxAggregateInputType
  }

  export type GetCitiesAggregateType<T extends CitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCities[P]>
      : GetScalarType<T[P], AggregateCities[P]>
  }




  export type citiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: citiesWhereInput
    orderBy?: citiesOrderByWithAggregationInput | citiesOrderByWithAggregationInput[]
    by: CitiesScalarFieldEnum[] | CitiesScalarFieldEnum
    having?: citiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitiesCountAggregateInputType | true
    _min?: CitiesMinAggregateInputType
    _max?: CitiesMaxAggregateInputType
  }

  export type CitiesGroupByOutputType = {
    id: string
    name: string
    state: string | null
    country: string | null
    _count: CitiesCountAggregateOutputType | null
    _min: CitiesMinAggregateOutputType | null
    _max: CitiesMaxAggregateOutputType | null
  }

  type GetCitiesGroupByPayload<T extends citiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitiesGroupByOutputType[P]>
            : GetScalarType<T[P], CitiesGroupByOutputType[P]>
        }
      >
    >


  export type citiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    state?: boolean
    country?: boolean
    provider_branches?: boolean | cities$provider_branchesArgs<ExtArgs>
    _count?: boolean | CitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cities"]>

  export type citiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    state?: boolean
    country?: boolean
  }, ExtArgs["result"]["cities"]>

  export type citiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    state?: boolean
    country?: boolean
  }, ExtArgs["result"]["cities"]>

  export type citiesSelectScalar = {
    id?: boolean
    name?: boolean
    state?: boolean
    country?: boolean
  }

  export type citiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "state" | "country", ExtArgs["result"]["cities"]>
  export type citiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | cities$provider_branchesArgs<ExtArgs>
    _count?: boolean | CitiesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type citiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type citiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $citiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cities"
    objects: {
      provider_branches: Prisma.$provider_branchesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      state: string | null
      country: string | null
    }, ExtArgs["result"]["cities"]>
    composites: {}
  }

  type citiesGetPayload<S extends boolean | null | undefined | citiesDefaultArgs> = $Result.GetResult<Prisma.$citiesPayload, S>

  type citiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<citiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CitiesCountAggregateInputType | true
    }

  export interface citiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cities'], meta: { name: 'cities' } }
    /**
     * Find zero or one Cities that matches the filter.
     * @param {citiesFindUniqueArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends citiesFindUniqueArgs>(args: SelectSubset<T, citiesFindUniqueArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {citiesFindUniqueOrThrowArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends citiesFindUniqueOrThrowArgs>(args: SelectSubset<T, citiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindFirstArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends citiesFindFirstArgs>(args?: SelectSubset<T, citiesFindFirstArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindFirstOrThrowArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends citiesFindFirstOrThrowArgs>(args?: SelectSubset<T, citiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.cities.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.cities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const citiesWithIdOnly = await prisma.cities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends citiesFindManyArgs>(args?: SelectSubset<T, citiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cities.
     * @param {citiesCreateArgs} args - Arguments to create a Cities.
     * @example
     * // Create one Cities
     * const Cities = await prisma.cities.create({
     *   data: {
     *     // ... data to create a Cities
     *   }
     * })
     * 
     */
    create<T extends citiesCreateArgs>(args: SelectSubset<T, citiesCreateArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {citiesCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const cities = await prisma.cities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends citiesCreateManyArgs>(args?: SelectSubset<T, citiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cities and returns the data saved in the database.
     * @param {citiesCreateManyAndReturnArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const cities = await prisma.cities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cities and only return the `id`
     * const citiesWithIdOnly = await prisma.cities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends citiesCreateManyAndReturnArgs>(args?: SelectSubset<T, citiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cities.
     * @param {citiesDeleteArgs} args - Arguments to delete one Cities.
     * @example
     * // Delete one Cities
     * const Cities = await prisma.cities.delete({
     *   where: {
     *     // ... filter to delete one Cities
     *   }
     * })
     * 
     */
    delete<T extends citiesDeleteArgs>(args: SelectSubset<T, citiesDeleteArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cities.
     * @param {citiesUpdateArgs} args - Arguments to update one Cities.
     * @example
     * // Update one Cities
     * const cities = await prisma.cities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends citiesUpdateArgs>(args: SelectSubset<T, citiesUpdateArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {citiesDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.cities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends citiesDeleteManyArgs>(args?: SelectSubset<T, citiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const cities = await prisma.cities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends citiesUpdateManyArgs>(args: SelectSubset<T, citiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities and returns the data updated in the database.
     * @param {citiesUpdateManyAndReturnArgs} args - Arguments to update many Cities.
     * @example
     * // Update many Cities
     * const cities = await prisma.cities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cities and only return the `id`
     * const citiesWithIdOnly = await prisma.cities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends citiesUpdateManyAndReturnArgs>(args: SelectSubset<T, citiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cities.
     * @param {citiesUpsertArgs} args - Arguments to update or create a Cities.
     * @example
     * // Update or create a Cities
     * const cities = await prisma.cities.upsert({
     *   create: {
     *     // ... data to create a Cities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cities we want to update
     *   }
     * })
     */
    upsert<T extends citiesUpsertArgs>(args: SelectSubset<T, citiesUpsertArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.cities.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends citiesCountArgs>(
      args?: Subset<T, citiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitiesAggregateArgs>(args: Subset<T, CitiesAggregateArgs>): Prisma.PrismaPromise<GetCitiesAggregateType<T>>

    /**
     * Group by Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends citiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: citiesGroupByArgs['orderBy'] }
        : { orderBy?: citiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, citiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cities model
   */
  readonly fields: citiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__citiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider_branches<T extends cities$provider_branchesArgs<ExtArgs> = {}>(args?: Subset<T, cities$provider_branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cities model
   */
  interface citiesFieldRefs {
    readonly id: FieldRef<"cities", 'String'>
    readonly name: FieldRef<"cities", 'String'>
    readonly state: FieldRef<"cities", 'String'>
    readonly country: FieldRef<"cities", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cities findUnique
   */
  export type citiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities findUniqueOrThrow
   */
  export type citiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities findFirst
   */
  export type citiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: CitiesScalarFieldEnum | CitiesScalarFieldEnum[]
  }

  /**
   * cities findFirstOrThrow
   */
  export type citiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: CitiesScalarFieldEnum | CitiesScalarFieldEnum[]
  }

  /**
   * cities findMany
   */
  export type citiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities.
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    distinct?: CitiesScalarFieldEnum | CitiesScalarFieldEnum[]
  }

  /**
   * cities create
   */
  export type citiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * The data needed to create a cities.
     */
    data: XOR<citiesCreateInput, citiesUncheckedCreateInput>
  }

  /**
   * cities createMany
   */
  export type citiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cities.
     */
    data: citiesCreateManyInput | citiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cities createManyAndReturn
   */
  export type citiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * The data used to create many cities.
     */
    data: citiesCreateManyInput | citiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cities update
   */
  export type citiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * The data needed to update a cities.
     */
    data: XOR<citiesUpdateInput, citiesUncheckedUpdateInput>
    /**
     * Choose, which cities to update.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities updateMany
   */
  export type citiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cities.
     */
    data: XOR<citiesUpdateManyMutationInput, citiesUncheckedUpdateManyInput>
    /**
     * Filter which cities to update
     */
    where?: citiesWhereInput
    /**
     * Limit how many cities to update.
     */
    limit?: number
  }

  /**
   * cities updateManyAndReturn
   */
  export type citiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * The data used to update cities.
     */
    data: XOR<citiesUpdateManyMutationInput, citiesUncheckedUpdateManyInput>
    /**
     * Filter which cities to update
     */
    where?: citiesWhereInput
    /**
     * Limit how many cities to update.
     */
    limit?: number
  }

  /**
   * cities upsert
   */
  export type citiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * The filter to search for the cities to update in case it exists.
     */
    where: citiesWhereUniqueInput
    /**
     * In case the cities found by the `where` argument doesn't exist, create a new cities with this data.
     */
    create: XOR<citiesCreateInput, citiesUncheckedCreateInput>
    /**
     * In case the cities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<citiesUpdateInput, citiesUncheckedUpdateInput>
  }

  /**
   * cities delete
   */
  export type citiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter which cities to delete.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities deleteMany
   */
  export type citiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cities to delete
     */
    where?: citiesWhereInput
    /**
     * Limit how many cities to delete.
     */
    limit?: number
  }

  /**
   * cities.provider_branches
   */
  export type cities$provider_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    where?: provider_branchesWhereInput
    orderBy?: provider_branchesOrderByWithRelationInput | provider_branchesOrderByWithRelationInput[]
    cursor?: provider_branchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Provider_branchesScalarFieldEnum | Provider_branchesScalarFieldEnum[]
  }

  /**
   * cities without action
   */
  export type citiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
  }


  /**
   * Model medical_history
   */

  export type AggregateMedical_history = {
    _count: Medical_historyCountAggregateOutputType | null
    _min: Medical_historyMinAggregateOutputType | null
    _max: Medical_historyMaxAggregateOutputType | null
  }

  export type Medical_historyMinAggregateOutputType = {
    id: string | null
    patient_id: string | null
    provider_id: string | null
    doctor_name_snapshot: string | null
    specialty_snapshot: string | null
    diagnosis: string | null
    date: Date | null
    treatment: string | null
    indications: string | null
    observations: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Medical_historyMaxAggregateOutputType = {
    id: string | null
    patient_id: string | null
    provider_id: string | null
    doctor_name_snapshot: string | null
    specialty_snapshot: string | null
    diagnosis: string | null
    date: Date | null
    treatment: string | null
    indications: string | null
    observations: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Medical_historyCountAggregateOutputType = {
    id: number
    patient_id: number
    provider_id: number
    doctor_name_snapshot: number
    specialty_snapshot: number
    diagnosis: number
    date: number
    treatment: number
    indications: number
    observations: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Medical_historyMinAggregateInputType = {
    id?: true
    patient_id?: true
    provider_id?: true
    doctor_name_snapshot?: true
    specialty_snapshot?: true
    diagnosis?: true
    date?: true
    treatment?: true
    indications?: true
    observations?: true
    created_at?: true
    updated_at?: true
  }

  export type Medical_historyMaxAggregateInputType = {
    id?: true
    patient_id?: true
    provider_id?: true
    doctor_name_snapshot?: true
    specialty_snapshot?: true
    diagnosis?: true
    date?: true
    treatment?: true
    indications?: true
    observations?: true
    created_at?: true
    updated_at?: true
  }

  export type Medical_historyCountAggregateInputType = {
    id?: true
    patient_id?: true
    provider_id?: true
    doctor_name_snapshot?: true
    specialty_snapshot?: true
    diagnosis?: true
    date?: true
    treatment?: true
    indications?: true
    observations?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Medical_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medical_history to aggregate.
     */
    where?: medical_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_histories to fetch.
     */
    orderBy?: medical_historyOrderByWithRelationInput | medical_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: medical_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned medical_histories
    **/
    _count?: true | Medical_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Medical_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Medical_historyMaxAggregateInputType
  }

  export type GetMedical_historyAggregateType<T extends Medical_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateMedical_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedical_history[P]>
      : GetScalarType<T[P], AggregateMedical_history[P]>
  }




  export type medical_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: medical_historyWhereInput
    orderBy?: medical_historyOrderByWithAggregationInput | medical_historyOrderByWithAggregationInput[]
    by: Medical_historyScalarFieldEnum[] | Medical_historyScalarFieldEnum
    having?: medical_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Medical_historyCountAggregateInputType | true
    _min?: Medical_historyMinAggregateInputType
    _max?: Medical_historyMaxAggregateInputType
  }

  export type Medical_historyGroupByOutputType = {
    id: string
    patient_id: string | null
    provider_id: string | null
    doctor_name_snapshot: string | null
    specialty_snapshot: string | null
    diagnosis: string | null
    date: Date | null
    treatment: string | null
    indications: string | null
    observations: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Medical_historyCountAggregateOutputType | null
    _min: Medical_historyMinAggregateOutputType | null
    _max: Medical_historyMaxAggregateOutputType | null
  }

  type GetMedical_historyGroupByPayload<T extends medical_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Medical_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Medical_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Medical_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Medical_historyGroupByOutputType[P]>
        }
      >
    >


  export type medical_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    provider_id?: boolean
    doctor_name_snapshot?: boolean
    specialty_snapshot?: boolean
    diagnosis?: boolean
    date?: boolean
    treatment?: boolean
    indications?: boolean
    observations?: boolean
    created_at?: boolean
    updated_at?: boolean
    patients?: boolean | medical_history$patientsArgs<ExtArgs>
    providers?: boolean | medical_history$providersArgs<ExtArgs>
  }, ExtArgs["result"]["medical_history"]>

  export type medical_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    provider_id?: boolean
    doctor_name_snapshot?: boolean
    specialty_snapshot?: boolean
    diagnosis?: boolean
    date?: boolean
    treatment?: boolean
    indications?: boolean
    observations?: boolean
    created_at?: boolean
    updated_at?: boolean
    patients?: boolean | medical_history$patientsArgs<ExtArgs>
    providers?: boolean | medical_history$providersArgs<ExtArgs>
  }, ExtArgs["result"]["medical_history"]>

  export type medical_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    provider_id?: boolean
    doctor_name_snapshot?: boolean
    specialty_snapshot?: boolean
    diagnosis?: boolean
    date?: boolean
    treatment?: boolean
    indications?: boolean
    observations?: boolean
    created_at?: boolean
    updated_at?: boolean
    patients?: boolean | medical_history$patientsArgs<ExtArgs>
    providers?: boolean | medical_history$providersArgs<ExtArgs>
  }, ExtArgs["result"]["medical_history"]>

  export type medical_historySelectScalar = {
    id?: boolean
    patient_id?: boolean
    provider_id?: boolean
    doctor_name_snapshot?: boolean
    specialty_snapshot?: boolean
    diagnosis?: boolean
    date?: boolean
    treatment?: boolean
    indications?: boolean
    observations?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type medical_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "provider_id" | "doctor_name_snapshot" | "specialty_snapshot" | "diagnosis" | "date" | "treatment" | "indications" | "observations" | "created_at" | "updated_at", ExtArgs["result"]["medical_history"]>
  export type medical_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | medical_history$patientsArgs<ExtArgs>
    providers?: boolean | medical_history$providersArgs<ExtArgs>
  }
  export type medical_historyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | medical_history$patientsArgs<ExtArgs>
    providers?: boolean | medical_history$providersArgs<ExtArgs>
  }
  export type medical_historyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | medical_history$patientsArgs<ExtArgs>
    providers?: boolean | medical_history$providersArgs<ExtArgs>
  }

  export type $medical_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "medical_history"
    objects: {
      patients: Prisma.$patientsPayload<ExtArgs> | null
      providers: Prisma.$providersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patient_id: string | null
      provider_id: string | null
      doctor_name_snapshot: string | null
      specialty_snapshot: string | null
      diagnosis: string | null
      date: Date | null
      treatment: string | null
      indications: string | null
      observations: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["medical_history"]>
    composites: {}
  }

  type medical_historyGetPayload<S extends boolean | null | undefined | medical_historyDefaultArgs> = $Result.GetResult<Prisma.$medical_historyPayload, S>

  type medical_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<medical_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Medical_historyCountAggregateInputType | true
    }

  export interface medical_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['medical_history'], meta: { name: 'medical_history' } }
    /**
     * Find zero or one Medical_history that matches the filter.
     * @param {medical_historyFindUniqueArgs} args - Arguments to find a Medical_history
     * @example
     * // Get one Medical_history
     * const medical_history = await prisma.medical_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends medical_historyFindUniqueArgs>(args: SelectSubset<T, medical_historyFindUniqueArgs<ExtArgs>>): Prisma__medical_historyClient<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Medical_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {medical_historyFindUniqueOrThrowArgs} args - Arguments to find a Medical_history
     * @example
     * // Get one Medical_history
     * const medical_history = await prisma.medical_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends medical_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, medical_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__medical_historyClient<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medical_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_historyFindFirstArgs} args - Arguments to find a Medical_history
     * @example
     * // Get one Medical_history
     * const medical_history = await prisma.medical_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends medical_historyFindFirstArgs>(args?: SelectSubset<T, medical_historyFindFirstArgs<ExtArgs>>): Prisma__medical_historyClient<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Medical_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_historyFindFirstOrThrowArgs} args - Arguments to find a Medical_history
     * @example
     * // Get one Medical_history
     * const medical_history = await prisma.medical_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends medical_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, medical_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__medical_historyClient<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Medical_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medical_histories
     * const medical_histories = await prisma.medical_history.findMany()
     * 
     * // Get first 10 Medical_histories
     * const medical_histories = await prisma.medical_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medical_historyWithIdOnly = await prisma.medical_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends medical_historyFindManyArgs>(args?: SelectSubset<T, medical_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Medical_history.
     * @param {medical_historyCreateArgs} args - Arguments to create a Medical_history.
     * @example
     * // Create one Medical_history
     * const Medical_history = await prisma.medical_history.create({
     *   data: {
     *     // ... data to create a Medical_history
     *   }
     * })
     * 
     */
    create<T extends medical_historyCreateArgs>(args: SelectSubset<T, medical_historyCreateArgs<ExtArgs>>): Prisma__medical_historyClient<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Medical_histories.
     * @param {medical_historyCreateManyArgs} args - Arguments to create many Medical_histories.
     * @example
     * // Create many Medical_histories
     * const medical_history = await prisma.medical_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends medical_historyCreateManyArgs>(args?: SelectSubset<T, medical_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medical_histories and returns the data saved in the database.
     * @param {medical_historyCreateManyAndReturnArgs} args - Arguments to create many Medical_histories.
     * @example
     * // Create many Medical_histories
     * const medical_history = await prisma.medical_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medical_histories and only return the `id`
     * const medical_historyWithIdOnly = await prisma.medical_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends medical_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, medical_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Medical_history.
     * @param {medical_historyDeleteArgs} args - Arguments to delete one Medical_history.
     * @example
     * // Delete one Medical_history
     * const Medical_history = await prisma.medical_history.delete({
     *   where: {
     *     // ... filter to delete one Medical_history
     *   }
     * })
     * 
     */
    delete<T extends medical_historyDeleteArgs>(args: SelectSubset<T, medical_historyDeleteArgs<ExtArgs>>): Prisma__medical_historyClient<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Medical_history.
     * @param {medical_historyUpdateArgs} args - Arguments to update one Medical_history.
     * @example
     * // Update one Medical_history
     * const medical_history = await prisma.medical_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends medical_historyUpdateArgs>(args: SelectSubset<T, medical_historyUpdateArgs<ExtArgs>>): Prisma__medical_historyClient<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Medical_histories.
     * @param {medical_historyDeleteManyArgs} args - Arguments to filter Medical_histories to delete.
     * @example
     * // Delete a few Medical_histories
     * const { count } = await prisma.medical_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends medical_historyDeleteManyArgs>(args?: SelectSubset<T, medical_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medical_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medical_histories
     * const medical_history = await prisma.medical_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends medical_historyUpdateManyArgs>(args: SelectSubset<T, medical_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medical_histories and returns the data updated in the database.
     * @param {medical_historyUpdateManyAndReturnArgs} args - Arguments to update many Medical_histories.
     * @example
     * // Update many Medical_histories
     * const medical_history = await prisma.medical_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Medical_histories and only return the `id`
     * const medical_historyWithIdOnly = await prisma.medical_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends medical_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, medical_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Medical_history.
     * @param {medical_historyUpsertArgs} args - Arguments to update or create a Medical_history.
     * @example
     * // Update or create a Medical_history
     * const medical_history = await prisma.medical_history.upsert({
     *   create: {
     *     // ... data to create a Medical_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medical_history we want to update
     *   }
     * })
     */
    upsert<T extends medical_historyUpsertArgs>(args: SelectSubset<T, medical_historyUpsertArgs<ExtArgs>>): Prisma__medical_historyClient<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Medical_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_historyCountArgs} args - Arguments to filter Medical_histories to count.
     * @example
     * // Count the number of Medical_histories
     * const count = await prisma.medical_history.count({
     *   where: {
     *     // ... the filter for the Medical_histories we want to count
     *   }
     * })
    **/
    count<T extends medical_historyCountArgs>(
      args?: Subset<T, medical_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Medical_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medical_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Medical_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Medical_historyAggregateArgs>(args: Subset<T, Medical_historyAggregateArgs>): Prisma.PrismaPromise<GetMedical_historyAggregateType<T>>

    /**
     * Group by Medical_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {medical_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends medical_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: medical_historyGroupByArgs['orderBy'] }
        : { orderBy?: medical_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, medical_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedical_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the medical_history model
   */
  readonly fields: medical_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for medical_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__medical_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patients<T extends medical_history$patientsArgs<ExtArgs> = {}>(args?: Subset<T, medical_history$patientsArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    providers<T extends medical_history$providersArgs<ExtArgs> = {}>(args?: Subset<T, medical_history$providersArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the medical_history model
   */
  interface medical_historyFieldRefs {
    readonly id: FieldRef<"medical_history", 'String'>
    readonly patient_id: FieldRef<"medical_history", 'String'>
    readonly provider_id: FieldRef<"medical_history", 'String'>
    readonly doctor_name_snapshot: FieldRef<"medical_history", 'String'>
    readonly specialty_snapshot: FieldRef<"medical_history", 'String'>
    readonly diagnosis: FieldRef<"medical_history", 'String'>
    readonly date: FieldRef<"medical_history", 'DateTime'>
    readonly treatment: FieldRef<"medical_history", 'String'>
    readonly indications: FieldRef<"medical_history", 'String'>
    readonly observations: FieldRef<"medical_history", 'String'>
    readonly created_at: FieldRef<"medical_history", 'DateTime'>
    readonly updated_at: FieldRef<"medical_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * medical_history findUnique
   */
  export type medical_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    /**
     * Filter, which medical_history to fetch.
     */
    where: medical_historyWhereUniqueInput
  }

  /**
   * medical_history findUniqueOrThrow
   */
  export type medical_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    /**
     * Filter, which medical_history to fetch.
     */
    where: medical_historyWhereUniqueInput
  }

  /**
   * medical_history findFirst
   */
  export type medical_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    /**
     * Filter, which medical_history to fetch.
     */
    where?: medical_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_histories to fetch.
     */
    orderBy?: medical_historyOrderByWithRelationInput | medical_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medical_histories.
     */
    cursor?: medical_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medical_histories.
     */
    distinct?: Medical_historyScalarFieldEnum | Medical_historyScalarFieldEnum[]
  }

  /**
   * medical_history findFirstOrThrow
   */
  export type medical_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    /**
     * Filter, which medical_history to fetch.
     */
    where?: medical_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_histories to fetch.
     */
    orderBy?: medical_historyOrderByWithRelationInput | medical_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for medical_histories.
     */
    cursor?: medical_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of medical_histories.
     */
    distinct?: Medical_historyScalarFieldEnum | Medical_historyScalarFieldEnum[]
  }

  /**
   * medical_history findMany
   */
  export type medical_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    /**
     * Filter, which medical_histories to fetch.
     */
    where?: medical_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of medical_histories to fetch.
     */
    orderBy?: medical_historyOrderByWithRelationInput | medical_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing medical_histories.
     */
    cursor?: medical_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` medical_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` medical_histories.
     */
    skip?: number
    distinct?: Medical_historyScalarFieldEnum | Medical_historyScalarFieldEnum[]
  }

  /**
   * medical_history create
   */
  export type medical_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a medical_history.
     */
    data: XOR<medical_historyCreateInput, medical_historyUncheckedCreateInput>
  }

  /**
   * medical_history createMany
   */
  export type medical_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many medical_histories.
     */
    data: medical_historyCreateManyInput | medical_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * medical_history createManyAndReturn
   */
  export type medical_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * The data used to create many medical_histories.
     */
    data: medical_historyCreateManyInput | medical_historyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * medical_history update
   */
  export type medical_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a medical_history.
     */
    data: XOR<medical_historyUpdateInput, medical_historyUncheckedUpdateInput>
    /**
     * Choose, which medical_history to update.
     */
    where: medical_historyWhereUniqueInput
  }

  /**
   * medical_history updateMany
   */
  export type medical_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update medical_histories.
     */
    data: XOR<medical_historyUpdateManyMutationInput, medical_historyUncheckedUpdateManyInput>
    /**
     * Filter which medical_histories to update
     */
    where?: medical_historyWhereInput
    /**
     * Limit how many medical_histories to update.
     */
    limit?: number
  }

  /**
   * medical_history updateManyAndReturn
   */
  export type medical_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * The data used to update medical_histories.
     */
    data: XOR<medical_historyUpdateManyMutationInput, medical_historyUncheckedUpdateManyInput>
    /**
     * Filter which medical_histories to update
     */
    where?: medical_historyWhereInput
    /**
     * Limit how many medical_histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * medical_history upsert
   */
  export type medical_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the medical_history to update in case it exists.
     */
    where: medical_historyWhereUniqueInput
    /**
     * In case the medical_history found by the `where` argument doesn't exist, create a new medical_history with this data.
     */
    create: XOR<medical_historyCreateInput, medical_historyUncheckedCreateInput>
    /**
     * In case the medical_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<medical_historyUpdateInput, medical_historyUncheckedUpdateInput>
  }

  /**
   * medical_history delete
   */
  export type medical_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    /**
     * Filter which medical_history to delete.
     */
    where: medical_historyWhereUniqueInput
  }

  /**
   * medical_history deleteMany
   */
  export type medical_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which medical_histories to delete
     */
    where?: medical_historyWhereInput
    /**
     * Limit how many medical_histories to delete.
     */
    limit?: number
  }

  /**
   * medical_history.patients
   */
  export type medical_history$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    where?: patientsWhereInput
  }

  /**
   * medical_history.providers
   */
  export type medical_history$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
  }

  /**
   * medical_history without action
   */
  export type medical_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
  }


  /**
   * Model notifications
   */

  export type AggregateNotifications = {
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  export type NotificationsMinAggregateOutputType = {
    id: string | null
    patient_id: string | null
    type: $Enums.enum_notif_types | null
    title: string | null
    body: string | null
    is_read: boolean | null
    created_at: Date | null
  }

  export type NotificationsMaxAggregateOutputType = {
    id: string | null
    patient_id: string | null
    type: $Enums.enum_notif_types | null
    title: string | null
    body: string | null
    is_read: boolean | null
    created_at: Date | null
  }

  export type NotificationsCountAggregateOutputType = {
    id: number
    patient_id: number
    type: number
    title: number
    body: number
    is_read: number
    data: number
    created_at: number
    _all: number
  }


  export type NotificationsMinAggregateInputType = {
    id?: true
    patient_id?: true
    type?: true
    title?: true
    body?: true
    is_read?: true
    created_at?: true
  }

  export type NotificationsMaxAggregateInputType = {
    id?: true
    patient_id?: true
    type?: true
    title?: true
    body?: true
    is_read?: true
    created_at?: true
  }

  export type NotificationsCountAggregateInputType = {
    id?: true
    patient_id?: true
    type?: true
    title?: true
    body?: true
    is_read?: true
    data?: true
    created_at?: true
    _all?: true
  }

  export type NotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to aggregate.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationsMaxAggregateInputType
  }

  export type GetNotificationsAggregateType<T extends NotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotifications[P]>
      : GetScalarType<T[P], AggregateNotifications[P]>
  }




  export type notificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithAggregationInput | notificationsOrderByWithAggregationInput[]
    by: NotificationsScalarFieldEnum[] | NotificationsScalarFieldEnum
    having?: notificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationsCountAggregateInputType | true
    _min?: NotificationsMinAggregateInputType
    _max?: NotificationsMaxAggregateInputType
  }

  export type NotificationsGroupByOutputType = {
    id: string
    patient_id: string
    type: $Enums.enum_notif_types
    title: string
    body: string
    is_read: boolean | null
    data: JsonValue | null
    created_at: Date | null
    _count: NotificationsCountAggregateOutputType | null
    _min: NotificationsMinAggregateOutputType | null
    _max: NotificationsMaxAggregateOutputType | null
  }

  type GetNotificationsGroupByPayload<T extends notificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationsGroupByOutputType[P]>
        }
      >
    >


  export type notificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    is_read?: boolean
    data?: boolean
    created_at?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    is_read?: boolean
    data?: boolean
    created_at?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    is_read?: boolean
    data?: boolean
    created_at?: boolean
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notifications"]>

  export type notificationsSelectScalar = {
    id?: boolean
    patient_id?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    is_read?: boolean
    data?: boolean
    created_at?: boolean
  }

  export type notificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "type" | "title" | "body" | "is_read" | "data" | "created_at", ExtArgs["result"]["notifications"]>
  export type notificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }
  export type notificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | patientsDefaultArgs<ExtArgs>
  }

  export type $notificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notifications"
    objects: {
      patients: Prisma.$patientsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patient_id: string
      type: $Enums.enum_notif_types
      title: string
      body: string
      is_read: boolean | null
      data: Prisma.JsonValue | null
      created_at: Date | null
    }, ExtArgs["result"]["notifications"]>
    composites: {}
  }

  type notificationsGetPayload<S extends boolean | null | undefined | notificationsDefaultArgs> = $Result.GetResult<Prisma.$notificationsPayload, S>

  type notificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationsCountAggregateInputType | true
    }

  export interface notificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notifications'], meta: { name: 'notifications' } }
    /**
     * Find zero or one Notifications that matches the filter.
     * @param {notificationsFindUniqueArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notificationsFindUniqueArgs>(args: SelectSubset<T, notificationsFindUniqueArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notificationsFindUniqueOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, notificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notificationsFindFirstArgs>(args?: SelectSubset<T, notificationsFindFirstArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindFirstOrThrowArgs} args - Arguments to find a Notifications
     * @example
     * // Get one Notifications
     * const notifications = await prisma.notifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, notificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notifications.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationsWithIdOnly = await prisma.notifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notificationsFindManyArgs>(args?: SelectSubset<T, notificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notifications.
     * @param {notificationsCreateArgs} args - Arguments to create a Notifications.
     * @example
     * // Create one Notifications
     * const Notifications = await prisma.notifications.create({
     *   data: {
     *     // ... data to create a Notifications
     *   }
     * })
     * 
     */
    create<T extends notificationsCreateArgs>(args: SelectSubset<T, notificationsCreateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {notificationsCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notificationsCreateManyArgs>(args?: SelectSubset<T, notificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {notificationsCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notifications = await prisma.notifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, notificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notifications.
     * @param {notificationsDeleteArgs} args - Arguments to delete one Notifications.
     * @example
     * // Delete one Notifications
     * const Notifications = await prisma.notifications.delete({
     *   where: {
     *     // ... filter to delete one Notifications
     *   }
     * })
     * 
     */
    delete<T extends notificationsDeleteArgs>(args: SelectSubset<T, notificationsDeleteArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notifications.
     * @param {notificationsUpdateArgs} args - Arguments to update one Notifications.
     * @example
     * // Update one Notifications
     * const notifications = await prisma.notifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notificationsUpdateArgs>(args: SelectSubset<T, notificationsUpdateArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {notificationsDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notificationsDeleteManyArgs>(args?: SelectSubset<T, notificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notificationsUpdateManyArgs>(args: SelectSubset<T, notificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {notificationsUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notifications = await prisma.notifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationsWithIdOnly = await prisma.notifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, notificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notifications.
     * @param {notificationsUpsertArgs} args - Arguments to update or create a Notifications.
     * @example
     * // Update or create a Notifications
     * const notifications = await prisma.notifications.upsert({
     *   create: {
     *     // ... data to create a Notifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notifications we want to update
     *   }
     * })
     */
    upsert<T extends notificationsUpsertArgs>(args: SelectSubset<T, notificationsUpsertArgs<ExtArgs>>): Prisma__notificationsClient<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notifications.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationsCountArgs>(
      args?: Subset<T, notificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationsAggregateArgs>(args: Subset<T, NotificationsAggregateArgs>): Prisma.PrismaPromise<GetNotificationsAggregateType<T>>

    /**
     * Group by Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notificationsGroupByArgs['orderBy'] }
        : { orderBy?: notificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notifications model
   */
  readonly fields: notificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patients<T extends patientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, patientsDefaultArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notifications model
   */
  interface notificationsFieldRefs {
    readonly id: FieldRef<"notifications", 'String'>
    readonly patient_id: FieldRef<"notifications", 'String'>
    readonly type: FieldRef<"notifications", 'enum_notif_types'>
    readonly title: FieldRef<"notifications", 'String'>
    readonly body: FieldRef<"notifications", 'String'>
    readonly is_read: FieldRef<"notifications", 'Boolean'>
    readonly data: FieldRef<"notifications", 'Json'>
    readonly created_at: FieldRef<"notifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * notifications findUnique
   */
  export type notificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findUniqueOrThrow
   */
  export type notificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications findFirst
   */
  export type notificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findFirstOrThrow
   */
  export type notificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications findMany
   */
  export type notificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * notifications create
   */
  export type notificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a notifications.
     */
    data: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
  }

  /**
   * notifications createMany
   */
  export type notificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notifications createManyAndReturn
   */
  export type notificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to create many notifications.
     */
    data: notificationsCreateManyInput | notificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications update
   */
  export type notificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a notifications.
     */
    data: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
    /**
     * Choose, which notifications to update.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications updateMany
   */
  export type notificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
  }

  /**
   * notifications updateManyAndReturn
   */
  export type notificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * notifications upsert
   */
  export type notificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the notifications to update in case it exists.
     */
    where: notificationsWhereUniqueInput
    /**
     * In case the notifications found by the `where` argument doesn't exist, create a new notifications with this data.
     */
    create: XOR<notificationsCreateInput, notificationsUncheckedCreateInput>
    /**
     * In case the notifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationsUpdateInput, notificationsUncheckedUpdateInput>
  }

  /**
   * notifications delete
   */
  export type notificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    /**
     * Filter which notifications to delete.
     */
    where: notificationsWhereUniqueInput
  }

  /**
   * notifications deleteMany
   */
  export type notificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationsWhereInput
    /**
     * Limit how many notifications to delete.
     */
    limit?: number
  }

  /**
   * notifications without action
   */
  export type notificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
  }


  /**
   * Model patient_favorites
   */

  export type AggregatePatient_favorites = {
    _count: Patient_favoritesCountAggregateOutputType | null
    _min: Patient_favoritesMinAggregateOutputType | null
    _max: Patient_favoritesMaxAggregateOutputType | null
  }

  export type Patient_favoritesMinAggregateOutputType = {
    id: string | null
    patient_id: string | null
    branch_id: string | null
    created_at: Date | null
  }

  export type Patient_favoritesMaxAggregateOutputType = {
    id: string | null
    patient_id: string | null
    branch_id: string | null
    created_at: Date | null
  }

  export type Patient_favoritesCountAggregateOutputType = {
    id: number
    patient_id: number
    branch_id: number
    created_at: number
    _all: number
  }


  export type Patient_favoritesMinAggregateInputType = {
    id?: true
    patient_id?: true
    branch_id?: true
    created_at?: true
  }

  export type Patient_favoritesMaxAggregateInputType = {
    id?: true
    patient_id?: true
    branch_id?: true
    created_at?: true
  }

  export type Patient_favoritesCountAggregateInputType = {
    id?: true
    patient_id?: true
    branch_id?: true
    created_at?: true
    _all?: true
  }

  export type Patient_favoritesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_favorites to aggregate.
     */
    where?: patient_favoritesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_favorites to fetch.
     */
    orderBy?: patient_favoritesOrderByWithRelationInput | patient_favoritesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patient_favoritesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patient_favorites
    **/
    _count?: true | Patient_favoritesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Patient_favoritesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Patient_favoritesMaxAggregateInputType
  }

  export type GetPatient_favoritesAggregateType<T extends Patient_favoritesAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient_favorites]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient_favorites[P]>
      : GetScalarType<T[P], AggregatePatient_favorites[P]>
  }




  export type patient_favoritesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patient_favoritesWhereInput
    orderBy?: patient_favoritesOrderByWithAggregationInput | patient_favoritesOrderByWithAggregationInput[]
    by: Patient_favoritesScalarFieldEnum[] | Patient_favoritesScalarFieldEnum
    having?: patient_favoritesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Patient_favoritesCountAggregateInputType | true
    _min?: Patient_favoritesMinAggregateInputType
    _max?: Patient_favoritesMaxAggregateInputType
  }

  export type Patient_favoritesGroupByOutputType = {
    id: string
    patient_id: string | null
    branch_id: string | null
    created_at: Date | null
    _count: Patient_favoritesCountAggregateOutputType | null
    _min: Patient_favoritesMinAggregateOutputType | null
    _max: Patient_favoritesMaxAggregateOutputType | null
  }

  type GetPatient_favoritesGroupByPayload<T extends patient_favoritesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Patient_favoritesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Patient_favoritesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Patient_favoritesGroupByOutputType[P]>
            : GetScalarType<T[P], Patient_favoritesGroupByOutputType[P]>
        }
      >
    >


  export type patient_favoritesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    created_at?: boolean
    provider_branches?: boolean | patient_favorites$provider_branchesArgs<ExtArgs>
    patients?: boolean | patient_favorites$patientsArgs<ExtArgs>
  }, ExtArgs["result"]["patient_favorites"]>

  export type patient_favoritesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    created_at?: boolean
    provider_branches?: boolean | patient_favorites$provider_branchesArgs<ExtArgs>
    patients?: boolean | patient_favorites$patientsArgs<ExtArgs>
  }, ExtArgs["result"]["patient_favorites"]>

  export type patient_favoritesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    created_at?: boolean
    provider_branches?: boolean | patient_favorites$provider_branchesArgs<ExtArgs>
    patients?: boolean | patient_favorites$patientsArgs<ExtArgs>
  }, ExtArgs["result"]["patient_favorites"]>

  export type patient_favoritesSelectScalar = {
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    created_at?: boolean
  }

  export type patient_favoritesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "branch_id" | "created_at", ExtArgs["result"]["patient_favorites"]>
  export type patient_favoritesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | patient_favorites$provider_branchesArgs<ExtArgs>
    patients?: boolean | patient_favorites$patientsArgs<ExtArgs>
  }
  export type patient_favoritesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | patient_favorites$provider_branchesArgs<ExtArgs>
    patients?: boolean | patient_favorites$patientsArgs<ExtArgs>
  }
  export type patient_favoritesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | patient_favorites$provider_branchesArgs<ExtArgs>
    patients?: boolean | patient_favorites$patientsArgs<ExtArgs>
  }

  export type $patient_favoritesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patient_favorites"
    objects: {
      provider_branches: Prisma.$provider_branchesPayload<ExtArgs> | null
      patients: Prisma.$patientsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patient_id: string | null
      branch_id: string | null
      created_at: Date | null
    }, ExtArgs["result"]["patient_favorites"]>
    composites: {}
  }

  type patient_favoritesGetPayload<S extends boolean | null | undefined | patient_favoritesDefaultArgs> = $Result.GetResult<Prisma.$patient_favoritesPayload, S>

  type patient_favoritesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<patient_favoritesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Patient_favoritesCountAggregateInputType | true
    }

  export interface patient_favoritesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patient_favorites'], meta: { name: 'patient_favorites' } }
    /**
     * Find zero or one Patient_favorites that matches the filter.
     * @param {patient_favoritesFindUniqueArgs} args - Arguments to find a Patient_favorites
     * @example
     * // Get one Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patient_favoritesFindUniqueArgs>(args: SelectSubset<T, patient_favoritesFindUniqueArgs<ExtArgs>>): Prisma__patient_favoritesClient<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patient_favorites that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {patient_favoritesFindUniqueOrThrowArgs} args - Arguments to find a Patient_favorites
     * @example
     * // Get one Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patient_favoritesFindUniqueOrThrowArgs>(args: SelectSubset<T, patient_favoritesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patient_favoritesClient<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient_favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_favoritesFindFirstArgs} args - Arguments to find a Patient_favorites
     * @example
     * // Get one Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patient_favoritesFindFirstArgs>(args?: SelectSubset<T, patient_favoritesFindFirstArgs<ExtArgs>>): Prisma__patient_favoritesClient<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patient_favorites that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_favoritesFindFirstOrThrowArgs} args - Arguments to find a Patient_favorites
     * @example
     * // Get one Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patient_favoritesFindFirstOrThrowArgs>(args?: SelectSubset<T, patient_favoritesFindFirstOrThrowArgs<ExtArgs>>): Prisma__patient_favoritesClient<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patient_favorites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_favoritesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.findMany()
     * 
     * // Get first 10 Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patient_favoritesWithIdOnly = await prisma.patient_favorites.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends patient_favoritesFindManyArgs>(args?: SelectSubset<T, patient_favoritesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patient_favorites.
     * @param {patient_favoritesCreateArgs} args - Arguments to create a Patient_favorites.
     * @example
     * // Create one Patient_favorites
     * const Patient_favorites = await prisma.patient_favorites.create({
     *   data: {
     *     // ... data to create a Patient_favorites
     *   }
     * })
     * 
     */
    create<T extends patient_favoritesCreateArgs>(args: SelectSubset<T, patient_favoritesCreateArgs<ExtArgs>>): Prisma__patient_favoritesClient<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patient_favorites.
     * @param {patient_favoritesCreateManyArgs} args - Arguments to create many Patient_favorites.
     * @example
     * // Create many Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patient_favoritesCreateManyArgs>(args?: SelectSubset<T, patient_favoritesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patient_favorites and returns the data saved in the database.
     * @param {patient_favoritesCreateManyAndReturnArgs} args - Arguments to create many Patient_favorites.
     * @example
     * // Create many Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patient_favorites and only return the `id`
     * const patient_favoritesWithIdOnly = await prisma.patient_favorites.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends patient_favoritesCreateManyAndReturnArgs>(args?: SelectSubset<T, patient_favoritesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patient_favorites.
     * @param {patient_favoritesDeleteArgs} args - Arguments to delete one Patient_favorites.
     * @example
     * // Delete one Patient_favorites
     * const Patient_favorites = await prisma.patient_favorites.delete({
     *   where: {
     *     // ... filter to delete one Patient_favorites
     *   }
     * })
     * 
     */
    delete<T extends patient_favoritesDeleteArgs>(args: SelectSubset<T, patient_favoritesDeleteArgs<ExtArgs>>): Prisma__patient_favoritesClient<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patient_favorites.
     * @param {patient_favoritesUpdateArgs} args - Arguments to update one Patient_favorites.
     * @example
     * // Update one Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patient_favoritesUpdateArgs>(args: SelectSubset<T, patient_favoritesUpdateArgs<ExtArgs>>): Prisma__patient_favoritesClient<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patient_favorites.
     * @param {patient_favoritesDeleteManyArgs} args - Arguments to filter Patient_favorites to delete.
     * @example
     * // Delete a few Patient_favorites
     * const { count } = await prisma.patient_favorites.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patient_favoritesDeleteManyArgs>(args?: SelectSubset<T, patient_favoritesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_favoritesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patient_favoritesUpdateManyArgs>(args: SelectSubset<T, patient_favoritesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patient_favorites and returns the data updated in the database.
     * @param {patient_favoritesUpdateManyAndReturnArgs} args - Arguments to update many Patient_favorites.
     * @example
     * // Update many Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patient_favorites and only return the `id`
     * const patient_favoritesWithIdOnly = await prisma.patient_favorites.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends patient_favoritesUpdateManyAndReturnArgs>(args: SelectSubset<T, patient_favoritesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patient_favorites.
     * @param {patient_favoritesUpsertArgs} args - Arguments to update or create a Patient_favorites.
     * @example
     * // Update or create a Patient_favorites
     * const patient_favorites = await prisma.patient_favorites.upsert({
     *   create: {
     *     // ... data to create a Patient_favorites
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient_favorites we want to update
     *   }
     * })
     */
    upsert<T extends patient_favoritesUpsertArgs>(args: SelectSubset<T, patient_favoritesUpsertArgs<ExtArgs>>): Prisma__patient_favoritesClient<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patient_favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_favoritesCountArgs} args - Arguments to filter Patient_favorites to count.
     * @example
     * // Count the number of Patient_favorites
     * const count = await prisma.patient_favorites.count({
     *   where: {
     *     // ... the filter for the Patient_favorites we want to count
     *   }
     * })
    **/
    count<T extends patient_favoritesCountArgs>(
      args?: Subset<T, patient_favoritesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Patient_favoritesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient_favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Patient_favoritesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Patient_favoritesAggregateArgs>(args: Subset<T, Patient_favoritesAggregateArgs>): Prisma.PrismaPromise<GetPatient_favoritesAggregateType<T>>

    /**
     * Group by Patient_favorites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patient_favoritesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patient_favoritesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patient_favoritesGroupByArgs['orderBy'] }
        : { orderBy?: patient_favoritesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patient_favoritesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatient_favoritesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patient_favorites model
   */
  readonly fields: patient_favoritesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patient_favorites.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patient_favoritesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider_branches<T extends patient_favorites$provider_branchesArgs<ExtArgs> = {}>(args?: Subset<T, patient_favorites$provider_branchesArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patients<T extends patient_favorites$patientsArgs<ExtArgs> = {}>(args?: Subset<T, patient_favorites$patientsArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patient_favorites model
   */
  interface patient_favoritesFieldRefs {
    readonly id: FieldRef<"patient_favorites", 'String'>
    readonly patient_id: FieldRef<"patient_favorites", 'String'>
    readonly branch_id: FieldRef<"patient_favorites", 'String'>
    readonly created_at: FieldRef<"patient_favorites", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * patient_favorites findUnique
   */
  export type patient_favoritesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    /**
     * Filter, which patient_favorites to fetch.
     */
    where: patient_favoritesWhereUniqueInput
  }

  /**
   * patient_favorites findUniqueOrThrow
   */
  export type patient_favoritesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    /**
     * Filter, which patient_favorites to fetch.
     */
    where: patient_favoritesWhereUniqueInput
  }

  /**
   * patient_favorites findFirst
   */
  export type patient_favoritesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    /**
     * Filter, which patient_favorites to fetch.
     */
    where?: patient_favoritesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_favorites to fetch.
     */
    orderBy?: patient_favoritesOrderByWithRelationInput | patient_favoritesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_favorites.
     */
    cursor?: patient_favoritesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_favorites.
     */
    distinct?: Patient_favoritesScalarFieldEnum | Patient_favoritesScalarFieldEnum[]
  }

  /**
   * patient_favorites findFirstOrThrow
   */
  export type patient_favoritesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    /**
     * Filter, which patient_favorites to fetch.
     */
    where?: patient_favoritesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_favorites to fetch.
     */
    orderBy?: patient_favoritesOrderByWithRelationInput | patient_favoritesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patient_favorites.
     */
    cursor?: patient_favoritesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_favorites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patient_favorites.
     */
    distinct?: Patient_favoritesScalarFieldEnum | Patient_favoritesScalarFieldEnum[]
  }

  /**
   * patient_favorites findMany
   */
  export type patient_favoritesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    /**
     * Filter, which patient_favorites to fetch.
     */
    where?: patient_favoritesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patient_favorites to fetch.
     */
    orderBy?: patient_favoritesOrderByWithRelationInput | patient_favoritesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patient_favorites.
     */
    cursor?: patient_favoritesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patient_favorites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patient_favorites.
     */
    skip?: number
    distinct?: Patient_favoritesScalarFieldEnum | Patient_favoritesScalarFieldEnum[]
  }

  /**
   * patient_favorites create
   */
  export type patient_favoritesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    /**
     * The data needed to create a patient_favorites.
     */
    data: XOR<patient_favoritesCreateInput, patient_favoritesUncheckedCreateInput>
  }

  /**
   * patient_favorites createMany
   */
  export type patient_favoritesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patient_favorites.
     */
    data: patient_favoritesCreateManyInput | patient_favoritesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patient_favorites createManyAndReturn
   */
  export type patient_favoritesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * The data used to create many patient_favorites.
     */
    data: patient_favoritesCreateManyInput | patient_favoritesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * patient_favorites update
   */
  export type patient_favoritesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    /**
     * The data needed to update a patient_favorites.
     */
    data: XOR<patient_favoritesUpdateInput, patient_favoritesUncheckedUpdateInput>
    /**
     * Choose, which patient_favorites to update.
     */
    where: patient_favoritesWhereUniqueInput
  }

  /**
   * patient_favorites updateMany
   */
  export type patient_favoritesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patient_favorites.
     */
    data: XOR<patient_favoritesUpdateManyMutationInput, patient_favoritesUncheckedUpdateManyInput>
    /**
     * Filter which patient_favorites to update
     */
    where?: patient_favoritesWhereInput
    /**
     * Limit how many patient_favorites to update.
     */
    limit?: number
  }

  /**
   * patient_favorites updateManyAndReturn
   */
  export type patient_favoritesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * The data used to update patient_favorites.
     */
    data: XOR<patient_favoritesUpdateManyMutationInput, patient_favoritesUncheckedUpdateManyInput>
    /**
     * Filter which patient_favorites to update
     */
    where?: patient_favoritesWhereInput
    /**
     * Limit how many patient_favorites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * patient_favorites upsert
   */
  export type patient_favoritesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    /**
     * The filter to search for the patient_favorites to update in case it exists.
     */
    where: patient_favoritesWhereUniqueInput
    /**
     * In case the patient_favorites found by the `where` argument doesn't exist, create a new patient_favorites with this data.
     */
    create: XOR<patient_favoritesCreateInput, patient_favoritesUncheckedCreateInput>
    /**
     * In case the patient_favorites was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patient_favoritesUpdateInput, patient_favoritesUncheckedUpdateInput>
  }

  /**
   * patient_favorites delete
   */
  export type patient_favoritesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    /**
     * Filter which patient_favorites to delete.
     */
    where: patient_favoritesWhereUniqueInput
  }

  /**
   * patient_favorites deleteMany
   */
  export type patient_favoritesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patient_favorites to delete
     */
    where?: patient_favoritesWhereInput
    /**
     * Limit how many patient_favorites to delete.
     */
    limit?: number
  }

  /**
   * patient_favorites.provider_branches
   */
  export type patient_favorites$provider_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    where?: provider_branchesWhereInput
  }

  /**
   * patient_favorites.patients
   */
  export type patient_favorites$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    where?: patientsWhereInput
  }

  /**
   * patient_favorites without action
   */
  export type patient_favoritesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
  }


  /**
   * Model patients
   */

  export type AggregatePatients = {
    _count: PatientsCountAggregateOutputType | null
    _min: PatientsMinAggregateOutputType | null
    _max: PatientsMaxAggregateOutputType | null
  }

  export type PatientsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    full_name: string | null
    identification: string | null
    phone: string | null
    birth_date: Date | null
    address_text: string | null
  }

  export type PatientsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    full_name: string | null
    identification: string | null
    phone: string | null
    birth_date: Date | null
    address_text: string | null
  }

  export type PatientsCountAggregateOutputType = {
    id: number
    user_id: number
    full_name: number
    identification: number
    phone: number
    birth_date: number
    address_text: number
    _all: number
  }


  export type PatientsMinAggregateInputType = {
    id?: true
    user_id?: true
    full_name?: true
    identification?: true
    phone?: true
    birth_date?: true
    address_text?: true
  }

  export type PatientsMaxAggregateInputType = {
    id?: true
    user_id?: true
    full_name?: true
    identification?: true
    phone?: true
    birth_date?: true
    address_text?: true
  }

  export type PatientsCountAggregateInputType = {
    id?: true
    user_id?: true
    full_name?: true
    identification?: true
    phone?: true
    birth_date?: true
    address_text?: true
    _all?: true
  }

  export type PatientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patients to aggregate.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned patients
    **/
    _count?: true | PatientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientsMaxAggregateInputType
  }

  export type GetPatientsAggregateType<T extends PatientsAggregateArgs> = {
        [P in keyof T & keyof AggregatePatients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatients[P]>
      : GetScalarType<T[P], AggregatePatients[P]>
  }




  export type patientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: patientsWhereInput
    orderBy?: patientsOrderByWithAggregationInput | patientsOrderByWithAggregationInput[]
    by: PatientsScalarFieldEnum[] | PatientsScalarFieldEnum
    having?: patientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientsCountAggregateInputType | true
    _min?: PatientsMinAggregateInputType
    _max?: PatientsMaxAggregateInputType
  }

  export type PatientsGroupByOutputType = {
    id: string
    user_id: string | null
    full_name: string
    identification: string | null
    phone: string | null
    birth_date: Date | null
    address_text: string | null
    _count: PatientsCountAggregateOutputType | null
    _min: PatientsMinAggregateOutputType | null
    _max: PatientsMaxAggregateOutputType | null
  }

  type GetPatientsGroupByPayload<T extends patientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientsGroupByOutputType[P]>
            : GetScalarType<T[P], PatientsGroupByOutputType[P]>
        }
      >
    >


  export type patientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    full_name?: boolean
    identification?: boolean
    phone?: boolean
    birth_date?: boolean
    address_text?: boolean
    appointments?: boolean | patients$appointmentsArgs<ExtArgs>
    medical_history?: boolean | patients$medical_historyArgs<ExtArgs>
    notifications?: boolean | patients$notificationsArgs<ExtArgs>
    patient_favorites?: boolean | patients$patient_favoritesArgs<ExtArgs>
    users?: boolean | patients$usersArgs<ExtArgs>
    reviews?: boolean | patients$reviewsArgs<ExtArgs>
    _count?: boolean | PatientsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    full_name?: boolean
    identification?: boolean
    phone?: boolean
    birth_date?: boolean
    address_text?: boolean
    users?: boolean | patients$usersArgs<ExtArgs>
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    full_name?: boolean
    identification?: boolean
    phone?: boolean
    birth_date?: boolean
    address_text?: boolean
    users?: boolean | patients$usersArgs<ExtArgs>
  }, ExtArgs["result"]["patients"]>

  export type patientsSelectScalar = {
    id?: boolean
    user_id?: boolean
    full_name?: boolean
    identification?: boolean
    phone?: boolean
    birth_date?: boolean
    address_text?: boolean
  }

  export type patientsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "full_name" | "identification" | "phone" | "birth_date" | "address_text", ExtArgs["result"]["patients"]>
  export type patientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | patients$appointmentsArgs<ExtArgs>
    medical_history?: boolean | patients$medical_historyArgs<ExtArgs>
    notifications?: boolean | patients$notificationsArgs<ExtArgs>
    patient_favorites?: boolean | patients$patient_favoritesArgs<ExtArgs>
    users?: boolean | patients$usersArgs<ExtArgs>
    reviews?: boolean | patients$reviewsArgs<ExtArgs>
    _count?: boolean | PatientsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type patientsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | patients$usersArgs<ExtArgs>
  }
  export type patientsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | patients$usersArgs<ExtArgs>
  }

  export type $patientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "patients"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>[]
      medical_history: Prisma.$medical_historyPayload<ExtArgs>[]
      notifications: Prisma.$notificationsPayload<ExtArgs>[]
      patient_favorites: Prisma.$patient_favoritesPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs> | null
      reviews: Prisma.$reviewsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      full_name: string
      identification: string | null
      phone: string | null
      birth_date: Date | null
      address_text: string | null
    }, ExtArgs["result"]["patients"]>
    composites: {}
  }

  type patientsGetPayload<S extends boolean | null | undefined | patientsDefaultArgs> = $Result.GetResult<Prisma.$patientsPayload, S>

  type patientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<patientsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PatientsCountAggregateInputType | true
    }

  export interface patientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['patients'], meta: { name: 'patients' } }
    /**
     * Find zero or one Patients that matches the filter.
     * @param {patientsFindUniqueArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends patientsFindUniqueArgs>(args: SelectSubset<T, patientsFindUniqueArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Patients that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {patientsFindUniqueOrThrowArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends patientsFindUniqueOrThrowArgs>(args: SelectSubset<T, patientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindFirstArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends patientsFindFirstArgs>(args?: SelectSubset<T, patientsFindFirstArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Patients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindFirstOrThrowArgs} args - Arguments to find a Patients
     * @example
     * // Get one Patients
     * const patients = await prisma.patients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends patientsFindFirstOrThrowArgs>(args?: SelectSubset<T, patientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patients.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patients.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientsWithIdOnly = await prisma.patients.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends patientsFindManyArgs>(args?: SelectSubset<T, patientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Patients.
     * @param {patientsCreateArgs} args - Arguments to create a Patients.
     * @example
     * // Create one Patients
     * const Patients = await prisma.patients.create({
     *   data: {
     *     // ... data to create a Patients
     *   }
     * })
     * 
     */
    create<T extends patientsCreateArgs>(args: SelectSubset<T, patientsCreateArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Patients.
     * @param {patientsCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patients = await prisma.patients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends patientsCreateManyArgs>(args?: SelectSubset<T, patientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {patientsCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patients = await prisma.patients.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientsWithIdOnly = await prisma.patients.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends patientsCreateManyAndReturnArgs>(args?: SelectSubset<T, patientsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Patients.
     * @param {patientsDeleteArgs} args - Arguments to delete one Patients.
     * @example
     * // Delete one Patients
     * const Patients = await prisma.patients.delete({
     *   where: {
     *     // ... filter to delete one Patients
     *   }
     * })
     * 
     */
    delete<T extends patientsDeleteArgs>(args: SelectSubset<T, patientsDeleteArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Patients.
     * @param {patientsUpdateArgs} args - Arguments to update one Patients.
     * @example
     * // Update one Patients
     * const patients = await prisma.patients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends patientsUpdateArgs>(args: SelectSubset<T, patientsUpdateArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Patients.
     * @param {patientsDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends patientsDeleteManyArgs>(args?: SelectSubset<T, patientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patients = await prisma.patients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends patientsUpdateManyArgs>(args: SelectSubset<T, patientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients and returns the data updated in the database.
     * @param {patientsUpdateManyAndReturnArgs} args - Arguments to update many Patients.
     * @example
     * // Update many Patients
     * const patients = await prisma.patients.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Patients and only return the `id`
     * const patientsWithIdOnly = await prisma.patients.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends patientsUpdateManyAndReturnArgs>(args: SelectSubset<T, patientsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Patients.
     * @param {patientsUpsertArgs} args - Arguments to update or create a Patients.
     * @example
     * // Update or create a Patients
     * const patients = await prisma.patients.upsert({
     *   create: {
     *     // ... data to create a Patients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patients we want to update
     *   }
     * })
     */
    upsert<T extends patientsUpsertArgs>(args: SelectSubset<T, patientsUpsertArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patients.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends patientsCountArgs>(
      args?: Subset<T, patientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientsAggregateArgs>(args: Subset<T, PatientsAggregateArgs>): Prisma.PrismaPromise<GetPatientsAggregateType<T>>

    /**
     * Group by Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {patientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends patientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: patientsGroupByArgs['orderBy'] }
        : { orderBy?: patientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, patientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the patients model
   */
  readonly fields: patientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for patients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__patientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends patients$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, patients$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medical_history<T extends patients$medical_historyArgs<ExtArgs> = {}>(args?: Subset<T, patients$medical_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends patients$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, patients$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patient_favorites<T extends patients$patient_favoritesArgs<ExtArgs> = {}>(args?: Subset<T, patients$patient_favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends patients$usersArgs<ExtArgs> = {}>(args?: Subset<T, patients$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reviews<T extends patients$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, patients$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the patients model
   */
  interface patientsFieldRefs {
    readonly id: FieldRef<"patients", 'String'>
    readonly user_id: FieldRef<"patients", 'String'>
    readonly full_name: FieldRef<"patients", 'String'>
    readonly identification: FieldRef<"patients", 'String'>
    readonly phone: FieldRef<"patients", 'String'>
    readonly birth_date: FieldRef<"patients", 'DateTime'>
    readonly address_text: FieldRef<"patients", 'String'>
  }
    

  // Custom InputTypes
  /**
   * patients findUnique
   */
  export type patientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients findUniqueOrThrow
   */
  export type patientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients findFirst
   */
  export type patientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patients.
     */
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients findFirstOrThrow
   */
  export type patientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of patients.
     */
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients findMany
   */
  export type patientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter, which patients to fetch.
     */
    where?: patientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of patients to fetch.
     */
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing patients.
     */
    cursor?: patientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` patients.
     */
    skip?: number
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * patients create
   */
  export type patientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * The data needed to create a patients.
     */
    data: XOR<patientsCreateInput, patientsUncheckedCreateInput>
  }

  /**
   * patients createMany
   */
  export type patientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many patients.
     */
    data: patientsCreateManyInput | patientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * patients createManyAndReturn
   */
  export type patientsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The data used to create many patients.
     */
    data: patientsCreateManyInput | patientsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * patients update
   */
  export type patientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * The data needed to update a patients.
     */
    data: XOR<patientsUpdateInput, patientsUncheckedUpdateInput>
    /**
     * Choose, which patients to update.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients updateMany
   */
  export type patientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update patients.
     */
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyInput>
    /**
     * Filter which patients to update
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to update.
     */
    limit?: number
  }

  /**
   * patients updateManyAndReturn
   */
  export type patientsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * The data used to update patients.
     */
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyInput>
    /**
     * Filter which patients to update
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * patients upsert
   */
  export type patientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * The filter to search for the patients to update in case it exists.
     */
    where: patientsWhereUniqueInput
    /**
     * In case the patients found by the `where` argument doesn't exist, create a new patients with this data.
     */
    create: XOR<patientsCreateInput, patientsUncheckedCreateInput>
    /**
     * In case the patients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<patientsUpdateInput, patientsUncheckedUpdateInput>
  }

  /**
   * patients delete
   */
  export type patientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    /**
     * Filter which patients to delete.
     */
    where: patientsWhereUniqueInput
  }

  /**
   * patients deleteMany
   */
  export type patientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which patients to delete
     */
    where?: patientsWhereInput
    /**
     * Limit how many patients to delete.
     */
    limit?: number
  }

  /**
   * patients.appointments
   */
  export type patients$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * patients.medical_history
   */
  export type patients$medical_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    where?: medical_historyWhereInput
    orderBy?: medical_historyOrderByWithRelationInput | medical_historyOrderByWithRelationInput[]
    cursor?: medical_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Medical_historyScalarFieldEnum | Medical_historyScalarFieldEnum[]
  }

  /**
   * patients.notifications
   */
  export type patients$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notifications
     */
    select?: notificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notifications
     */
    omit?: notificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: notificationsInclude<ExtArgs> | null
    where?: notificationsWhereInput
    orderBy?: notificationsOrderByWithRelationInput | notificationsOrderByWithRelationInput[]
    cursor?: notificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationsScalarFieldEnum | NotificationsScalarFieldEnum[]
  }

  /**
   * patients.patient_favorites
   */
  export type patients$patient_favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    where?: patient_favoritesWhereInput
    orderBy?: patient_favoritesOrderByWithRelationInput | patient_favoritesOrderByWithRelationInput[]
    cursor?: patient_favoritesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Patient_favoritesScalarFieldEnum | Patient_favoritesScalarFieldEnum[]
  }

  /**
   * patients.users
   */
  export type patients$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * patients.reviews
   */
  export type patients$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * patients without action
   */
  export type patientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    amount_total: Decimal | null
    platform_fee: Decimal | null
    provider_amount: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    amount_total: Decimal | null
    platform_fee: Decimal | null
    provider_amount: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: string | null
    appointment_id: string | null
    payout_id: string | null
    stripe_payment_intent_id: string | null
    amount_total: Decimal | null
    platform_fee: Decimal | null
    provider_amount: Decimal | null
    status: string | null
    created_at: Date | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: string | null
    appointment_id: string | null
    payout_id: string | null
    stripe_payment_intent_id: string | null
    amount_total: Decimal | null
    platform_fee: Decimal | null
    provider_amount: Decimal | null
    status: string | null
    created_at: Date | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    appointment_id: number
    payout_id: number
    stripe_payment_intent_id: number
    amount_total: number
    platform_fee: number
    provider_amount: number
    status: number
    created_at: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    amount_total?: true
    platform_fee?: true
    provider_amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    amount_total?: true
    platform_fee?: true
    provider_amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    appointment_id?: true
    payout_id?: true
    stripe_payment_intent_id?: true
    amount_total?: true
    platform_fee?: true
    provider_amount?: true
    status?: true
    created_at?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    appointment_id?: true
    payout_id?: true
    stripe_payment_intent_id?: true
    amount_total?: true
    platform_fee?: true
    provider_amount?: true
    status?: true
    created_at?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    appointment_id?: true
    payout_id?: true
    stripe_payment_intent_id?: true
    amount_total?: true
    platform_fee?: true
    provider_amount?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: string
    appointment_id: string | null
    payout_id: string | null
    stripe_payment_intent_id: string | null
    amount_total: Decimal | null
    platform_fee: Decimal | null
    provider_amount: Decimal | null
    status: string | null
    created_at: Date | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointment_id?: boolean
    payout_id?: boolean
    stripe_payment_intent_id?: boolean
    amount_total?: boolean
    platform_fee?: boolean
    provider_amount?: boolean
    status?: boolean
    created_at?: boolean
    appointments?: boolean | payments$appointmentsArgs<ExtArgs>
    payouts?: boolean | payments$payoutsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointment_id?: boolean
    payout_id?: boolean
    stripe_payment_intent_id?: boolean
    amount_total?: boolean
    platform_fee?: boolean
    provider_amount?: boolean
    status?: boolean
    created_at?: boolean
    appointments?: boolean | payments$appointmentsArgs<ExtArgs>
    payouts?: boolean | payments$payoutsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appointment_id?: boolean
    payout_id?: boolean
    stripe_payment_intent_id?: boolean
    amount_total?: boolean
    platform_fee?: boolean
    provider_amount?: boolean
    status?: boolean
    created_at?: boolean
    appointments?: boolean | payments$appointmentsArgs<ExtArgs>
    payouts?: boolean | payments$payoutsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    appointment_id?: boolean
    payout_id?: boolean
    stripe_payment_intent_id?: boolean
    amount_total?: boolean
    platform_fee?: boolean
    provider_amount?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appointment_id" | "payout_id" | "stripe_payment_intent_id" | "amount_total" | "platform_fee" | "provider_amount" | "status" | "created_at", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | payments$appointmentsArgs<ExtArgs>
    payouts?: boolean | payments$payoutsArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | payments$appointmentsArgs<ExtArgs>
    payouts?: boolean | payments$payoutsArgs<ExtArgs>
  }
  export type paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | payments$appointmentsArgs<ExtArgs>
    payouts?: boolean | payments$payoutsArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs> | null
      payouts: Prisma.$payoutsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      appointment_id: string | null
      payout_id: string | null
      stripe_payment_intent_id: string | null
      amount_total: Prisma.Decimal | null
      platform_fee: Prisma.Decimal | null
      provider_amount: Prisma.Decimal | null
      status: string | null
      created_at: Date | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends payments$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, payments$appointmentsArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payouts<T extends payments$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, payments$payoutsArgs<ExtArgs>>): Prisma__payoutsClient<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'String'>
    readonly appointment_id: FieldRef<"payments", 'String'>
    readonly payout_id: FieldRef<"payments", 'String'>
    readonly stripe_payment_intent_id: FieldRef<"payments", 'String'>
    readonly amount_total: FieldRef<"payments", 'Decimal'>
    readonly platform_fee: FieldRef<"payments", 'Decimal'>
    readonly provider_amount: FieldRef<"payments", 'Decimal'>
    readonly status: FieldRef<"payments", 'String'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments.appointments
   */
  export type payments$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
  }

  /**
   * payments.payouts
   */
  export type payments$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    where?: payoutsWhereInput
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model payouts
   */

  export type AggregatePayouts = {
    _count: PayoutsCountAggregateOutputType | null
    _avg: PayoutsAvgAggregateOutputType | null
    _sum: PayoutsSumAggregateOutputType | null
    _min: PayoutsMinAggregateOutputType | null
    _max: PayoutsMaxAggregateOutputType | null
  }

  export type PayoutsAvgAggregateOutputType = {
    total_amount: Decimal | null
  }

  export type PayoutsSumAggregateOutputType = {
    total_amount: Decimal | null
  }

  export type PayoutsMinAggregateOutputType = {
    id: string | null
    provider_id: string | null
    total_amount: Decimal | null
    currency: string | null
    status: string | null
    reference_number: string | null
    period_start: Date | null
    period_end: Date | null
    created_at: Date | null
  }

  export type PayoutsMaxAggregateOutputType = {
    id: string | null
    provider_id: string | null
    total_amount: Decimal | null
    currency: string | null
    status: string | null
    reference_number: string | null
    period_start: Date | null
    period_end: Date | null
    created_at: Date | null
  }

  export type PayoutsCountAggregateOutputType = {
    id: number
    provider_id: number
    total_amount: number
    currency: number
    status: number
    reference_number: number
    period_start: number
    period_end: number
    created_at: number
    _all: number
  }


  export type PayoutsAvgAggregateInputType = {
    total_amount?: true
  }

  export type PayoutsSumAggregateInputType = {
    total_amount?: true
  }

  export type PayoutsMinAggregateInputType = {
    id?: true
    provider_id?: true
    total_amount?: true
    currency?: true
    status?: true
    reference_number?: true
    period_start?: true
    period_end?: true
    created_at?: true
  }

  export type PayoutsMaxAggregateInputType = {
    id?: true
    provider_id?: true
    total_amount?: true
    currency?: true
    status?: true
    reference_number?: true
    period_start?: true
    period_end?: true
    created_at?: true
  }

  export type PayoutsCountAggregateInputType = {
    id?: true
    provider_id?: true
    total_amount?: true
    currency?: true
    status?: true
    reference_number?: true
    period_start?: true
    period_end?: true
    created_at?: true
    _all?: true
  }

  export type PayoutsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payouts to aggregate.
     */
    where?: payoutsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payouts to fetch.
     */
    orderBy?: payoutsOrderByWithRelationInput | payoutsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: payoutsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payouts
    **/
    _count?: true | PayoutsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayoutsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayoutsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayoutsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayoutsMaxAggregateInputType
  }

  export type GetPayoutsAggregateType<T extends PayoutsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayouts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayouts[P]>
      : GetScalarType<T[P], AggregatePayouts[P]>
  }




  export type payoutsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: payoutsWhereInput
    orderBy?: payoutsOrderByWithAggregationInput | payoutsOrderByWithAggregationInput[]
    by: PayoutsScalarFieldEnum[] | PayoutsScalarFieldEnum
    having?: payoutsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayoutsCountAggregateInputType | true
    _avg?: PayoutsAvgAggregateInputType
    _sum?: PayoutsSumAggregateInputType
    _min?: PayoutsMinAggregateInputType
    _max?: PayoutsMaxAggregateInputType
  }

  export type PayoutsGroupByOutputType = {
    id: string
    provider_id: string | null
    total_amount: Decimal | null
    currency: string | null
    status: string | null
    reference_number: string | null
    period_start: Date | null
    period_end: Date | null
    created_at: Date | null
    _count: PayoutsCountAggregateOutputType | null
    _avg: PayoutsAvgAggregateOutputType | null
    _sum: PayoutsSumAggregateOutputType | null
    _min: PayoutsMinAggregateOutputType | null
    _max: PayoutsMaxAggregateOutputType | null
  }

  type GetPayoutsGroupByPayload<T extends payoutsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayoutsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayoutsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayoutsGroupByOutputType[P]>
            : GetScalarType<T[P], PayoutsGroupByOutputType[P]>
        }
      >
    >


  export type payoutsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    total_amount?: boolean
    currency?: boolean
    status?: boolean
    reference_number?: boolean
    period_start?: boolean
    period_end?: boolean
    created_at?: boolean
    payments?: boolean | payouts$paymentsArgs<ExtArgs>
    providers?: boolean | payouts$providersArgs<ExtArgs>
    _count?: boolean | PayoutsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payouts"]>

  export type payoutsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    total_amount?: boolean
    currency?: boolean
    status?: boolean
    reference_number?: boolean
    period_start?: boolean
    period_end?: boolean
    created_at?: boolean
    providers?: boolean | payouts$providersArgs<ExtArgs>
  }, ExtArgs["result"]["payouts"]>

  export type payoutsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    total_amount?: boolean
    currency?: boolean
    status?: boolean
    reference_number?: boolean
    period_start?: boolean
    period_end?: boolean
    created_at?: boolean
    providers?: boolean | payouts$providersArgs<ExtArgs>
  }, ExtArgs["result"]["payouts"]>

  export type payoutsSelectScalar = {
    id?: boolean
    provider_id?: boolean
    total_amount?: boolean
    currency?: boolean
    status?: boolean
    reference_number?: boolean
    period_start?: boolean
    period_end?: boolean
    created_at?: boolean
  }

  export type payoutsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider_id" | "total_amount" | "currency" | "status" | "reference_number" | "period_start" | "period_end" | "created_at", ExtArgs["result"]["payouts"]>
  export type payoutsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | payouts$paymentsArgs<ExtArgs>
    providers?: boolean | payouts$providersArgs<ExtArgs>
    _count?: boolean | PayoutsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type payoutsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | payouts$providersArgs<ExtArgs>
  }
  export type payoutsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | payouts$providersArgs<ExtArgs>
  }

  export type $payoutsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payouts"
    objects: {
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      providers: Prisma.$providersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider_id: string | null
      total_amount: Prisma.Decimal | null
      currency: string | null
      status: string | null
      reference_number: string | null
      period_start: Date | null
      period_end: Date | null
      created_at: Date | null
    }, ExtArgs["result"]["payouts"]>
    composites: {}
  }

  type payoutsGetPayload<S extends boolean | null | undefined | payoutsDefaultArgs> = $Result.GetResult<Prisma.$payoutsPayload, S>

  type payoutsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<payoutsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayoutsCountAggregateInputType | true
    }

  export interface payoutsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payouts'], meta: { name: 'payouts' } }
    /**
     * Find zero or one Payouts that matches the filter.
     * @param {payoutsFindUniqueArgs} args - Arguments to find a Payouts
     * @example
     * // Get one Payouts
     * const payouts = await prisma.payouts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends payoutsFindUniqueArgs>(args: SelectSubset<T, payoutsFindUniqueArgs<ExtArgs>>): Prisma__payoutsClient<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payouts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {payoutsFindUniqueOrThrowArgs} args - Arguments to find a Payouts
     * @example
     * // Get one Payouts
     * const payouts = await prisma.payouts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends payoutsFindUniqueOrThrowArgs>(args: SelectSubset<T, payoutsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__payoutsClient<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payoutsFindFirstArgs} args - Arguments to find a Payouts
     * @example
     * // Get one Payouts
     * const payouts = await prisma.payouts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends payoutsFindFirstArgs>(args?: SelectSubset<T, payoutsFindFirstArgs<ExtArgs>>): Prisma__payoutsClient<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payouts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payoutsFindFirstOrThrowArgs} args - Arguments to find a Payouts
     * @example
     * // Get one Payouts
     * const payouts = await prisma.payouts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends payoutsFindFirstOrThrowArgs>(args?: SelectSubset<T, payoutsFindFirstOrThrowArgs<ExtArgs>>): Prisma__payoutsClient<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payoutsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payouts
     * const payouts = await prisma.payouts.findMany()
     * 
     * // Get first 10 Payouts
     * const payouts = await prisma.payouts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payoutsWithIdOnly = await prisma.payouts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends payoutsFindManyArgs>(args?: SelectSubset<T, payoutsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payouts.
     * @param {payoutsCreateArgs} args - Arguments to create a Payouts.
     * @example
     * // Create one Payouts
     * const Payouts = await prisma.payouts.create({
     *   data: {
     *     // ... data to create a Payouts
     *   }
     * })
     * 
     */
    create<T extends payoutsCreateArgs>(args: SelectSubset<T, payoutsCreateArgs<ExtArgs>>): Prisma__payoutsClient<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payouts.
     * @param {payoutsCreateManyArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payouts = await prisma.payouts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends payoutsCreateManyArgs>(args?: SelectSubset<T, payoutsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payouts and returns the data saved in the database.
     * @param {payoutsCreateManyAndReturnArgs} args - Arguments to create many Payouts.
     * @example
     * // Create many Payouts
     * const payouts = await prisma.payouts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payouts and only return the `id`
     * const payoutsWithIdOnly = await prisma.payouts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends payoutsCreateManyAndReturnArgs>(args?: SelectSubset<T, payoutsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payouts.
     * @param {payoutsDeleteArgs} args - Arguments to delete one Payouts.
     * @example
     * // Delete one Payouts
     * const Payouts = await prisma.payouts.delete({
     *   where: {
     *     // ... filter to delete one Payouts
     *   }
     * })
     * 
     */
    delete<T extends payoutsDeleteArgs>(args: SelectSubset<T, payoutsDeleteArgs<ExtArgs>>): Prisma__payoutsClient<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payouts.
     * @param {payoutsUpdateArgs} args - Arguments to update one Payouts.
     * @example
     * // Update one Payouts
     * const payouts = await prisma.payouts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends payoutsUpdateArgs>(args: SelectSubset<T, payoutsUpdateArgs<ExtArgs>>): Prisma__payoutsClient<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payouts.
     * @param {payoutsDeleteManyArgs} args - Arguments to filter Payouts to delete.
     * @example
     * // Delete a few Payouts
     * const { count } = await prisma.payouts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends payoutsDeleteManyArgs>(args?: SelectSubset<T, payoutsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payoutsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payouts
     * const payouts = await prisma.payouts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends payoutsUpdateManyArgs>(args: SelectSubset<T, payoutsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payouts and returns the data updated in the database.
     * @param {payoutsUpdateManyAndReturnArgs} args - Arguments to update many Payouts.
     * @example
     * // Update many Payouts
     * const payouts = await prisma.payouts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payouts and only return the `id`
     * const payoutsWithIdOnly = await prisma.payouts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends payoutsUpdateManyAndReturnArgs>(args: SelectSubset<T, payoutsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payouts.
     * @param {payoutsUpsertArgs} args - Arguments to update or create a Payouts.
     * @example
     * // Update or create a Payouts
     * const payouts = await prisma.payouts.upsert({
     *   create: {
     *     // ... data to create a Payouts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payouts we want to update
     *   }
     * })
     */
    upsert<T extends payoutsUpsertArgs>(args: SelectSubset<T, payoutsUpsertArgs<ExtArgs>>): Prisma__payoutsClient<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payoutsCountArgs} args - Arguments to filter Payouts to count.
     * @example
     * // Count the number of Payouts
     * const count = await prisma.payouts.count({
     *   where: {
     *     // ... the filter for the Payouts we want to count
     *   }
     * })
    **/
    count<T extends payoutsCountArgs>(
      args?: Subset<T, payoutsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayoutsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayoutsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayoutsAggregateArgs>(args: Subset<T, PayoutsAggregateArgs>): Prisma.PrismaPromise<GetPayoutsAggregateType<T>>

    /**
     * Group by Payouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {payoutsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends payoutsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: payoutsGroupByArgs['orderBy'] }
        : { orderBy?: payoutsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, payoutsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayoutsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payouts model
   */
  readonly fields: payoutsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payouts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__payoutsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends payouts$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, payouts$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    providers<T extends payouts$providersArgs<ExtArgs> = {}>(args?: Subset<T, payouts$providersArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payouts model
   */
  interface payoutsFieldRefs {
    readonly id: FieldRef<"payouts", 'String'>
    readonly provider_id: FieldRef<"payouts", 'String'>
    readonly total_amount: FieldRef<"payouts", 'Decimal'>
    readonly currency: FieldRef<"payouts", 'String'>
    readonly status: FieldRef<"payouts", 'String'>
    readonly reference_number: FieldRef<"payouts", 'String'>
    readonly period_start: FieldRef<"payouts", 'DateTime'>
    readonly period_end: FieldRef<"payouts", 'DateTime'>
    readonly created_at: FieldRef<"payouts", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payouts findUnique
   */
  export type payoutsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    /**
     * Filter, which payouts to fetch.
     */
    where: payoutsWhereUniqueInput
  }

  /**
   * payouts findUniqueOrThrow
   */
  export type payoutsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    /**
     * Filter, which payouts to fetch.
     */
    where: payoutsWhereUniqueInput
  }

  /**
   * payouts findFirst
   */
  export type payoutsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    /**
     * Filter, which payouts to fetch.
     */
    where?: payoutsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payouts to fetch.
     */
    orderBy?: payoutsOrderByWithRelationInput | payoutsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payouts.
     */
    cursor?: payoutsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payouts.
     */
    distinct?: PayoutsScalarFieldEnum | PayoutsScalarFieldEnum[]
  }

  /**
   * payouts findFirstOrThrow
   */
  export type payoutsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    /**
     * Filter, which payouts to fetch.
     */
    where?: payoutsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payouts to fetch.
     */
    orderBy?: payoutsOrderByWithRelationInput | payoutsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payouts.
     */
    cursor?: payoutsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payouts.
     */
    distinct?: PayoutsScalarFieldEnum | PayoutsScalarFieldEnum[]
  }

  /**
   * payouts findMany
   */
  export type payoutsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    /**
     * Filter, which payouts to fetch.
     */
    where?: payoutsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payouts to fetch.
     */
    orderBy?: payoutsOrderByWithRelationInput | payoutsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payouts.
     */
    cursor?: payoutsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payouts.
     */
    skip?: number
    distinct?: PayoutsScalarFieldEnum | PayoutsScalarFieldEnum[]
  }

  /**
   * payouts create
   */
  export type payoutsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    /**
     * The data needed to create a payouts.
     */
    data: XOR<payoutsCreateInput, payoutsUncheckedCreateInput>
  }

  /**
   * payouts createMany
   */
  export type payoutsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payouts.
     */
    data: payoutsCreateManyInput | payoutsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payouts createManyAndReturn
   */
  export type payoutsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * The data used to create many payouts.
     */
    data: payoutsCreateManyInput | payoutsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payouts update
   */
  export type payoutsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    /**
     * The data needed to update a payouts.
     */
    data: XOR<payoutsUpdateInput, payoutsUncheckedUpdateInput>
    /**
     * Choose, which payouts to update.
     */
    where: payoutsWhereUniqueInput
  }

  /**
   * payouts updateMany
   */
  export type payoutsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payouts.
     */
    data: XOR<payoutsUpdateManyMutationInput, payoutsUncheckedUpdateManyInput>
    /**
     * Filter which payouts to update
     */
    where?: payoutsWhereInput
    /**
     * Limit how many payouts to update.
     */
    limit?: number
  }

  /**
   * payouts updateManyAndReturn
   */
  export type payoutsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * The data used to update payouts.
     */
    data: XOR<payoutsUpdateManyMutationInput, payoutsUncheckedUpdateManyInput>
    /**
     * Filter which payouts to update
     */
    where?: payoutsWhereInput
    /**
     * Limit how many payouts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payouts upsert
   */
  export type payoutsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    /**
     * The filter to search for the payouts to update in case it exists.
     */
    where: payoutsWhereUniqueInput
    /**
     * In case the payouts found by the `where` argument doesn't exist, create a new payouts with this data.
     */
    create: XOR<payoutsCreateInput, payoutsUncheckedCreateInput>
    /**
     * In case the payouts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<payoutsUpdateInput, payoutsUncheckedUpdateInput>
  }

  /**
   * payouts delete
   */
  export type payoutsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    /**
     * Filter which payouts to delete.
     */
    where: payoutsWhereUniqueInput
  }

  /**
   * payouts deleteMany
   */
  export type payoutsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payouts to delete
     */
    where?: payoutsWhereInput
    /**
     * Limit how many payouts to delete.
     */
    limit?: number
  }

  /**
   * payouts.payments
   */
  export type payouts$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payouts.providers
   */
  export type payouts$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
  }

  /**
   * payouts without action
   */
  export type payoutsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
  }


  /**
   * Model provider_ads
   */

  export type AggregateProvider_ads = {
    _count: Provider_adsCountAggregateOutputType | null
    _avg: Provider_adsAvgAggregateOutputType | null
    _sum: Provider_adsSumAggregateOutputType | null
    _min: Provider_adsMinAggregateOutputType | null
    _max: Provider_adsMaxAggregateOutputType | null
  }

  export type Provider_adsAvgAggregateOutputType = {
    priority_order: number | null
  }

  export type Provider_adsSumAggregateOutputType = {
    priority_order: number | null
  }

  export type Provider_adsMinAggregateOutputType = {
    id: string | null
    provider_id: string | null
    badge_text: string | null
    title: string | null
    subtitle: string | null
    image_url: string | null
    action_text: string | null
    bg_color_hex: string | null
    accent_color_hex: string | null
    target_screen: string | null
    target_id: string | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
    priority_order: number | null
  }

  export type Provider_adsMaxAggregateOutputType = {
    id: string | null
    provider_id: string | null
    badge_text: string | null
    title: string | null
    subtitle: string | null
    image_url: string | null
    action_text: string | null
    bg_color_hex: string | null
    accent_color_hex: string | null
    target_screen: string | null
    target_id: string | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
    priority_order: number | null
  }

  export type Provider_adsCountAggregateOutputType = {
    id: number
    provider_id: number
    badge_text: number
    title: number
    subtitle: number
    image_url: number
    action_text: number
    bg_color_hex: number
    accent_color_hex: number
    target_screen: number
    target_id: number
    start_date: number
    end_date: number
    is_active: number
    priority_order: number
    _all: number
  }


  export type Provider_adsAvgAggregateInputType = {
    priority_order?: true
  }

  export type Provider_adsSumAggregateInputType = {
    priority_order?: true
  }

  export type Provider_adsMinAggregateInputType = {
    id?: true
    provider_id?: true
    badge_text?: true
    title?: true
    subtitle?: true
    image_url?: true
    action_text?: true
    bg_color_hex?: true
    accent_color_hex?: true
    target_screen?: true
    target_id?: true
    start_date?: true
    end_date?: true
    is_active?: true
    priority_order?: true
  }

  export type Provider_adsMaxAggregateInputType = {
    id?: true
    provider_id?: true
    badge_text?: true
    title?: true
    subtitle?: true
    image_url?: true
    action_text?: true
    bg_color_hex?: true
    accent_color_hex?: true
    target_screen?: true
    target_id?: true
    start_date?: true
    end_date?: true
    is_active?: true
    priority_order?: true
  }

  export type Provider_adsCountAggregateInputType = {
    id?: true
    provider_id?: true
    badge_text?: true
    title?: true
    subtitle?: true
    image_url?: true
    action_text?: true
    bg_color_hex?: true
    accent_color_hex?: true
    target_screen?: true
    target_id?: true
    start_date?: true
    end_date?: true
    is_active?: true
    priority_order?: true
    _all?: true
  }

  export type Provider_adsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_ads to aggregate.
     */
    where?: provider_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_ads to fetch.
     */
    orderBy?: provider_adsOrderByWithRelationInput | provider_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: provider_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned provider_ads
    **/
    _count?: true | Provider_adsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Provider_adsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Provider_adsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Provider_adsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Provider_adsMaxAggregateInputType
  }

  export type GetProvider_adsAggregateType<T extends Provider_adsAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider_ads]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider_ads[P]>
      : GetScalarType<T[P], AggregateProvider_ads[P]>
  }




  export type provider_adsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_adsWhereInput
    orderBy?: provider_adsOrderByWithAggregationInput | provider_adsOrderByWithAggregationInput[]
    by: Provider_adsScalarFieldEnum[] | Provider_adsScalarFieldEnum
    having?: provider_adsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Provider_adsCountAggregateInputType | true
    _avg?: Provider_adsAvgAggregateInputType
    _sum?: Provider_adsSumAggregateInputType
    _min?: Provider_adsMinAggregateInputType
    _max?: Provider_adsMaxAggregateInputType
  }

  export type Provider_adsGroupByOutputType = {
    id: string
    provider_id: string | null
    badge_text: string | null
    title: string | null
    subtitle: string | null
    image_url: string | null
    action_text: string | null
    bg_color_hex: string | null
    accent_color_hex: string | null
    target_screen: string | null
    target_id: string | null
    start_date: Date | null
    end_date: Date | null
    is_active: boolean | null
    priority_order: number | null
    _count: Provider_adsCountAggregateOutputType | null
    _avg: Provider_adsAvgAggregateOutputType | null
    _sum: Provider_adsSumAggregateOutputType | null
    _min: Provider_adsMinAggregateOutputType | null
    _max: Provider_adsMaxAggregateOutputType | null
  }

  type GetProvider_adsGroupByPayload<T extends provider_adsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Provider_adsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Provider_adsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Provider_adsGroupByOutputType[P]>
            : GetScalarType<T[P], Provider_adsGroupByOutputType[P]>
        }
      >
    >


  export type provider_adsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    badge_text?: boolean
    title?: boolean
    subtitle?: boolean
    image_url?: boolean
    action_text?: boolean
    bg_color_hex?: boolean
    accent_color_hex?: boolean
    target_screen?: boolean
    target_id?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    priority_order?: boolean
    providers?: boolean | provider_ads$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_ads"]>

  export type provider_adsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    badge_text?: boolean
    title?: boolean
    subtitle?: boolean
    image_url?: boolean
    action_text?: boolean
    bg_color_hex?: boolean
    accent_color_hex?: boolean
    target_screen?: boolean
    target_id?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    priority_order?: boolean
    providers?: boolean | provider_ads$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_ads"]>

  export type provider_adsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    badge_text?: boolean
    title?: boolean
    subtitle?: boolean
    image_url?: boolean
    action_text?: boolean
    bg_color_hex?: boolean
    accent_color_hex?: boolean
    target_screen?: boolean
    target_id?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    priority_order?: boolean
    providers?: boolean | provider_ads$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_ads"]>

  export type provider_adsSelectScalar = {
    id?: boolean
    provider_id?: boolean
    badge_text?: boolean
    title?: boolean
    subtitle?: boolean
    image_url?: boolean
    action_text?: boolean
    bg_color_hex?: boolean
    accent_color_hex?: boolean
    target_screen?: boolean
    target_id?: boolean
    start_date?: boolean
    end_date?: boolean
    is_active?: boolean
    priority_order?: boolean
  }

  export type provider_adsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider_id" | "badge_text" | "title" | "subtitle" | "image_url" | "action_text" | "bg_color_hex" | "accent_color_hex" | "target_screen" | "target_id" | "start_date" | "end_date" | "is_active" | "priority_order", ExtArgs["result"]["provider_ads"]>
  export type provider_adsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | provider_ads$providersArgs<ExtArgs>
  }
  export type provider_adsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | provider_ads$providersArgs<ExtArgs>
  }
  export type provider_adsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | provider_ads$providersArgs<ExtArgs>
  }

  export type $provider_adsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "provider_ads"
    objects: {
      providers: Prisma.$providersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider_id: string | null
      badge_text: string | null
      title: string | null
      subtitle: string | null
      image_url: string | null
      action_text: string | null
      bg_color_hex: string | null
      accent_color_hex: string | null
      target_screen: string | null
      target_id: string | null
      start_date: Date | null
      end_date: Date | null
      is_active: boolean | null
      priority_order: number | null
    }, ExtArgs["result"]["provider_ads"]>
    composites: {}
  }

  type provider_adsGetPayload<S extends boolean | null | undefined | provider_adsDefaultArgs> = $Result.GetResult<Prisma.$provider_adsPayload, S>

  type provider_adsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<provider_adsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Provider_adsCountAggregateInputType | true
    }

  export interface provider_adsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['provider_ads'], meta: { name: 'provider_ads' } }
    /**
     * Find zero or one Provider_ads that matches the filter.
     * @param {provider_adsFindUniqueArgs} args - Arguments to find a Provider_ads
     * @example
     * // Get one Provider_ads
     * const provider_ads = await prisma.provider_ads.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends provider_adsFindUniqueArgs>(args: SelectSubset<T, provider_adsFindUniqueArgs<ExtArgs>>): Prisma__provider_adsClient<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider_ads that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {provider_adsFindUniqueOrThrowArgs} args - Arguments to find a Provider_ads
     * @example
     * // Get one Provider_ads
     * const provider_ads = await prisma.provider_ads.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends provider_adsFindUniqueOrThrowArgs>(args: SelectSubset<T, provider_adsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__provider_adsClient<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_adsFindFirstArgs} args - Arguments to find a Provider_ads
     * @example
     * // Get one Provider_ads
     * const provider_ads = await prisma.provider_ads.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends provider_adsFindFirstArgs>(args?: SelectSubset<T, provider_adsFindFirstArgs<ExtArgs>>): Prisma__provider_adsClient<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_ads that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_adsFindFirstOrThrowArgs} args - Arguments to find a Provider_ads
     * @example
     * // Get one Provider_ads
     * const provider_ads = await prisma.provider_ads.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends provider_adsFindFirstOrThrowArgs>(args?: SelectSubset<T, provider_adsFindFirstOrThrowArgs<ExtArgs>>): Prisma__provider_adsClient<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provider_ads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_adsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provider_ads
     * const provider_ads = await prisma.provider_ads.findMany()
     * 
     * // Get first 10 Provider_ads
     * const provider_ads = await prisma.provider_ads.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provider_adsWithIdOnly = await prisma.provider_ads.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends provider_adsFindManyArgs>(args?: SelectSubset<T, provider_adsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider_ads.
     * @param {provider_adsCreateArgs} args - Arguments to create a Provider_ads.
     * @example
     * // Create one Provider_ads
     * const Provider_ads = await prisma.provider_ads.create({
     *   data: {
     *     // ... data to create a Provider_ads
     *   }
     * })
     * 
     */
    create<T extends provider_adsCreateArgs>(args: SelectSubset<T, provider_adsCreateArgs<ExtArgs>>): Prisma__provider_adsClient<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provider_ads.
     * @param {provider_adsCreateManyArgs} args - Arguments to create many Provider_ads.
     * @example
     * // Create many Provider_ads
     * const provider_ads = await prisma.provider_ads.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends provider_adsCreateManyArgs>(args?: SelectSubset<T, provider_adsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provider_ads and returns the data saved in the database.
     * @param {provider_adsCreateManyAndReturnArgs} args - Arguments to create many Provider_ads.
     * @example
     * // Create many Provider_ads
     * const provider_ads = await prisma.provider_ads.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provider_ads and only return the `id`
     * const provider_adsWithIdOnly = await prisma.provider_ads.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends provider_adsCreateManyAndReturnArgs>(args?: SelectSubset<T, provider_adsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider_ads.
     * @param {provider_adsDeleteArgs} args - Arguments to delete one Provider_ads.
     * @example
     * // Delete one Provider_ads
     * const Provider_ads = await prisma.provider_ads.delete({
     *   where: {
     *     // ... filter to delete one Provider_ads
     *   }
     * })
     * 
     */
    delete<T extends provider_adsDeleteArgs>(args: SelectSubset<T, provider_adsDeleteArgs<ExtArgs>>): Prisma__provider_adsClient<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider_ads.
     * @param {provider_adsUpdateArgs} args - Arguments to update one Provider_ads.
     * @example
     * // Update one Provider_ads
     * const provider_ads = await prisma.provider_ads.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends provider_adsUpdateArgs>(args: SelectSubset<T, provider_adsUpdateArgs<ExtArgs>>): Prisma__provider_adsClient<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provider_ads.
     * @param {provider_adsDeleteManyArgs} args - Arguments to filter Provider_ads to delete.
     * @example
     * // Delete a few Provider_ads
     * const { count } = await prisma.provider_ads.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends provider_adsDeleteManyArgs>(args?: SelectSubset<T, provider_adsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_adsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provider_ads
     * const provider_ads = await prisma.provider_ads.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends provider_adsUpdateManyArgs>(args: SelectSubset<T, provider_adsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_ads and returns the data updated in the database.
     * @param {provider_adsUpdateManyAndReturnArgs} args - Arguments to update many Provider_ads.
     * @example
     * // Update many Provider_ads
     * const provider_ads = await prisma.provider_ads.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provider_ads and only return the `id`
     * const provider_adsWithIdOnly = await prisma.provider_ads.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends provider_adsUpdateManyAndReturnArgs>(args: SelectSubset<T, provider_adsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider_ads.
     * @param {provider_adsUpsertArgs} args - Arguments to update or create a Provider_ads.
     * @example
     * // Update or create a Provider_ads
     * const provider_ads = await prisma.provider_ads.upsert({
     *   create: {
     *     // ... data to create a Provider_ads
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider_ads we want to update
     *   }
     * })
     */
    upsert<T extends provider_adsUpsertArgs>(args: SelectSubset<T, provider_adsUpsertArgs<ExtArgs>>): Prisma__provider_adsClient<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provider_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_adsCountArgs} args - Arguments to filter Provider_ads to count.
     * @example
     * // Count the number of Provider_ads
     * const count = await prisma.provider_ads.count({
     *   where: {
     *     // ... the filter for the Provider_ads we want to count
     *   }
     * })
    **/
    count<T extends provider_adsCountArgs>(
      args?: Subset<T, provider_adsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Provider_adsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Provider_adsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Provider_adsAggregateArgs>(args: Subset<T, Provider_adsAggregateArgs>): Prisma.PrismaPromise<GetProvider_adsAggregateType<T>>

    /**
     * Group by Provider_ads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_adsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends provider_adsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: provider_adsGroupByArgs['orderBy'] }
        : { orderBy?: provider_adsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, provider_adsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvider_adsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the provider_ads model
   */
  readonly fields: provider_adsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for provider_ads.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__provider_adsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    providers<T extends provider_ads$providersArgs<ExtArgs> = {}>(args?: Subset<T, provider_ads$providersArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the provider_ads model
   */
  interface provider_adsFieldRefs {
    readonly id: FieldRef<"provider_ads", 'String'>
    readonly provider_id: FieldRef<"provider_ads", 'String'>
    readonly badge_text: FieldRef<"provider_ads", 'String'>
    readonly title: FieldRef<"provider_ads", 'String'>
    readonly subtitle: FieldRef<"provider_ads", 'String'>
    readonly image_url: FieldRef<"provider_ads", 'String'>
    readonly action_text: FieldRef<"provider_ads", 'String'>
    readonly bg_color_hex: FieldRef<"provider_ads", 'String'>
    readonly accent_color_hex: FieldRef<"provider_ads", 'String'>
    readonly target_screen: FieldRef<"provider_ads", 'String'>
    readonly target_id: FieldRef<"provider_ads", 'String'>
    readonly start_date: FieldRef<"provider_ads", 'DateTime'>
    readonly end_date: FieldRef<"provider_ads", 'DateTime'>
    readonly is_active: FieldRef<"provider_ads", 'Boolean'>
    readonly priority_order: FieldRef<"provider_ads", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * provider_ads findUnique
   */
  export type provider_adsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
    /**
     * Filter, which provider_ads to fetch.
     */
    where: provider_adsWhereUniqueInput
  }

  /**
   * provider_ads findUniqueOrThrow
   */
  export type provider_adsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
    /**
     * Filter, which provider_ads to fetch.
     */
    where: provider_adsWhereUniqueInput
  }

  /**
   * provider_ads findFirst
   */
  export type provider_adsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
    /**
     * Filter, which provider_ads to fetch.
     */
    where?: provider_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_ads to fetch.
     */
    orderBy?: provider_adsOrderByWithRelationInput | provider_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_ads.
     */
    cursor?: provider_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_ads.
     */
    distinct?: Provider_adsScalarFieldEnum | Provider_adsScalarFieldEnum[]
  }

  /**
   * provider_ads findFirstOrThrow
   */
  export type provider_adsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
    /**
     * Filter, which provider_ads to fetch.
     */
    where?: provider_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_ads to fetch.
     */
    orderBy?: provider_adsOrderByWithRelationInput | provider_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_ads.
     */
    cursor?: provider_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_ads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_ads.
     */
    distinct?: Provider_adsScalarFieldEnum | Provider_adsScalarFieldEnum[]
  }

  /**
   * provider_ads findMany
   */
  export type provider_adsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
    /**
     * Filter, which provider_ads to fetch.
     */
    where?: provider_adsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_ads to fetch.
     */
    orderBy?: provider_adsOrderByWithRelationInput | provider_adsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing provider_ads.
     */
    cursor?: provider_adsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_ads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_ads.
     */
    skip?: number
    distinct?: Provider_adsScalarFieldEnum | Provider_adsScalarFieldEnum[]
  }

  /**
   * provider_ads create
   */
  export type provider_adsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
    /**
     * The data needed to create a provider_ads.
     */
    data: XOR<provider_adsCreateInput, provider_adsUncheckedCreateInput>
  }

  /**
   * provider_ads createMany
   */
  export type provider_adsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many provider_ads.
     */
    data: provider_adsCreateManyInput | provider_adsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * provider_ads createManyAndReturn
   */
  export type provider_adsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * The data used to create many provider_ads.
     */
    data: provider_adsCreateManyInput | provider_adsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_ads update
   */
  export type provider_adsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
    /**
     * The data needed to update a provider_ads.
     */
    data: XOR<provider_adsUpdateInput, provider_adsUncheckedUpdateInput>
    /**
     * Choose, which provider_ads to update.
     */
    where: provider_adsWhereUniqueInput
  }

  /**
   * provider_ads updateMany
   */
  export type provider_adsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update provider_ads.
     */
    data: XOR<provider_adsUpdateManyMutationInput, provider_adsUncheckedUpdateManyInput>
    /**
     * Filter which provider_ads to update
     */
    where?: provider_adsWhereInput
    /**
     * Limit how many provider_ads to update.
     */
    limit?: number
  }

  /**
   * provider_ads updateManyAndReturn
   */
  export type provider_adsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * The data used to update provider_ads.
     */
    data: XOR<provider_adsUpdateManyMutationInput, provider_adsUncheckedUpdateManyInput>
    /**
     * Filter which provider_ads to update
     */
    where?: provider_adsWhereInput
    /**
     * Limit how many provider_ads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_ads upsert
   */
  export type provider_adsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
    /**
     * The filter to search for the provider_ads to update in case it exists.
     */
    where: provider_adsWhereUniqueInput
    /**
     * In case the provider_ads found by the `where` argument doesn't exist, create a new provider_ads with this data.
     */
    create: XOR<provider_adsCreateInput, provider_adsUncheckedCreateInput>
    /**
     * In case the provider_ads was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provider_adsUpdateInput, provider_adsUncheckedUpdateInput>
  }

  /**
   * provider_ads delete
   */
  export type provider_adsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
    /**
     * Filter which provider_ads to delete.
     */
    where: provider_adsWhereUniqueInput
  }

  /**
   * provider_ads deleteMany
   */
  export type provider_adsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_ads to delete
     */
    where?: provider_adsWhereInput
    /**
     * Limit how many provider_ads to delete.
     */
    limit?: number
  }

  /**
   * provider_ads.providers
   */
  export type provider_ads$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
  }

  /**
   * provider_ads without action
   */
  export type provider_adsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
  }


  /**
   * Model provider_bank_details
   */

  export type AggregateProvider_bank_details = {
    _count: Provider_bank_detailsCountAggregateOutputType | null
    _min: Provider_bank_detailsMinAggregateOutputType | null
    _max: Provider_bank_detailsMaxAggregateOutputType | null
  }

  export type Provider_bank_detailsMinAggregateOutputType = {
    id: string | null
    provider_id: string | null
    bank_name: string | null
    account_number: string | null
    account_type: string | null
    account_holder_name: string | null
    holder_identification: string | null
    is_verified: boolean | null
    updated_at: Date | null
  }

  export type Provider_bank_detailsMaxAggregateOutputType = {
    id: string | null
    provider_id: string | null
    bank_name: string | null
    account_number: string | null
    account_type: string | null
    account_holder_name: string | null
    holder_identification: string | null
    is_verified: boolean | null
    updated_at: Date | null
  }

  export type Provider_bank_detailsCountAggregateOutputType = {
    id: number
    provider_id: number
    bank_name: number
    account_number: number
    account_type: number
    account_holder_name: number
    holder_identification: number
    is_verified: number
    updated_at: number
    _all: number
  }


  export type Provider_bank_detailsMinAggregateInputType = {
    id?: true
    provider_id?: true
    bank_name?: true
    account_number?: true
    account_type?: true
    account_holder_name?: true
    holder_identification?: true
    is_verified?: true
    updated_at?: true
  }

  export type Provider_bank_detailsMaxAggregateInputType = {
    id?: true
    provider_id?: true
    bank_name?: true
    account_number?: true
    account_type?: true
    account_holder_name?: true
    holder_identification?: true
    is_verified?: true
    updated_at?: true
  }

  export type Provider_bank_detailsCountAggregateInputType = {
    id?: true
    provider_id?: true
    bank_name?: true
    account_number?: true
    account_type?: true
    account_holder_name?: true
    holder_identification?: true
    is_verified?: true
    updated_at?: true
    _all?: true
  }

  export type Provider_bank_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_bank_details to aggregate.
     */
    where?: provider_bank_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_bank_details to fetch.
     */
    orderBy?: provider_bank_detailsOrderByWithRelationInput | provider_bank_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: provider_bank_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_bank_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_bank_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned provider_bank_details
    **/
    _count?: true | Provider_bank_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Provider_bank_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Provider_bank_detailsMaxAggregateInputType
  }

  export type GetProvider_bank_detailsAggregateType<T extends Provider_bank_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider_bank_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider_bank_details[P]>
      : GetScalarType<T[P], AggregateProvider_bank_details[P]>
  }




  export type provider_bank_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_bank_detailsWhereInput
    orderBy?: provider_bank_detailsOrderByWithAggregationInput | provider_bank_detailsOrderByWithAggregationInput[]
    by: Provider_bank_detailsScalarFieldEnum[] | Provider_bank_detailsScalarFieldEnum
    having?: provider_bank_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Provider_bank_detailsCountAggregateInputType | true
    _min?: Provider_bank_detailsMinAggregateInputType
    _max?: Provider_bank_detailsMaxAggregateInputType
  }

  export type Provider_bank_detailsGroupByOutputType = {
    id: string
    provider_id: string | null
    bank_name: string | null
    account_number: string | null
    account_type: string | null
    account_holder_name: string | null
    holder_identification: string | null
    is_verified: boolean | null
    updated_at: Date | null
    _count: Provider_bank_detailsCountAggregateOutputType | null
    _min: Provider_bank_detailsMinAggregateOutputType | null
    _max: Provider_bank_detailsMaxAggregateOutputType | null
  }

  type GetProvider_bank_detailsGroupByPayload<T extends provider_bank_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Provider_bank_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Provider_bank_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Provider_bank_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Provider_bank_detailsGroupByOutputType[P]>
        }
      >
    >


  export type provider_bank_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    bank_name?: boolean
    account_number?: boolean
    account_type?: boolean
    account_holder_name?: boolean
    holder_identification?: boolean
    is_verified?: boolean
    updated_at?: boolean
    providers?: boolean | provider_bank_details$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_bank_details"]>

  export type provider_bank_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    bank_name?: boolean
    account_number?: boolean
    account_type?: boolean
    account_holder_name?: boolean
    holder_identification?: boolean
    is_verified?: boolean
    updated_at?: boolean
    providers?: boolean | provider_bank_details$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_bank_details"]>

  export type provider_bank_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    bank_name?: boolean
    account_number?: boolean
    account_type?: boolean
    account_holder_name?: boolean
    holder_identification?: boolean
    is_verified?: boolean
    updated_at?: boolean
    providers?: boolean | provider_bank_details$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_bank_details"]>

  export type provider_bank_detailsSelectScalar = {
    id?: boolean
    provider_id?: boolean
    bank_name?: boolean
    account_number?: boolean
    account_type?: boolean
    account_holder_name?: boolean
    holder_identification?: boolean
    is_verified?: boolean
    updated_at?: boolean
  }

  export type provider_bank_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider_id" | "bank_name" | "account_number" | "account_type" | "account_holder_name" | "holder_identification" | "is_verified" | "updated_at", ExtArgs["result"]["provider_bank_details"]>
  export type provider_bank_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | provider_bank_details$providersArgs<ExtArgs>
  }
  export type provider_bank_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | provider_bank_details$providersArgs<ExtArgs>
  }
  export type provider_bank_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | provider_bank_details$providersArgs<ExtArgs>
  }

  export type $provider_bank_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "provider_bank_details"
    objects: {
      providers: Prisma.$providersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider_id: string | null
      bank_name: string | null
      account_number: string | null
      account_type: string | null
      account_holder_name: string | null
      holder_identification: string | null
      is_verified: boolean | null
      updated_at: Date | null
    }, ExtArgs["result"]["provider_bank_details"]>
    composites: {}
  }

  type provider_bank_detailsGetPayload<S extends boolean | null | undefined | provider_bank_detailsDefaultArgs> = $Result.GetResult<Prisma.$provider_bank_detailsPayload, S>

  type provider_bank_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<provider_bank_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Provider_bank_detailsCountAggregateInputType | true
    }

  export interface provider_bank_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['provider_bank_details'], meta: { name: 'provider_bank_details' } }
    /**
     * Find zero or one Provider_bank_details that matches the filter.
     * @param {provider_bank_detailsFindUniqueArgs} args - Arguments to find a Provider_bank_details
     * @example
     * // Get one Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends provider_bank_detailsFindUniqueArgs>(args: SelectSubset<T, provider_bank_detailsFindUniqueArgs<ExtArgs>>): Prisma__provider_bank_detailsClient<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider_bank_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {provider_bank_detailsFindUniqueOrThrowArgs} args - Arguments to find a Provider_bank_details
     * @example
     * // Get one Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends provider_bank_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, provider_bank_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__provider_bank_detailsClient<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_bank_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_bank_detailsFindFirstArgs} args - Arguments to find a Provider_bank_details
     * @example
     * // Get one Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends provider_bank_detailsFindFirstArgs>(args?: SelectSubset<T, provider_bank_detailsFindFirstArgs<ExtArgs>>): Prisma__provider_bank_detailsClient<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_bank_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_bank_detailsFindFirstOrThrowArgs} args - Arguments to find a Provider_bank_details
     * @example
     * // Get one Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends provider_bank_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, provider_bank_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__provider_bank_detailsClient<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provider_bank_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_bank_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.findMany()
     * 
     * // Get first 10 Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provider_bank_detailsWithIdOnly = await prisma.provider_bank_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends provider_bank_detailsFindManyArgs>(args?: SelectSubset<T, provider_bank_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider_bank_details.
     * @param {provider_bank_detailsCreateArgs} args - Arguments to create a Provider_bank_details.
     * @example
     * // Create one Provider_bank_details
     * const Provider_bank_details = await prisma.provider_bank_details.create({
     *   data: {
     *     // ... data to create a Provider_bank_details
     *   }
     * })
     * 
     */
    create<T extends provider_bank_detailsCreateArgs>(args: SelectSubset<T, provider_bank_detailsCreateArgs<ExtArgs>>): Prisma__provider_bank_detailsClient<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provider_bank_details.
     * @param {provider_bank_detailsCreateManyArgs} args - Arguments to create many Provider_bank_details.
     * @example
     * // Create many Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends provider_bank_detailsCreateManyArgs>(args?: SelectSubset<T, provider_bank_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provider_bank_details and returns the data saved in the database.
     * @param {provider_bank_detailsCreateManyAndReturnArgs} args - Arguments to create many Provider_bank_details.
     * @example
     * // Create many Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provider_bank_details and only return the `id`
     * const provider_bank_detailsWithIdOnly = await prisma.provider_bank_details.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends provider_bank_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, provider_bank_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider_bank_details.
     * @param {provider_bank_detailsDeleteArgs} args - Arguments to delete one Provider_bank_details.
     * @example
     * // Delete one Provider_bank_details
     * const Provider_bank_details = await prisma.provider_bank_details.delete({
     *   where: {
     *     // ... filter to delete one Provider_bank_details
     *   }
     * })
     * 
     */
    delete<T extends provider_bank_detailsDeleteArgs>(args: SelectSubset<T, provider_bank_detailsDeleteArgs<ExtArgs>>): Prisma__provider_bank_detailsClient<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider_bank_details.
     * @param {provider_bank_detailsUpdateArgs} args - Arguments to update one Provider_bank_details.
     * @example
     * // Update one Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends provider_bank_detailsUpdateArgs>(args: SelectSubset<T, provider_bank_detailsUpdateArgs<ExtArgs>>): Prisma__provider_bank_detailsClient<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provider_bank_details.
     * @param {provider_bank_detailsDeleteManyArgs} args - Arguments to filter Provider_bank_details to delete.
     * @example
     * // Delete a few Provider_bank_details
     * const { count } = await prisma.provider_bank_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends provider_bank_detailsDeleteManyArgs>(args?: SelectSubset<T, provider_bank_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_bank_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_bank_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends provider_bank_detailsUpdateManyArgs>(args: SelectSubset<T, provider_bank_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_bank_details and returns the data updated in the database.
     * @param {provider_bank_detailsUpdateManyAndReturnArgs} args - Arguments to update many Provider_bank_details.
     * @example
     * // Update many Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provider_bank_details and only return the `id`
     * const provider_bank_detailsWithIdOnly = await prisma.provider_bank_details.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends provider_bank_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, provider_bank_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider_bank_details.
     * @param {provider_bank_detailsUpsertArgs} args - Arguments to update or create a Provider_bank_details.
     * @example
     * // Update or create a Provider_bank_details
     * const provider_bank_details = await prisma.provider_bank_details.upsert({
     *   create: {
     *     // ... data to create a Provider_bank_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider_bank_details we want to update
     *   }
     * })
     */
    upsert<T extends provider_bank_detailsUpsertArgs>(args: SelectSubset<T, provider_bank_detailsUpsertArgs<ExtArgs>>): Prisma__provider_bank_detailsClient<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provider_bank_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_bank_detailsCountArgs} args - Arguments to filter Provider_bank_details to count.
     * @example
     * // Count the number of Provider_bank_details
     * const count = await prisma.provider_bank_details.count({
     *   where: {
     *     // ... the filter for the Provider_bank_details we want to count
     *   }
     * })
    **/
    count<T extends provider_bank_detailsCountArgs>(
      args?: Subset<T, provider_bank_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Provider_bank_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider_bank_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Provider_bank_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Provider_bank_detailsAggregateArgs>(args: Subset<T, Provider_bank_detailsAggregateArgs>): Prisma.PrismaPromise<GetProvider_bank_detailsAggregateType<T>>

    /**
     * Group by Provider_bank_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_bank_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends provider_bank_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: provider_bank_detailsGroupByArgs['orderBy'] }
        : { orderBy?: provider_bank_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, provider_bank_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvider_bank_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the provider_bank_details model
   */
  readonly fields: provider_bank_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for provider_bank_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__provider_bank_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    providers<T extends provider_bank_details$providersArgs<ExtArgs> = {}>(args?: Subset<T, provider_bank_details$providersArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the provider_bank_details model
   */
  interface provider_bank_detailsFieldRefs {
    readonly id: FieldRef<"provider_bank_details", 'String'>
    readonly provider_id: FieldRef<"provider_bank_details", 'String'>
    readonly bank_name: FieldRef<"provider_bank_details", 'String'>
    readonly account_number: FieldRef<"provider_bank_details", 'String'>
    readonly account_type: FieldRef<"provider_bank_details", 'String'>
    readonly account_holder_name: FieldRef<"provider_bank_details", 'String'>
    readonly holder_identification: FieldRef<"provider_bank_details", 'String'>
    readonly is_verified: FieldRef<"provider_bank_details", 'Boolean'>
    readonly updated_at: FieldRef<"provider_bank_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * provider_bank_details findUnique
   */
  export type provider_bank_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
    /**
     * Filter, which provider_bank_details to fetch.
     */
    where: provider_bank_detailsWhereUniqueInput
  }

  /**
   * provider_bank_details findUniqueOrThrow
   */
  export type provider_bank_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
    /**
     * Filter, which provider_bank_details to fetch.
     */
    where: provider_bank_detailsWhereUniqueInput
  }

  /**
   * provider_bank_details findFirst
   */
  export type provider_bank_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
    /**
     * Filter, which provider_bank_details to fetch.
     */
    where?: provider_bank_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_bank_details to fetch.
     */
    orderBy?: provider_bank_detailsOrderByWithRelationInput | provider_bank_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_bank_details.
     */
    cursor?: provider_bank_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_bank_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_bank_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_bank_details.
     */
    distinct?: Provider_bank_detailsScalarFieldEnum | Provider_bank_detailsScalarFieldEnum[]
  }

  /**
   * provider_bank_details findFirstOrThrow
   */
  export type provider_bank_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
    /**
     * Filter, which provider_bank_details to fetch.
     */
    where?: provider_bank_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_bank_details to fetch.
     */
    orderBy?: provider_bank_detailsOrderByWithRelationInput | provider_bank_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_bank_details.
     */
    cursor?: provider_bank_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_bank_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_bank_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_bank_details.
     */
    distinct?: Provider_bank_detailsScalarFieldEnum | Provider_bank_detailsScalarFieldEnum[]
  }

  /**
   * provider_bank_details findMany
   */
  export type provider_bank_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
    /**
     * Filter, which provider_bank_details to fetch.
     */
    where?: provider_bank_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_bank_details to fetch.
     */
    orderBy?: provider_bank_detailsOrderByWithRelationInput | provider_bank_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing provider_bank_details.
     */
    cursor?: provider_bank_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_bank_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_bank_details.
     */
    skip?: number
    distinct?: Provider_bank_detailsScalarFieldEnum | Provider_bank_detailsScalarFieldEnum[]
  }

  /**
   * provider_bank_details create
   */
  export type provider_bank_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a provider_bank_details.
     */
    data: XOR<provider_bank_detailsCreateInput, provider_bank_detailsUncheckedCreateInput>
  }

  /**
   * provider_bank_details createMany
   */
  export type provider_bank_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many provider_bank_details.
     */
    data: provider_bank_detailsCreateManyInput | provider_bank_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * provider_bank_details createManyAndReturn
   */
  export type provider_bank_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many provider_bank_details.
     */
    data: provider_bank_detailsCreateManyInput | provider_bank_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_bank_details update
   */
  export type provider_bank_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a provider_bank_details.
     */
    data: XOR<provider_bank_detailsUpdateInput, provider_bank_detailsUncheckedUpdateInput>
    /**
     * Choose, which provider_bank_details to update.
     */
    where: provider_bank_detailsWhereUniqueInput
  }

  /**
   * provider_bank_details updateMany
   */
  export type provider_bank_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update provider_bank_details.
     */
    data: XOR<provider_bank_detailsUpdateManyMutationInput, provider_bank_detailsUncheckedUpdateManyInput>
    /**
     * Filter which provider_bank_details to update
     */
    where?: provider_bank_detailsWhereInput
    /**
     * Limit how many provider_bank_details to update.
     */
    limit?: number
  }

  /**
   * provider_bank_details updateManyAndReturn
   */
  export type provider_bank_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * The data used to update provider_bank_details.
     */
    data: XOR<provider_bank_detailsUpdateManyMutationInput, provider_bank_detailsUncheckedUpdateManyInput>
    /**
     * Filter which provider_bank_details to update
     */
    where?: provider_bank_detailsWhereInput
    /**
     * Limit how many provider_bank_details to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_bank_details upsert
   */
  export type provider_bank_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the provider_bank_details to update in case it exists.
     */
    where: provider_bank_detailsWhereUniqueInput
    /**
     * In case the provider_bank_details found by the `where` argument doesn't exist, create a new provider_bank_details with this data.
     */
    create: XOR<provider_bank_detailsCreateInput, provider_bank_detailsUncheckedCreateInput>
    /**
     * In case the provider_bank_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provider_bank_detailsUpdateInput, provider_bank_detailsUncheckedUpdateInput>
  }

  /**
   * provider_bank_details delete
   */
  export type provider_bank_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
    /**
     * Filter which provider_bank_details to delete.
     */
    where: provider_bank_detailsWhereUniqueInput
  }

  /**
   * provider_bank_details deleteMany
   */
  export type provider_bank_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_bank_details to delete
     */
    where?: provider_bank_detailsWhereInput
    /**
     * Limit how many provider_bank_details to delete.
     */
    limit?: number
  }

  /**
   * provider_bank_details.providers
   */
  export type provider_bank_details$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
  }

  /**
   * provider_bank_details without action
   */
  export type provider_bank_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
  }


  /**
   * Model provider_branches
   */

  export type AggregateProvider_branches = {
    _count: Provider_branchesCountAggregateOutputType | null
    _avg: Provider_branchesAvgAggregateOutputType | null
    _sum: Provider_branchesSumAggregateOutputType | null
    _min: Provider_branchesMinAggregateOutputType | null
    _max: Provider_branchesMaxAggregateOutputType | null
  }

  export type Provider_branchesAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    rating_cache: number | null
  }

  export type Provider_branchesSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    rating_cache: number | null
  }

  export type Provider_branchesMinAggregateOutputType = {
    id: string | null
    provider_id: string | null
    city_id: string | null
    name: string | null
    description: string | null
    address_text: string | null
    latitude: number | null
    longitude: number | null
    phone_contact: string | null
    email_contact: string | null
    image_url: string | null
    opening_hours_text: string | null
    is_24h: boolean | null
    has_delivery: boolean | null
    rating_cache: number | null
    is_main: boolean | null
    is_active: boolean | null
  }

  export type Provider_branchesMaxAggregateOutputType = {
    id: string | null
    provider_id: string | null
    city_id: string | null
    name: string | null
    description: string | null
    address_text: string | null
    latitude: number | null
    longitude: number | null
    phone_contact: string | null
    email_contact: string | null
    image_url: string | null
    opening_hours_text: string | null
    is_24h: boolean | null
    has_delivery: boolean | null
    rating_cache: number | null
    is_main: boolean | null
    is_active: boolean | null
  }

  export type Provider_branchesCountAggregateOutputType = {
    id: number
    provider_id: number
    city_id: number
    name: number
    description: number
    address_text: number
    latitude: number
    longitude: number
    phone_contact: number
    email_contact: number
    image_url: number
    opening_hours_text: number
    is_24h: number
    has_delivery: number
    rating_cache: number
    is_main: number
    is_active: number
    _all: number
  }


  export type Provider_branchesAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    rating_cache?: true
  }

  export type Provider_branchesSumAggregateInputType = {
    latitude?: true
    longitude?: true
    rating_cache?: true
  }

  export type Provider_branchesMinAggregateInputType = {
    id?: true
    provider_id?: true
    city_id?: true
    name?: true
    description?: true
    address_text?: true
    latitude?: true
    longitude?: true
    phone_contact?: true
    email_contact?: true
    image_url?: true
    opening_hours_text?: true
    is_24h?: true
    has_delivery?: true
    rating_cache?: true
    is_main?: true
    is_active?: true
  }

  export type Provider_branchesMaxAggregateInputType = {
    id?: true
    provider_id?: true
    city_id?: true
    name?: true
    description?: true
    address_text?: true
    latitude?: true
    longitude?: true
    phone_contact?: true
    email_contact?: true
    image_url?: true
    opening_hours_text?: true
    is_24h?: true
    has_delivery?: true
    rating_cache?: true
    is_main?: true
    is_active?: true
  }

  export type Provider_branchesCountAggregateInputType = {
    id?: true
    provider_id?: true
    city_id?: true
    name?: true
    description?: true
    address_text?: true
    latitude?: true
    longitude?: true
    phone_contact?: true
    email_contact?: true
    image_url?: true
    opening_hours_text?: true
    is_24h?: true
    has_delivery?: true
    rating_cache?: true
    is_main?: true
    is_active?: true
    _all?: true
  }

  export type Provider_branchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_branches to aggregate.
     */
    where?: provider_branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_branches to fetch.
     */
    orderBy?: provider_branchesOrderByWithRelationInput | provider_branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: provider_branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned provider_branches
    **/
    _count?: true | Provider_branchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Provider_branchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Provider_branchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Provider_branchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Provider_branchesMaxAggregateInputType
  }

  export type GetProvider_branchesAggregateType<T extends Provider_branchesAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider_branches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider_branches[P]>
      : GetScalarType<T[P], AggregateProvider_branches[P]>
  }




  export type provider_branchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_branchesWhereInput
    orderBy?: provider_branchesOrderByWithAggregationInput | provider_branchesOrderByWithAggregationInput[]
    by: Provider_branchesScalarFieldEnum[] | Provider_branchesScalarFieldEnum
    having?: provider_branchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Provider_branchesCountAggregateInputType | true
    _avg?: Provider_branchesAvgAggregateInputType
    _sum?: Provider_branchesSumAggregateInputType
    _min?: Provider_branchesMinAggregateInputType
    _max?: Provider_branchesMaxAggregateInputType
  }

  export type Provider_branchesGroupByOutputType = {
    id: string
    provider_id: string | null
    city_id: string | null
    name: string | null
    description: string | null
    address_text: string | null
    latitude: number | null
    longitude: number | null
    phone_contact: string | null
    email_contact: string | null
    image_url: string | null
    opening_hours_text: string | null
    is_24h: boolean | null
    has_delivery: boolean | null
    rating_cache: number | null
    is_main: boolean | null
    is_active: boolean | null
    _count: Provider_branchesCountAggregateOutputType | null
    _avg: Provider_branchesAvgAggregateOutputType | null
    _sum: Provider_branchesSumAggregateOutputType | null
    _min: Provider_branchesMinAggregateOutputType | null
    _max: Provider_branchesMaxAggregateOutputType | null
  }

  type GetProvider_branchesGroupByPayload<T extends provider_branchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Provider_branchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Provider_branchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Provider_branchesGroupByOutputType[P]>
            : GetScalarType<T[P], Provider_branchesGroupByOutputType[P]>
        }
      >
    >


  export type provider_branchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    city_id?: boolean
    name?: boolean
    description?: boolean
    address_text?: boolean
    latitude?: boolean
    longitude?: boolean
    phone_contact?: boolean
    email_contact?: boolean
    image_url?: boolean
    opening_hours_text?: boolean
    is_24h?: boolean
    has_delivery?: boolean
    rating_cache?: boolean
    is_main?: boolean
    is_active?: boolean
    appointments?: boolean | provider_branches$appointmentsArgs<ExtArgs>
    patient_favorites?: boolean | provider_branches$patient_favoritesArgs<ExtArgs>
    cities?: boolean | provider_branches$citiesArgs<ExtArgs>
    providers?: boolean | provider_branches$providersArgs<ExtArgs>
    provider_schedules?: boolean | provider_branches$provider_schedulesArgs<ExtArgs>
    reviews?: boolean | provider_branches$reviewsArgs<ExtArgs>
    _count?: boolean | Provider_branchesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider_branches"]>

  export type provider_branchesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    city_id?: boolean
    name?: boolean
    description?: boolean
    address_text?: boolean
    latitude?: boolean
    longitude?: boolean
    phone_contact?: boolean
    email_contact?: boolean
    image_url?: boolean
    opening_hours_text?: boolean
    is_24h?: boolean
    has_delivery?: boolean
    rating_cache?: boolean
    is_main?: boolean
    is_active?: boolean
    cities?: boolean | provider_branches$citiesArgs<ExtArgs>
    providers?: boolean | provider_branches$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_branches"]>

  export type provider_branchesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    city_id?: boolean
    name?: boolean
    description?: boolean
    address_text?: boolean
    latitude?: boolean
    longitude?: boolean
    phone_contact?: boolean
    email_contact?: boolean
    image_url?: boolean
    opening_hours_text?: boolean
    is_24h?: boolean
    has_delivery?: boolean
    rating_cache?: boolean
    is_main?: boolean
    is_active?: boolean
    cities?: boolean | provider_branches$citiesArgs<ExtArgs>
    providers?: boolean | provider_branches$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_branches"]>

  export type provider_branchesSelectScalar = {
    id?: boolean
    provider_id?: boolean
    city_id?: boolean
    name?: boolean
    description?: boolean
    address_text?: boolean
    latitude?: boolean
    longitude?: boolean
    phone_contact?: boolean
    email_contact?: boolean
    image_url?: boolean
    opening_hours_text?: boolean
    is_24h?: boolean
    has_delivery?: boolean
    rating_cache?: boolean
    is_main?: boolean
    is_active?: boolean
  }

  export type provider_branchesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider_id" | "city_id" | "name" | "description" | "address_text" | "latitude" | "longitude" | "phone_contact" | "email_contact" | "image_url" | "opening_hours_text" | "is_24h" | "has_delivery" | "rating_cache" | "is_main" | "is_active", ExtArgs["result"]["provider_branches"]>
  export type provider_branchesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | provider_branches$appointmentsArgs<ExtArgs>
    patient_favorites?: boolean | provider_branches$patient_favoritesArgs<ExtArgs>
    cities?: boolean | provider_branches$citiesArgs<ExtArgs>
    providers?: boolean | provider_branches$providersArgs<ExtArgs>
    provider_schedules?: boolean | provider_branches$provider_schedulesArgs<ExtArgs>
    reviews?: boolean | provider_branches$reviewsArgs<ExtArgs>
    _count?: boolean | Provider_branchesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type provider_branchesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | provider_branches$citiesArgs<ExtArgs>
    providers?: boolean | provider_branches$providersArgs<ExtArgs>
  }
  export type provider_branchesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | provider_branches$citiesArgs<ExtArgs>
    providers?: boolean | provider_branches$providersArgs<ExtArgs>
  }

  export type $provider_branchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "provider_branches"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>[]
      patient_favorites: Prisma.$patient_favoritesPayload<ExtArgs>[]
      cities: Prisma.$citiesPayload<ExtArgs> | null
      providers: Prisma.$providersPayload<ExtArgs> | null
      provider_schedules: Prisma.$provider_schedulesPayload<ExtArgs>[]
      reviews: Prisma.$reviewsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider_id: string | null
      city_id: string | null
      name: string | null
      description: string | null
      address_text: string | null
      latitude: number | null
      longitude: number | null
      phone_contact: string | null
      email_contact: string | null
      image_url: string | null
      opening_hours_text: string | null
      is_24h: boolean | null
      has_delivery: boolean | null
      rating_cache: number | null
      is_main: boolean | null
      is_active: boolean | null
    }, ExtArgs["result"]["provider_branches"]>
    composites: {}
  }

  type provider_branchesGetPayload<S extends boolean | null | undefined | provider_branchesDefaultArgs> = $Result.GetResult<Prisma.$provider_branchesPayload, S>

  type provider_branchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<provider_branchesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Provider_branchesCountAggregateInputType | true
    }

  export interface provider_branchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['provider_branches'], meta: { name: 'provider_branches' } }
    /**
     * Find zero or one Provider_branches that matches the filter.
     * @param {provider_branchesFindUniqueArgs} args - Arguments to find a Provider_branches
     * @example
     * // Get one Provider_branches
     * const provider_branches = await prisma.provider_branches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends provider_branchesFindUniqueArgs>(args: SelectSubset<T, provider_branchesFindUniqueArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider_branches that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {provider_branchesFindUniqueOrThrowArgs} args - Arguments to find a Provider_branches
     * @example
     * // Get one Provider_branches
     * const provider_branches = await prisma.provider_branches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends provider_branchesFindUniqueOrThrowArgs>(args: SelectSubset<T, provider_branchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_branchesFindFirstArgs} args - Arguments to find a Provider_branches
     * @example
     * // Get one Provider_branches
     * const provider_branches = await prisma.provider_branches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends provider_branchesFindFirstArgs>(args?: SelectSubset<T, provider_branchesFindFirstArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_branches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_branchesFindFirstOrThrowArgs} args - Arguments to find a Provider_branches
     * @example
     * // Get one Provider_branches
     * const provider_branches = await prisma.provider_branches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends provider_branchesFindFirstOrThrowArgs>(args?: SelectSubset<T, provider_branchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provider_branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_branchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provider_branches
     * const provider_branches = await prisma.provider_branches.findMany()
     * 
     * // Get first 10 Provider_branches
     * const provider_branches = await prisma.provider_branches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provider_branchesWithIdOnly = await prisma.provider_branches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends provider_branchesFindManyArgs>(args?: SelectSubset<T, provider_branchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider_branches.
     * @param {provider_branchesCreateArgs} args - Arguments to create a Provider_branches.
     * @example
     * // Create one Provider_branches
     * const Provider_branches = await prisma.provider_branches.create({
     *   data: {
     *     // ... data to create a Provider_branches
     *   }
     * })
     * 
     */
    create<T extends provider_branchesCreateArgs>(args: SelectSubset<T, provider_branchesCreateArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provider_branches.
     * @param {provider_branchesCreateManyArgs} args - Arguments to create many Provider_branches.
     * @example
     * // Create many Provider_branches
     * const provider_branches = await prisma.provider_branches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends provider_branchesCreateManyArgs>(args?: SelectSubset<T, provider_branchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provider_branches and returns the data saved in the database.
     * @param {provider_branchesCreateManyAndReturnArgs} args - Arguments to create many Provider_branches.
     * @example
     * // Create many Provider_branches
     * const provider_branches = await prisma.provider_branches.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provider_branches and only return the `id`
     * const provider_branchesWithIdOnly = await prisma.provider_branches.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends provider_branchesCreateManyAndReturnArgs>(args?: SelectSubset<T, provider_branchesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider_branches.
     * @param {provider_branchesDeleteArgs} args - Arguments to delete one Provider_branches.
     * @example
     * // Delete one Provider_branches
     * const Provider_branches = await prisma.provider_branches.delete({
     *   where: {
     *     // ... filter to delete one Provider_branches
     *   }
     * })
     * 
     */
    delete<T extends provider_branchesDeleteArgs>(args: SelectSubset<T, provider_branchesDeleteArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider_branches.
     * @param {provider_branchesUpdateArgs} args - Arguments to update one Provider_branches.
     * @example
     * // Update one Provider_branches
     * const provider_branches = await prisma.provider_branches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends provider_branchesUpdateArgs>(args: SelectSubset<T, provider_branchesUpdateArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provider_branches.
     * @param {provider_branchesDeleteManyArgs} args - Arguments to filter Provider_branches to delete.
     * @example
     * // Delete a few Provider_branches
     * const { count } = await prisma.provider_branches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends provider_branchesDeleteManyArgs>(args?: SelectSubset<T, provider_branchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_branchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provider_branches
     * const provider_branches = await prisma.provider_branches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends provider_branchesUpdateManyArgs>(args: SelectSubset<T, provider_branchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_branches and returns the data updated in the database.
     * @param {provider_branchesUpdateManyAndReturnArgs} args - Arguments to update many Provider_branches.
     * @example
     * // Update many Provider_branches
     * const provider_branches = await prisma.provider_branches.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provider_branches and only return the `id`
     * const provider_branchesWithIdOnly = await prisma.provider_branches.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends provider_branchesUpdateManyAndReturnArgs>(args: SelectSubset<T, provider_branchesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider_branches.
     * @param {provider_branchesUpsertArgs} args - Arguments to update or create a Provider_branches.
     * @example
     * // Update or create a Provider_branches
     * const provider_branches = await prisma.provider_branches.upsert({
     *   create: {
     *     // ... data to create a Provider_branches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider_branches we want to update
     *   }
     * })
     */
    upsert<T extends provider_branchesUpsertArgs>(args: SelectSubset<T, provider_branchesUpsertArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provider_branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_branchesCountArgs} args - Arguments to filter Provider_branches to count.
     * @example
     * // Count the number of Provider_branches
     * const count = await prisma.provider_branches.count({
     *   where: {
     *     // ... the filter for the Provider_branches we want to count
     *   }
     * })
    **/
    count<T extends provider_branchesCountArgs>(
      args?: Subset<T, provider_branchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Provider_branchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider_branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Provider_branchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Provider_branchesAggregateArgs>(args: Subset<T, Provider_branchesAggregateArgs>): Prisma.PrismaPromise<GetProvider_branchesAggregateType<T>>

    /**
     * Group by Provider_branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_branchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends provider_branchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: provider_branchesGroupByArgs['orderBy'] }
        : { orderBy?: provider_branchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, provider_branchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvider_branchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the provider_branches model
   */
  readonly fields: provider_branchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for provider_branches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__provider_branchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends provider_branches$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, provider_branches$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    patient_favorites<T extends provider_branches$patient_favoritesArgs<ExtArgs> = {}>(args?: Subset<T, provider_branches$patient_favoritesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patient_favoritesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cities<T extends provider_branches$citiesArgs<ExtArgs> = {}>(args?: Subset<T, provider_branches$citiesArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    providers<T extends provider_branches$providersArgs<ExtArgs> = {}>(args?: Subset<T, provider_branches$providersArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    provider_schedules<T extends provider_branches$provider_schedulesArgs<ExtArgs> = {}>(args?: Subset<T, provider_branches$provider_schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends provider_branches$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, provider_branches$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the provider_branches model
   */
  interface provider_branchesFieldRefs {
    readonly id: FieldRef<"provider_branches", 'String'>
    readonly provider_id: FieldRef<"provider_branches", 'String'>
    readonly city_id: FieldRef<"provider_branches", 'String'>
    readonly name: FieldRef<"provider_branches", 'String'>
    readonly description: FieldRef<"provider_branches", 'String'>
    readonly address_text: FieldRef<"provider_branches", 'String'>
    readonly latitude: FieldRef<"provider_branches", 'Float'>
    readonly longitude: FieldRef<"provider_branches", 'Float'>
    readonly phone_contact: FieldRef<"provider_branches", 'String'>
    readonly email_contact: FieldRef<"provider_branches", 'String'>
    readonly image_url: FieldRef<"provider_branches", 'String'>
    readonly opening_hours_text: FieldRef<"provider_branches", 'String'>
    readonly is_24h: FieldRef<"provider_branches", 'Boolean'>
    readonly has_delivery: FieldRef<"provider_branches", 'Boolean'>
    readonly rating_cache: FieldRef<"provider_branches", 'Float'>
    readonly is_main: FieldRef<"provider_branches", 'Boolean'>
    readonly is_active: FieldRef<"provider_branches", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * provider_branches findUnique
   */
  export type provider_branchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    /**
     * Filter, which provider_branches to fetch.
     */
    where: provider_branchesWhereUniqueInput
  }

  /**
   * provider_branches findUniqueOrThrow
   */
  export type provider_branchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    /**
     * Filter, which provider_branches to fetch.
     */
    where: provider_branchesWhereUniqueInput
  }

  /**
   * provider_branches findFirst
   */
  export type provider_branchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    /**
     * Filter, which provider_branches to fetch.
     */
    where?: provider_branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_branches to fetch.
     */
    orderBy?: provider_branchesOrderByWithRelationInput | provider_branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_branches.
     */
    cursor?: provider_branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_branches.
     */
    distinct?: Provider_branchesScalarFieldEnum | Provider_branchesScalarFieldEnum[]
  }

  /**
   * provider_branches findFirstOrThrow
   */
  export type provider_branchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    /**
     * Filter, which provider_branches to fetch.
     */
    where?: provider_branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_branches to fetch.
     */
    orderBy?: provider_branchesOrderByWithRelationInput | provider_branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_branches.
     */
    cursor?: provider_branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_branches.
     */
    distinct?: Provider_branchesScalarFieldEnum | Provider_branchesScalarFieldEnum[]
  }

  /**
   * provider_branches findMany
   */
  export type provider_branchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    /**
     * Filter, which provider_branches to fetch.
     */
    where?: provider_branchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_branches to fetch.
     */
    orderBy?: provider_branchesOrderByWithRelationInput | provider_branchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing provider_branches.
     */
    cursor?: provider_branchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_branches.
     */
    skip?: number
    distinct?: Provider_branchesScalarFieldEnum | Provider_branchesScalarFieldEnum[]
  }

  /**
   * provider_branches create
   */
  export type provider_branchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    /**
     * The data needed to create a provider_branches.
     */
    data: XOR<provider_branchesCreateInput, provider_branchesUncheckedCreateInput>
  }

  /**
   * provider_branches createMany
   */
  export type provider_branchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many provider_branches.
     */
    data: provider_branchesCreateManyInput | provider_branchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * provider_branches createManyAndReturn
   */
  export type provider_branchesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * The data used to create many provider_branches.
     */
    data: provider_branchesCreateManyInput | provider_branchesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_branches update
   */
  export type provider_branchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    /**
     * The data needed to update a provider_branches.
     */
    data: XOR<provider_branchesUpdateInput, provider_branchesUncheckedUpdateInput>
    /**
     * Choose, which provider_branches to update.
     */
    where: provider_branchesWhereUniqueInput
  }

  /**
   * provider_branches updateMany
   */
  export type provider_branchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update provider_branches.
     */
    data: XOR<provider_branchesUpdateManyMutationInput, provider_branchesUncheckedUpdateManyInput>
    /**
     * Filter which provider_branches to update
     */
    where?: provider_branchesWhereInput
    /**
     * Limit how many provider_branches to update.
     */
    limit?: number
  }

  /**
   * provider_branches updateManyAndReturn
   */
  export type provider_branchesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * The data used to update provider_branches.
     */
    data: XOR<provider_branchesUpdateManyMutationInput, provider_branchesUncheckedUpdateManyInput>
    /**
     * Filter which provider_branches to update
     */
    where?: provider_branchesWhereInput
    /**
     * Limit how many provider_branches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_branches upsert
   */
  export type provider_branchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    /**
     * The filter to search for the provider_branches to update in case it exists.
     */
    where: provider_branchesWhereUniqueInput
    /**
     * In case the provider_branches found by the `where` argument doesn't exist, create a new provider_branches with this data.
     */
    create: XOR<provider_branchesCreateInput, provider_branchesUncheckedCreateInput>
    /**
     * In case the provider_branches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provider_branchesUpdateInput, provider_branchesUncheckedUpdateInput>
  }

  /**
   * provider_branches delete
   */
  export type provider_branchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    /**
     * Filter which provider_branches to delete.
     */
    where: provider_branchesWhereUniqueInput
  }

  /**
   * provider_branches deleteMany
   */
  export type provider_branchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_branches to delete
     */
    where?: provider_branchesWhereInput
    /**
     * Limit how many provider_branches to delete.
     */
    limit?: number
  }

  /**
   * provider_branches.appointments
   */
  export type provider_branches$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * provider_branches.patient_favorites
   */
  export type provider_branches$patient_favoritesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patient_favorites
     */
    select?: patient_favoritesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patient_favorites
     */
    omit?: patient_favoritesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patient_favoritesInclude<ExtArgs> | null
    where?: patient_favoritesWhereInput
    orderBy?: patient_favoritesOrderByWithRelationInput | patient_favoritesOrderByWithRelationInput[]
    cursor?: patient_favoritesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Patient_favoritesScalarFieldEnum | Patient_favoritesScalarFieldEnum[]
  }

  /**
   * provider_branches.cities
   */
  export type provider_branches$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    where?: citiesWhereInput
  }

  /**
   * provider_branches.providers
   */
  export type provider_branches$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
  }

  /**
   * provider_branches.provider_schedules
   */
  export type provider_branches$provider_schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
    where?: provider_schedulesWhereInput
    orderBy?: provider_schedulesOrderByWithRelationInput | provider_schedulesOrderByWithRelationInput[]
    cursor?: provider_schedulesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Provider_schedulesScalarFieldEnum | Provider_schedulesScalarFieldEnum[]
  }

  /**
   * provider_branches.reviews
   */
  export type provider_branches$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    cursor?: reviewsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * provider_branches without action
   */
  export type provider_branchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
  }


  /**
   * Model provider_catalog
   */

  export type AggregateProvider_catalog = {
    _count: Provider_catalogCountAggregateOutputType | null
    _avg: Provider_catalogAvgAggregateOutputType | null
    _sum: Provider_catalogSumAggregateOutputType | null
    _min: Provider_catalogMinAggregateOutputType | null
    _max: Provider_catalogMaxAggregateOutputType | null
  }

  export type Provider_catalogAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type Provider_catalogSumAggregateOutputType = {
    price: Decimal | null
  }

  export type Provider_catalogMinAggregateOutputType = {
    id: string | null
    provider_id: string | null
    type: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    is_available: boolean | null
    image_url: string | null
  }

  export type Provider_catalogMaxAggregateOutputType = {
    id: string | null
    provider_id: string | null
    type: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    is_available: boolean | null
    image_url: string | null
  }

  export type Provider_catalogCountAggregateOutputType = {
    id: number
    provider_id: number
    type: number
    name: number
    description: number
    price: number
    is_available: number
    image_url: number
    _all: number
  }


  export type Provider_catalogAvgAggregateInputType = {
    price?: true
  }

  export type Provider_catalogSumAggregateInputType = {
    price?: true
  }

  export type Provider_catalogMinAggregateInputType = {
    id?: true
    provider_id?: true
    type?: true
    name?: true
    description?: true
    price?: true
    is_available?: true
    image_url?: true
  }

  export type Provider_catalogMaxAggregateInputType = {
    id?: true
    provider_id?: true
    type?: true
    name?: true
    description?: true
    price?: true
    is_available?: true
    image_url?: true
  }

  export type Provider_catalogCountAggregateInputType = {
    id?: true
    provider_id?: true
    type?: true
    name?: true
    description?: true
    price?: true
    is_available?: true
    image_url?: true
    _all?: true
  }

  export type Provider_catalogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_catalog to aggregate.
     */
    where?: provider_catalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_catalogs to fetch.
     */
    orderBy?: provider_catalogOrderByWithRelationInput | provider_catalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: provider_catalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_catalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned provider_catalogs
    **/
    _count?: true | Provider_catalogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Provider_catalogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Provider_catalogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Provider_catalogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Provider_catalogMaxAggregateInputType
  }

  export type GetProvider_catalogAggregateType<T extends Provider_catalogAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider_catalog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider_catalog[P]>
      : GetScalarType<T[P], AggregateProvider_catalog[P]>
  }




  export type provider_catalogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_catalogWhereInput
    orderBy?: provider_catalogOrderByWithAggregationInput | provider_catalogOrderByWithAggregationInput[]
    by: Provider_catalogScalarFieldEnum[] | Provider_catalogScalarFieldEnum
    having?: provider_catalogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Provider_catalogCountAggregateInputType | true
    _avg?: Provider_catalogAvgAggregateInputType
    _sum?: Provider_catalogSumAggregateInputType
    _min?: Provider_catalogMinAggregateInputType
    _max?: Provider_catalogMaxAggregateInputType
  }

  export type Provider_catalogGroupByOutputType = {
    id: string
    provider_id: string | null
    type: string | null
    name: string | null
    description: string | null
    price: Decimal | null
    is_available: boolean | null
    image_url: string | null
    _count: Provider_catalogCountAggregateOutputType | null
    _avg: Provider_catalogAvgAggregateOutputType | null
    _sum: Provider_catalogSumAggregateOutputType | null
    _min: Provider_catalogMinAggregateOutputType | null
    _max: Provider_catalogMaxAggregateOutputType | null
  }

  type GetProvider_catalogGroupByPayload<T extends provider_catalogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Provider_catalogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Provider_catalogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Provider_catalogGroupByOutputType[P]>
            : GetScalarType<T[P], Provider_catalogGroupByOutputType[P]>
        }
      >
    >


  export type provider_catalogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    is_available?: boolean
    image_url?: boolean
    providers?: boolean | provider_catalog$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_catalog"]>

  export type provider_catalogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    is_available?: boolean
    image_url?: boolean
    providers?: boolean | provider_catalog$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_catalog"]>

  export type provider_catalogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider_id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    is_available?: boolean
    image_url?: boolean
    providers?: boolean | provider_catalog$providersArgs<ExtArgs>
  }, ExtArgs["result"]["provider_catalog"]>

  export type provider_catalogSelectScalar = {
    id?: boolean
    provider_id?: boolean
    type?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    is_available?: boolean
    image_url?: boolean
  }

  export type provider_catalogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "provider_id" | "type" | "name" | "description" | "price" | "is_available" | "image_url", ExtArgs["result"]["provider_catalog"]>
  export type provider_catalogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | provider_catalog$providersArgs<ExtArgs>
  }
  export type provider_catalogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | provider_catalog$providersArgs<ExtArgs>
  }
  export type provider_catalogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | provider_catalog$providersArgs<ExtArgs>
  }

  export type $provider_catalogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "provider_catalog"
    objects: {
      providers: Prisma.$providersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider_id: string | null
      type: string | null
      name: string | null
      description: string | null
      price: Prisma.Decimal | null
      is_available: boolean | null
      image_url: string | null
    }, ExtArgs["result"]["provider_catalog"]>
    composites: {}
  }

  type provider_catalogGetPayload<S extends boolean | null | undefined | provider_catalogDefaultArgs> = $Result.GetResult<Prisma.$provider_catalogPayload, S>

  type provider_catalogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<provider_catalogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Provider_catalogCountAggregateInputType | true
    }

  export interface provider_catalogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['provider_catalog'], meta: { name: 'provider_catalog' } }
    /**
     * Find zero or one Provider_catalog that matches the filter.
     * @param {provider_catalogFindUniqueArgs} args - Arguments to find a Provider_catalog
     * @example
     * // Get one Provider_catalog
     * const provider_catalog = await prisma.provider_catalog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends provider_catalogFindUniqueArgs>(args: SelectSubset<T, provider_catalogFindUniqueArgs<ExtArgs>>): Prisma__provider_catalogClient<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider_catalog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {provider_catalogFindUniqueOrThrowArgs} args - Arguments to find a Provider_catalog
     * @example
     * // Get one Provider_catalog
     * const provider_catalog = await prisma.provider_catalog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends provider_catalogFindUniqueOrThrowArgs>(args: SelectSubset<T, provider_catalogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__provider_catalogClient<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_catalog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_catalogFindFirstArgs} args - Arguments to find a Provider_catalog
     * @example
     * // Get one Provider_catalog
     * const provider_catalog = await prisma.provider_catalog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends provider_catalogFindFirstArgs>(args?: SelectSubset<T, provider_catalogFindFirstArgs<ExtArgs>>): Prisma__provider_catalogClient<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_catalog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_catalogFindFirstOrThrowArgs} args - Arguments to find a Provider_catalog
     * @example
     * // Get one Provider_catalog
     * const provider_catalog = await prisma.provider_catalog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends provider_catalogFindFirstOrThrowArgs>(args?: SelectSubset<T, provider_catalogFindFirstOrThrowArgs<ExtArgs>>): Prisma__provider_catalogClient<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provider_catalogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_catalogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provider_catalogs
     * const provider_catalogs = await prisma.provider_catalog.findMany()
     * 
     * // Get first 10 Provider_catalogs
     * const provider_catalogs = await prisma.provider_catalog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provider_catalogWithIdOnly = await prisma.provider_catalog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends provider_catalogFindManyArgs>(args?: SelectSubset<T, provider_catalogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider_catalog.
     * @param {provider_catalogCreateArgs} args - Arguments to create a Provider_catalog.
     * @example
     * // Create one Provider_catalog
     * const Provider_catalog = await prisma.provider_catalog.create({
     *   data: {
     *     // ... data to create a Provider_catalog
     *   }
     * })
     * 
     */
    create<T extends provider_catalogCreateArgs>(args: SelectSubset<T, provider_catalogCreateArgs<ExtArgs>>): Prisma__provider_catalogClient<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provider_catalogs.
     * @param {provider_catalogCreateManyArgs} args - Arguments to create many Provider_catalogs.
     * @example
     * // Create many Provider_catalogs
     * const provider_catalog = await prisma.provider_catalog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends provider_catalogCreateManyArgs>(args?: SelectSubset<T, provider_catalogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provider_catalogs and returns the data saved in the database.
     * @param {provider_catalogCreateManyAndReturnArgs} args - Arguments to create many Provider_catalogs.
     * @example
     * // Create many Provider_catalogs
     * const provider_catalog = await prisma.provider_catalog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provider_catalogs and only return the `id`
     * const provider_catalogWithIdOnly = await prisma.provider_catalog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends provider_catalogCreateManyAndReturnArgs>(args?: SelectSubset<T, provider_catalogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider_catalog.
     * @param {provider_catalogDeleteArgs} args - Arguments to delete one Provider_catalog.
     * @example
     * // Delete one Provider_catalog
     * const Provider_catalog = await prisma.provider_catalog.delete({
     *   where: {
     *     // ... filter to delete one Provider_catalog
     *   }
     * })
     * 
     */
    delete<T extends provider_catalogDeleteArgs>(args: SelectSubset<T, provider_catalogDeleteArgs<ExtArgs>>): Prisma__provider_catalogClient<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider_catalog.
     * @param {provider_catalogUpdateArgs} args - Arguments to update one Provider_catalog.
     * @example
     * // Update one Provider_catalog
     * const provider_catalog = await prisma.provider_catalog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends provider_catalogUpdateArgs>(args: SelectSubset<T, provider_catalogUpdateArgs<ExtArgs>>): Prisma__provider_catalogClient<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provider_catalogs.
     * @param {provider_catalogDeleteManyArgs} args - Arguments to filter Provider_catalogs to delete.
     * @example
     * // Delete a few Provider_catalogs
     * const { count } = await prisma.provider_catalog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends provider_catalogDeleteManyArgs>(args?: SelectSubset<T, provider_catalogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_catalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_catalogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provider_catalogs
     * const provider_catalog = await prisma.provider_catalog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends provider_catalogUpdateManyArgs>(args: SelectSubset<T, provider_catalogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_catalogs and returns the data updated in the database.
     * @param {provider_catalogUpdateManyAndReturnArgs} args - Arguments to update many Provider_catalogs.
     * @example
     * // Update many Provider_catalogs
     * const provider_catalog = await prisma.provider_catalog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provider_catalogs and only return the `id`
     * const provider_catalogWithIdOnly = await prisma.provider_catalog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends provider_catalogUpdateManyAndReturnArgs>(args: SelectSubset<T, provider_catalogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider_catalog.
     * @param {provider_catalogUpsertArgs} args - Arguments to update or create a Provider_catalog.
     * @example
     * // Update or create a Provider_catalog
     * const provider_catalog = await prisma.provider_catalog.upsert({
     *   create: {
     *     // ... data to create a Provider_catalog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider_catalog we want to update
     *   }
     * })
     */
    upsert<T extends provider_catalogUpsertArgs>(args: SelectSubset<T, provider_catalogUpsertArgs<ExtArgs>>): Prisma__provider_catalogClient<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provider_catalogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_catalogCountArgs} args - Arguments to filter Provider_catalogs to count.
     * @example
     * // Count the number of Provider_catalogs
     * const count = await prisma.provider_catalog.count({
     *   where: {
     *     // ... the filter for the Provider_catalogs we want to count
     *   }
     * })
    **/
    count<T extends provider_catalogCountArgs>(
      args?: Subset<T, provider_catalogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Provider_catalogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider_catalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Provider_catalogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Provider_catalogAggregateArgs>(args: Subset<T, Provider_catalogAggregateArgs>): Prisma.PrismaPromise<GetProvider_catalogAggregateType<T>>

    /**
     * Group by Provider_catalog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_catalogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends provider_catalogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: provider_catalogGroupByArgs['orderBy'] }
        : { orderBy?: provider_catalogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, provider_catalogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvider_catalogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the provider_catalog model
   */
  readonly fields: provider_catalogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for provider_catalog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__provider_catalogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    providers<T extends provider_catalog$providersArgs<ExtArgs> = {}>(args?: Subset<T, provider_catalog$providersArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the provider_catalog model
   */
  interface provider_catalogFieldRefs {
    readonly id: FieldRef<"provider_catalog", 'String'>
    readonly provider_id: FieldRef<"provider_catalog", 'String'>
    readonly type: FieldRef<"provider_catalog", 'String'>
    readonly name: FieldRef<"provider_catalog", 'String'>
    readonly description: FieldRef<"provider_catalog", 'String'>
    readonly price: FieldRef<"provider_catalog", 'Decimal'>
    readonly is_available: FieldRef<"provider_catalog", 'Boolean'>
    readonly image_url: FieldRef<"provider_catalog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * provider_catalog findUnique
   */
  export type provider_catalogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
    /**
     * Filter, which provider_catalog to fetch.
     */
    where: provider_catalogWhereUniqueInput
  }

  /**
   * provider_catalog findUniqueOrThrow
   */
  export type provider_catalogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
    /**
     * Filter, which provider_catalog to fetch.
     */
    where: provider_catalogWhereUniqueInput
  }

  /**
   * provider_catalog findFirst
   */
  export type provider_catalogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
    /**
     * Filter, which provider_catalog to fetch.
     */
    where?: provider_catalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_catalogs to fetch.
     */
    orderBy?: provider_catalogOrderByWithRelationInput | provider_catalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_catalogs.
     */
    cursor?: provider_catalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_catalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_catalogs.
     */
    distinct?: Provider_catalogScalarFieldEnum | Provider_catalogScalarFieldEnum[]
  }

  /**
   * provider_catalog findFirstOrThrow
   */
  export type provider_catalogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
    /**
     * Filter, which provider_catalog to fetch.
     */
    where?: provider_catalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_catalogs to fetch.
     */
    orderBy?: provider_catalogOrderByWithRelationInput | provider_catalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_catalogs.
     */
    cursor?: provider_catalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_catalogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_catalogs.
     */
    distinct?: Provider_catalogScalarFieldEnum | Provider_catalogScalarFieldEnum[]
  }

  /**
   * provider_catalog findMany
   */
  export type provider_catalogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
    /**
     * Filter, which provider_catalogs to fetch.
     */
    where?: provider_catalogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_catalogs to fetch.
     */
    orderBy?: provider_catalogOrderByWithRelationInput | provider_catalogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing provider_catalogs.
     */
    cursor?: provider_catalogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_catalogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_catalogs.
     */
    skip?: number
    distinct?: Provider_catalogScalarFieldEnum | Provider_catalogScalarFieldEnum[]
  }

  /**
   * provider_catalog create
   */
  export type provider_catalogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
    /**
     * The data needed to create a provider_catalog.
     */
    data: XOR<provider_catalogCreateInput, provider_catalogUncheckedCreateInput>
  }

  /**
   * provider_catalog createMany
   */
  export type provider_catalogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many provider_catalogs.
     */
    data: provider_catalogCreateManyInput | provider_catalogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * provider_catalog createManyAndReturn
   */
  export type provider_catalogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * The data used to create many provider_catalogs.
     */
    data: provider_catalogCreateManyInput | provider_catalogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_catalog update
   */
  export type provider_catalogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
    /**
     * The data needed to update a provider_catalog.
     */
    data: XOR<provider_catalogUpdateInput, provider_catalogUncheckedUpdateInput>
    /**
     * Choose, which provider_catalog to update.
     */
    where: provider_catalogWhereUniqueInput
  }

  /**
   * provider_catalog updateMany
   */
  export type provider_catalogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update provider_catalogs.
     */
    data: XOR<provider_catalogUpdateManyMutationInput, provider_catalogUncheckedUpdateManyInput>
    /**
     * Filter which provider_catalogs to update
     */
    where?: provider_catalogWhereInput
    /**
     * Limit how many provider_catalogs to update.
     */
    limit?: number
  }

  /**
   * provider_catalog updateManyAndReturn
   */
  export type provider_catalogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * The data used to update provider_catalogs.
     */
    data: XOR<provider_catalogUpdateManyMutationInput, provider_catalogUncheckedUpdateManyInput>
    /**
     * Filter which provider_catalogs to update
     */
    where?: provider_catalogWhereInput
    /**
     * Limit how many provider_catalogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_catalog upsert
   */
  export type provider_catalogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
    /**
     * The filter to search for the provider_catalog to update in case it exists.
     */
    where: provider_catalogWhereUniqueInput
    /**
     * In case the provider_catalog found by the `where` argument doesn't exist, create a new provider_catalog with this data.
     */
    create: XOR<provider_catalogCreateInput, provider_catalogUncheckedCreateInput>
    /**
     * In case the provider_catalog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provider_catalogUpdateInput, provider_catalogUncheckedUpdateInput>
  }

  /**
   * provider_catalog delete
   */
  export type provider_catalogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
    /**
     * Filter which provider_catalog to delete.
     */
    where: provider_catalogWhereUniqueInput
  }

  /**
   * provider_catalog deleteMany
   */
  export type provider_catalogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_catalogs to delete
     */
    where?: provider_catalogWhereInput
    /**
     * Limit how many provider_catalogs to delete.
     */
    limit?: number
  }

  /**
   * provider_catalog.providers
   */
  export type provider_catalog$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
  }

  /**
   * provider_catalog without action
   */
  export type provider_catalogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
  }


  /**
   * Model provider_schedules
   */

  export type AggregateProvider_schedules = {
    _count: Provider_schedulesCountAggregateOutputType | null
    _avg: Provider_schedulesAvgAggregateOutputType | null
    _sum: Provider_schedulesSumAggregateOutputType | null
    _min: Provider_schedulesMinAggregateOutputType | null
    _max: Provider_schedulesMaxAggregateOutputType | null
  }

  export type Provider_schedulesAvgAggregateOutputType = {
    day_of_week: number | null
  }

  export type Provider_schedulesSumAggregateOutputType = {
    day_of_week: number | null
  }

  export type Provider_schedulesMinAggregateOutputType = {
    id: string | null
    branch_id: string | null
    day_of_week: number | null
    start_time: Date | null
    end_time: Date | null
  }

  export type Provider_schedulesMaxAggregateOutputType = {
    id: string | null
    branch_id: string | null
    day_of_week: number | null
    start_time: Date | null
    end_time: Date | null
  }

  export type Provider_schedulesCountAggregateOutputType = {
    id: number
    branch_id: number
    day_of_week: number
    start_time: number
    end_time: number
    _all: number
  }


  export type Provider_schedulesAvgAggregateInputType = {
    day_of_week?: true
  }

  export type Provider_schedulesSumAggregateInputType = {
    day_of_week?: true
  }

  export type Provider_schedulesMinAggregateInputType = {
    id?: true
    branch_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
  }

  export type Provider_schedulesMaxAggregateInputType = {
    id?: true
    branch_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
  }

  export type Provider_schedulesCountAggregateInputType = {
    id?: true
    branch_id?: true
    day_of_week?: true
    start_time?: true
    end_time?: true
    _all?: true
  }

  export type Provider_schedulesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_schedules to aggregate.
     */
    where?: provider_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_schedules to fetch.
     */
    orderBy?: provider_schedulesOrderByWithRelationInput | provider_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: provider_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned provider_schedules
    **/
    _count?: true | Provider_schedulesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Provider_schedulesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Provider_schedulesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Provider_schedulesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Provider_schedulesMaxAggregateInputType
  }

  export type GetProvider_schedulesAggregateType<T extends Provider_schedulesAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider_schedules]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider_schedules[P]>
      : GetScalarType<T[P], AggregateProvider_schedules[P]>
  }




  export type provider_schedulesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: provider_schedulesWhereInput
    orderBy?: provider_schedulesOrderByWithAggregationInput | provider_schedulesOrderByWithAggregationInput[]
    by: Provider_schedulesScalarFieldEnum[] | Provider_schedulesScalarFieldEnum
    having?: provider_schedulesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Provider_schedulesCountAggregateInputType | true
    _avg?: Provider_schedulesAvgAggregateInputType
    _sum?: Provider_schedulesSumAggregateInputType
    _min?: Provider_schedulesMinAggregateInputType
    _max?: Provider_schedulesMaxAggregateInputType
  }

  export type Provider_schedulesGroupByOutputType = {
    id: string
    branch_id: string | null
    day_of_week: number | null
    start_time: Date | null
    end_time: Date | null
    _count: Provider_schedulesCountAggregateOutputType | null
    _avg: Provider_schedulesAvgAggregateOutputType | null
    _sum: Provider_schedulesSumAggregateOutputType | null
    _min: Provider_schedulesMinAggregateOutputType | null
    _max: Provider_schedulesMaxAggregateOutputType | null
  }

  type GetProvider_schedulesGroupByPayload<T extends provider_schedulesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Provider_schedulesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Provider_schedulesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Provider_schedulesGroupByOutputType[P]>
            : GetScalarType<T[P], Provider_schedulesGroupByOutputType[P]>
        }
      >
    >


  export type provider_schedulesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branch_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    provider_branches?: boolean | provider_schedules$provider_branchesArgs<ExtArgs>
  }, ExtArgs["result"]["provider_schedules"]>

  export type provider_schedulesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branch_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    provider_branches?: boolean | provider_schedules$provider_branchesArgs<ExtArgs>
  }, ExtArgs["result"]["provider_schedules"]>

  export type provider_schedulesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    branch_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
    provider_branches?: boolean | provider_schedules$provider_branchesArgs<ExtArgs>
  }, ExtArgs["result"]["provider_schedules"]>

  export type provider_schedulesSelectScalar = {
    id?: boolean
    branch_id?: boolean
    day_of_week?: boolean
    start_time?: boolean
    end_time?: boolean
  }

  export type provider_schedulesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "branch_id" | "day_of_week" | "start_time" | "end_time", ExtArgs["result"]["provider_schedules"]>
  export type provider_schedulesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | provider_schedules$provider_branchesArgs<ExtArgs>
  }
  export type provider_schedulesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | provider_schedules$provider_branchesArgs<ExtArgs>
  }
  export type provider_schedulesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider_branches?: boolean | provider_schedules$provider_branchesArgs<ExtArgs>
  }

  export type $provider_schedulesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "provider_schedules"
    objects: {
      provider_branches: Prisma.$provider_branchesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      branch_id: string | null
      day_of_week: number | null
      start_time: Date | null
      end_time: Date | null
    }, ExtArgs["result"]["provider_schedules"]>
    composites: {}
  }

  type provider_schedulesGetPayload<S extends boolean | null | undefined | provider_schedulesDefaultArgs> = $Result.GetResult<Prisma.$provider_schedulesPayload, S>

  type provider_schedulesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<provider_schedulesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Provider_schedulesCountAggregateInputType | true
    }

  export interface provider_schedulesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['provider_schedules'], meta: { name: 'provider_schedules' } }
    /**
     * Find zero or one Provider_schedules that matches the filter.
     * @param {provider_schedulesFindUniqueArgs} args - Arguments to find a Provider_schedules
     * @example
     * // Get one Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends provider_schedulesFindUniqueArgs>(args: SelectSubset<T, provider_schedulesFindUniqueArgs<ExtArgs>>): Prisma__provider_schedulesClient<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider_schedules that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {provider_schedulesFindUniqueOrThrowArgs} args - Arguments to find a Provider_schedules
     * @example
     * // Get one Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends provider_schedulesFindUniqueOrThrowArgs>(args: SelectSubset<T, provider_schedulesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__provider_schedulesClient<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_schedulesFindFirstArgs} args - Arguments to find a Provider_schedules
     * @example
     * // Get one Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends provider_schedulesFindFirstArgs>(args?: SelectSubset<T, provider_schedulesFindFirstArgs<ExtArgs>>): Prisma__provider_schedulesClient<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider_schedules that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_schedulesFindFirstOrThrowArgs} args - Arguments to find a Provider_schedules
     * @example
     * // Get one Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends provider_schedulesFindFirstOrThrowArgs>(args?: SelectSubset<T, provider_schedulesFindFirstOrThrowArgs<ExtArgs>>): Prisma__provider_schedulesClient<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Provider_schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_schedulesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.findMany()
     * 
     * // Get first 10 Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const provider_schedulesWithIdOnly = await prisma.provider_schedules.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends provider_schedulesFindManyArgs>(args?: SelectSubset<T, provider_schedulesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider_schedules.
     * @param {provider_schedulesCreateArgs} args - Arguments to create a Provider_schedules.
     * @example
     * // Create one Provider_schedules
     * const Provider_schedules = await prisma.provider_schedules.create({
     *   data: {
     *     // ... data to create a Provider_schedules
     *   }
     * })
     * 
     */
    create<T extends provider_schedulesCreateArgs>(args: SelectSubset<T, provider_schedulesCreateArgs<ExtArgs>>): Prisma__provider_schedulesClient<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Provider_schedules.
     * @param {provider_schedulesCreateManyArgs} args - Arguments to create many Provider_schedules.
     * @example
     * // Create many Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends provider_schedulesCreateManyArgs>(args?: SelectSubset<T, provider_schedulesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Provider_schedules and returns the data saved in the database.
     * @param {provider_schedulesCreateManyAndReturnArgs} args - Arguments to create many Provider_schedules.
     * @example
     * // Create many Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Provider_schedules and only return the `id`
     * const provider_schedulesWithIdOnly = await prisma.provider_schedules.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends provider_schedulesCreateManyAndReturnArgs>(args?: SelectSubset<T, provider_schedulesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider_schedules.
     * @param {provider_schedulesDeleteArgs} args - Arguments to delete one Provider_schedules.
     * @example
     * // Delete one Provider_schedules
     * const Provider_schedules = await prisma.provider_schedules.delete({
     *   where: {
     *     // ... filter to delete one Provider_schedules
     *   }
     * })
     * 
     */
    delete<T extends provider_schedulesDeleteArgs>(args: SelectSubset<T, provider_schedulesDeleteArgs<ExtArgs>>): Prisma__provider_schedulesClient<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider_schedules.
     * @param {provider_schedulesUpdateArgs} args - Arguments to update one Provider_schedules.
     * @example
     * // Update one Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends provider_schedulesUpdateArgs>(args: SelectSubset<T, provider_schedulesUpdateArgs<ExtArgs>>): Prisma__provider_schedulesClient<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Provider_schedules.
     * @param {provider_schedulesDeleteManyArgs} args - Arguments to filter Provider_schedules to delete.
     * @example
     * // Delete a few Provider_schedules
     * const { count } = await prisma.provider_schedules.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends provider_schedulesDeleteManyArgs>(args?: SelectSubset<T, provider_schedulesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_schedulesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends provider_schedulesUpdateManyArgs>(args: SelectSubset<T, provider_schedulesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Provider_schedules and returns the data updated in the database.
     * @param {provider_schedulesUpdateManyAndReturnArgs} args - Arguments to update many Provider_schedules.
     * @example
     * // Update many Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Provider_schedules and only return the `id`
     * const provider_schedulesWithIdOnly = await prisma.provider_schedules.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends provider_schedulesUpdateManyAndReturnArgs>(args: SelectSubset<T, provider_schedulesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider_schedules.
     * @param {provider_schedulesUpsertArgs} args - Arguments to update or create a Provider_schedules.
     * @example
     * // Update or create a Provider_schedules
     * const provider_schedules = await prisma.provider_schedules.upsert({
     *   create: {
     *     // ... data to create a Provider_schedules
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider_schedules we want to update
     *   }
     * })
     */
    upsert<T extends provider_schedulesUpsertArgs>(args: SelectSubset<T, provider_schedulesUpsertArgs<ExtArgs>>): Prisma__provider_schedulesClient<$Result.GetResult<Prisma.$provider_schedulesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Provider_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_schedulesCountArgs} args - Arguments to filter Provider_schedules to count.
     * @example
     * // Count the number of Provider_schedules
     * const count = await prisma.provider_schedules.count({
     *   where: {
     *     // ... the filter for the Provider_schedules we want to count
     *   }
     * })
    **/
    count<T extends provider_schedulesCountArgs>(
      args?: Subset<T, provider_schedulesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Provider_schedulesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Provider_schedulesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Provider_schedulesAggregateArgs>(args: Subset<T, Provider_schedulesAggregateArgs>): Prisma.PrismaPromise<GetProvider_schedulesAggregateType<T>>

    /**
     * Group by Provider_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {provider_schedulesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends provider_schedulesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: provider_schedulesGroupByArgs['orderBy'] }
        : { orderBy?: provider_schedulesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, provider_schedulesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvider_schedulesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the provider_schedules model
   */
  readonly fields: provider_schedulesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for provider_schedules.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__provider_schedulesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider_branches<T extends provider_schedules$provider_branchesArgs<ExtArgs> = {}>(args?: Subset<T, provider_schedules$provider_branchesArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the provider_schedules model
   */
  interface provider_schedulesFieldRefs {
    readonly id: FieldRef<"provider_schedules", 'String'>
    readonly branch_id: FieldRef<"provider_schedules", 'String'>
    readonly day_of_week: FieldRef<"provider_schedules", 'Int'>
    readonly start_time: FieldRef<"provider_schedules", 'DateTime'>
    readonly end_time: FieldRef<"provider_schedules", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * provider_schedules findUnique
   */
  export type provider_schedulesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which provider_schedules to fetch.
     */
    where: provider_schedulesWhereUniqueInput
  }

  /**
   * provider_schedules findUniqueOrThrow
   */
  export type provider_schedulesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which provider_schedules to fetch.
     */
    where: provider_schedulesWhereUniqueInput
  }

  /**
   * provider_schedules findFirst
   */
  export type provider_schedulesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which provider_schedules to fetch.
     */
    where?: provider_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_schedules to fetch.
     */
    orderBy?: provider_schedulesOrderByWithRelationInput | provider_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_schedules.
     */
    cursor?: provider_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_schedules.
     */
    distinct?: Provider_schedulesScalarFieldEnum | Provider_schedulesScalarFieldEnum[]
  }

  /**
   * provider_schedules findFirstOrThrow
   */
  export type provider_schedulesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which provider_schedules to fetch.
     */
    where?: provider_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_schedules to fetch.
     */
    orderBy?: provider_schedulesOrderByWithRelationInput | provider_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for provider_schedules.
     */
    cursor?: provider_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of provider_schedules.
     */
    distinct?: Provider_schedulesScalarFieldEnum | Provider_schedulesScalarFieldEnum[]
  }

  /**
   * provider_schedules findMany
   */
  export type provider_schedulesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
    /**
     * Filter, which provider_schedules to fetch.
     */
    where?: provider_schedulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of provider_schedules to fetch.
     */
    orderBy?: provider_schedulesOrderByWithRelationInput | provider_schedulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing provider_schedules.
     */
    cursor?: provider_schedulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` provider_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` provider_schedules.
     */
    skip?: number
    distinct?: Provider_schedulesScalarFieldEnum | Provider_schedulesScalarFieldEnum[]
  }

  /**
   * provider_schedules create
   */
  export type provider_schedulesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
    /**
     * The data needed to create a provider_schedules.
     */
    data: XOR<provider_schedulesCreateInput, provider_schedulesUncheckedCreateInput>
  }

  /**
   * provider_schedules createMany
   */
  export type provider_schedulesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many provider_schedules.
     */
    data: provider_schedulesCreateManyInput | provider_schedulesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * provider_schedules createManyAndReturn
   */
  export type provider_schedulesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * The data used to create many provider_schedules.
     */
    data: provider_schedulesCreateManyInput | provider_schedulesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_schedules update
   */
  export type provider_schedulesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
    /**
     * The data needed to update a provider_schedules.
     */
    data: XOR<provider_schedulesUpdateInput, provider_schedulesUncheckedUpdateInput>
    /**
     * Choose, which provider_schedules to update.
     */
    where: provider_schedulesWhereUniqueInput
  }

  /**
   * provider_schedules updateMany
   */
  export type provider_schedulesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update provider_schedules.
     */
    data: XOR<provider_schedulesUpdateManyMutationInput, provider_schedulesUncheckedUpdateManyInput>
    /**
     * Filter which provider_schedules to update
     */
    where?: provider_schedulesWhereInput
    /**
     * Limit how many provider_schedules to update.
     */
    limit?: number
  }

  /**
   * provider_schedules updateManyAndReturn
   */
  export type provider_schedulesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * The data used to update provider_schedules.
     */
    data: XOR<provider_schedulesUpdateManyMutationInput, provider_schedulesUncheckedUpdateManyInput>
    /**
     * Filter which provider_schedules to update
     */
    where?: provider_schedulesWhereInput
    /**
     * Limit how many provider_schedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * provider_schedules upsert
   */
  export type provider_schedulesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
    /**
     * The filter to search for the provider_schedules to update in case it exists.
     */
    where: provider_schedulesWhereUniqueInput
    /**
     * In case the provider_schedules found by the `where` argument doesn't exist, create a new provider_schedules with this data.
     */
    create: XOR<provider_schedulesCreateInput, provider_schedulesUncheckedCreateInput>
    /**
     * In case the provider_schedules was found with the provided `where` argument, update it with this data.
     */
    update: XOR<provider_schedulesUpdateInput, provider_schedulesUncheckedUpdateInput>
  }

  /**
   * provider_schedules delete
   */
  export type provider_schedulesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
    /**
     * Filter which provider_schedules to delete.
     */
    where: provider_schedulesWhereUniqueInput
  }

  /**
   * provider_schedules deleteMany
   */
  export type provider_schedulesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which provider_schedules to delete
     */
    where?: provider_schedulesWhereInput
    /**
     * Limit how many provider_schedules to delete.
     */
    limit?: number
  }

  /**
   * provider_schedules.provider_branches
   */
  export type provider_schedules$provider_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    where?: provider_branchesWhereInput
  }

  /**
   * provider_schedules without action
   */
  export type provider_schedulesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_schedules
     */
    select?: provider_schedulesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_schedules
     */
    omit?: provider_schedulesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_schedulesInclude<ExtArgs> | null
  }


  /**
   * Model providers
   */

  export type AggregateProviders = {
    _count: ProvidersCountAggregateOutputType | null
    _avg: ProvidersAvgAggregateOutputType | null
    _sum: ProvidersSumAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  export type ProvidersAvgAggregateOutputType = {
    category_id: number | null
    commission_percentage: Decimal | null
  }

  export type ProvidersSumAggregateOutputType = {
    category_id: number | null
    commission_percentage: Decimal | null
  }

  export type ProvidersMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    category_id: number | null
    commercial_name: string | null
    logo_url: string | null
    description: string | null
    verification_status: string | null
    commission_percentage: Decimal | null
  }

  export type ProvidersMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    category_id: number | null
    commercial_name: string | null
    logo_url: string | null
    description: string | null
    verification_status: string | null
    commission_percentage: Decimal | null
  }

  export type ProvidersCountAggregateOutputType = {
    id: number
    user_id: number
    category_id: number
    commercial_name: number
    logo_url: number
    description: number
    verification_status: number
    commission_percentage: number
    _all: number
  }


  export type ProvidersAvgAggregateInputType = {
    category_id?: true
    commission_percentage?: true
  }

  export type ProvidersSumAggregateInputType = {
    category_id?: true
    commission_percentage?: true
  }

  export type ProvidersMinAggregateInputType = {
    id?: true
    user_id?: true
    category_id?: true
    commercial_name?: true
    logo_url?: true
    description?: true
    verification_status?: true
    commission_percentage?: true
  }

  export type ProvidersMaxAggregateInputType = {
    id?: true
    user_id?: true
    category_id?: true
    commercial_name?: true
    logo_url?: true
    description?: true
    verification_status?: true
    commission_percentage?: true
  }

  export type ProvidersCountAggregateInputType = {
    id?: true
    user_id?: true
    category_id?: true
    commercial_name?: true
    logo_url?: true
    description?: true
    verification_status?: true
    commission_percentage?: true
    _all?: true
  }

  export type ProvidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which providers to aggregate.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned providers
    **/
    _count?: true | ProvidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProvidersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProvidersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvidersMaxAggregateInputType
  }

  export type GetProvidersAggregateType<T extends ProvidersAggregateArgs> = {
        [P in keyof T & keyof AggregateProviders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviders[P]>
      : GetScalarType<T[P], AggregateProviders[P]>
  }




  export type providersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: providersWhereInput
    orderBy?: providersOrderByWithAggregationInput | providersOrderByWithAggregationInput[]
    by: ProvidersScalarFieldEnum[] | ProvidersScalarFieldEnum
    having?: providersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvidersCountAggregateInputType | true
    _avg?: ProvidersAvgAggregateInputType
    _sum?: ProvidersSumAggregateInputType
    _min?: ProvidersMinAggregateInputType
    _max?: ProvidersMaxAggregateInputType
  }

  export type ProvidersGroupByOutputType = {
    id: string
    user_id: string | null
    category_id: number | null
    commercial_name: string | null
    logo_url: string | null
    description: string | null
    verification_status: string | null
    commission_percentage: Decimal | null
    _count: ProvidersCountAggregateOutputType | null
    _avg: ProvidersAvgAggregateOutputType | null
    _sum: ProvidersSumAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  type GetProvidersGroupByPayload<T extends providersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
            : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
        }
      >
    >


  export type providersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    category_id?: boolean
    commercial_name?: boolean
    logo_url?: boolean
    description?: boolean
    verification_status?: boolean
    commission_percentage?: boolean
    appointments?: boolean | providers$appointmentsArgs<ExtArgs>
    medical_history?: boolean | providers$medical_historyArgs<ExtArgs>
    payouts?: boolean | providers$payoutsArgs<ExtArgs>
    provider_ads?: boolean | providers$provider_adsArgs<ExtArgs>
    provider_bank_details?: boolean | providers$provider_bank_detailsArgs<ExtArgs>
    provider_branches?: boolean | providers$provider_branchesArgs<ExtArgs>
    provider_catalog?: boolean | providers$provider_catalogArgs<ExtArgs>
    service_categories?: boolean | providers$service_categoriesArgs<ExtArgs>
    users?: boolean | providers$usersArgs<ExtArgs>
    _count?: boolean | ProvidersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providers"]>

  export type providersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    category_id?: boolean
    commercial_name?: boolean
    logo_url?: boolean
    description?: boolean
    verification_status?: boolean
    commission_percentage?: boolean
    service_categories?: boolean | providers$service_categoriesArgs<ExtArgs>
    users?: boolean | providers$usersArgs<ExtArgs>
  }, ExtArgs["result"]["providers"]>

  export type providersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    category_id?: boolean
    commercial_name?: boolean
    logo_url?: boolean
    description?: boolean
    verification_status?: boolean
    commission_percentage?: boolean
    service_categories?: boolean | providers$service_categoriesArgs<ExtArgs>
    users?: boolean | providers$usersArgs<ExtArgs>
  }, ExtArgs["result"]["providers"]>

  export type providersSelectScalar = {
    id?: boolean
    user_id?: boolean
    category_id?: boolean
    commercial_name?: boolean
    logo_url?: boolean
    description?: boolean
    verification_status?: boolean
    commission_percentage?: boolean
  }

  export type providersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "category_id" | "commercial_name" | "logo_url" | "description" | "verification_status" | "commission_percentage", ExtArgs["result"]["providers"]>
  export type providersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | providers$appointmentsArgs<ExtArgs>
    medical_history?: boolean | providers$medical_historyArgs<ExtArgs>
    payouts?: boolean | providers$payoutsArgs<ExtArgs>
    provider_ads?: boolean | providers$provider_adsArgs<ExtArgs>
    provider_bank_details?: boolean | providers$provider_bank_detailsArgs<ExtArgs>
    provider_branches?: boolean | providers$provider_branchesArgs<ExtArgs>
    provider_catalog?: boolean | providers$provider_catalogArgs<ExtArgs>
    service_categories?: boolean | providers$service_categoriesArgs<ExtArgs>
    users?: boolean | providers$usersArgs<ExtArgs>
    _count?: boolean | ProvidersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type providersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service_categories?: boolean | providers$service_categoriesArgs<ExtArgs>
    users?: boolean | providers$usersArgs<ExtArgs>
  }
  export type providersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service_categories?: boolean | providers$service_categoriesArgs<ExtArgs>
    users?: boolean | providers$usersArgs<ExtArgs>
  }

  export type $providersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "providers"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs>[]
      medical_history: Prisma.$medical_historyPayload<ExtArgs>[]
      payouts: Prisma.$payoutsPayload<ExtArgs>[]
      provider_ads: Prisma.$provider_adsPayload<ExtArgs>[]
      provider_bank_details: Prisma.$provider_bank_detailsPayload<ExtArgs>[]
      provider_branches: Prisma.$provider_branchesPayload<ExtArgs>[]
      provider_catalog: Prisma.$provider_catalogPayload<ExtArgs>[]
      service_categories: Prisma.$service_categoriesPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      category_id: number | null
      commercial_name: string | null
      logo_url: string | null
      description: string | null
      verification_status: string | null
      commission_percentage: Prisma.Decimal | null
    }, ExtArgs["result"]["providers"]>
    composites: {}
  }

  type providersGetPayload<S extends boolean | null | undefined | providersDefaultArgs> = $Result.GetResult<Prisma.$providersPayload, S>

  type providersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<providersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvidersCountAggregateInputType | true
    }

  export interface providersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['providers'], meta: { name: 'providers' } }
    /**
     * Find zero or one Providers that matches the filter.
     * @param {providersFindUniqueArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends providersFindUniqueArgs>(args: SelectSubset<T, providersFindUniqueArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Providers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {providersFindUniqueOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends providersFindUniqueOrThrowArgs>(args: SelectSubset<T, providersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindFirstArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends providersFindFirstArgs>(args?: SelectSubset<T, providersFindFirstArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Providers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindFirstOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends providersFindFirstOrThrowArgs>(args?: SelectSubset<T, providersFindFirstOrThrowArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.providers.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.providers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providersWithIdOnly = await prisma.providers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends providersFindManyArgs>(args?: SelectSubset<T, providersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Providers.
     * @param {providersCreateArgs} args - Arguments to create a Providers.
     * @example
     * // Create one Providers
     * const Providers = await prisma.providers.create({
     *   data: {
     *     // ... data to create a Providers
     *   }
     * })
     * 
     */
    create<T extends providersCreateArgs>(args: SelectSubset<T, providersCreateArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Providers.
     * @param {providersCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const providers = await prisma.providers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends providersCreateManyArgs>(args?: SelectSubset<T, providersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Providers and returns the data saved in the database.
     * @param {providersCreateManyAndReturnArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const providers = await prisma.providers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Providers and only return the `id`
     * const providersWithIdOnly = await prisma.providers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends providersCreateManyAndReturnArgs>(args?: SelectSubset<T, providersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Providers.
     * @param {providersDeleteArgs} args - Arguments to delete one Providers.
     * @example
     * // Delete one Providers
     * const Providers = await prisma.providers.delete({
     *   where: {
     *     // ... filter to delete one Providers
     *   }
     * })
     * 
     */
    delete<T extends providersDeleteArgs>(args: SelectSubset<T, providersDeleteArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Providers.
     * @param {providersUpdateArgs} args - Arguments to update one Providers.
     * @example
     * // Update one Providers
     * const providers = await prisma.providers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends providersUpdateArgs>(args: SelectSubset<T, providersUpdateArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Providers.
     * @param {providersDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.providers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends providersDeleteManyArgs>(args?: SelectSubset<T, providersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const providers = await prisma.providers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends providersUpdateManyArgs>(args: SelectSubset<T, providersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers and returns the data updated in the database.
     * @param {providersUpdateManyAndReturnArgs} args - Arguments to update many Providers.
     * @example
     * // Update many Providers
     * const providers = await prisma.providers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Providers and only return the `id`
     * const providersWithIdOnly = await prisma.providers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends providersUpdateManyAndReturnArgs>(args: SelectSubset<T, providersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Providers.
     * @param {providersUpsertArgs} args - Arguments to update or create a Providers.
     * @example
     * // Update or create a Providers
     * const providers = await prisma.providers.upsert({
     *   create: {
     *     // ... data to create a Providers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Providers we want to update
     *   }
     * })
     */
    upsert<T extends providersUpsertArgs>(args: SelectSubset<T, providersUpsertArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.providers.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends providersCountArgs>(
      args?: Subset<T, providersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvidersAggregateArgs>(args: Subset<T, ProvidersAggregateArgs>): Prisma.PrismaPromise<GetProvidersAggregateType<T>>

    /**
     * Group by Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends providersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: providersGroupByArgs['orderBy'] }
        : { orderBy?: providersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, providersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the providers model
   */
  readonly fields: providersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for providers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__providersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends providers$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, providers$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medical_history<T extends providers$medical_historyArgs<ExtArgs> = {}>(args?: Subset<T, providers$medical_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$medical_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payouts<T extends providers$payoutsArgs<ExtArgs> = {}>(args?: Subset<T, providers$payoutsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$payoutsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    provider_ads<T extends providers$provider_adsArgs<ExtArgs> = {}>(args?: Subset<T, providers$provider_adsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_adsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    provider_bank_details<T extends providers$provider_bank_detailsArgs<ExtArgs> = {}>(args?: Subset<T, providers$provider_bank_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_bank_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    provider_branches<T extends providers$provider_branchesArgs<ExtArgs> = {}>(args?: Subset<T, providers$provider_branchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    provider_catalog<T extends providers$provider_catalogArgs<ExtArgs> = {}>(args?: Subset<T, providers$provider_catalogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$provider_catalogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    service_categories<T extends providers$service_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, providers$service_categoriesArgs<ExtArgs>>): Prisma__service_categoriesClient<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends providers$usersArgs<ExtArgs> = {}>(args?: Subset<T, providers$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the providers model
   */
  interface providersFieldRefs {
    readonly id: FieldRef<"providers", 'String'>
    readonly user_id: FieldRef<"providers", 'String'>
    readonly category_id: FieldRef<"providers", 'Int'>
    readonly commercial_name: FieldRef<"providers", 'String'>
    readonly logo_url: FieldRef<"providers", 'String'>
    readonly description: FieldRef<"providers", 'String'>
    readonly verification_status: FieldRef<"providers", 'String'>
    readonly commission_percentage: FieldRef<"providers", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * providers findUnique
   */
  export type providersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers findUniqueOrThrow
   */
  export type providersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers findFirst
   */
  export type providersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of providers.
     */
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * providers findFirstOrThrow
   */
  export type providersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of providers.
     */
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * providers findMany
   */
  export type providersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * providers create
   */
  export type providersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * The data needed to create a providers.
     */
    data: XOR<providersCreateInput, providersUncheckedCreateInput>
  }

  /**
   * providers createMany
   */
  export type providersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many providers.
     */
    data: providersCreateManyInput | providersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * providers createManyAndReturn
   */
  export type providersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * The data used to create many providers.
     */
    data: providersCreateManyInput | providersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * providers update
   */
  export type providersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * The data needed to update a providers.
     */
    data: XOR<providersUpdateInput, providersUncheckedUpdateInput>
    /**
     * Choose, which providers to update.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers updateMany
   */
  export type providersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update providers.
     */
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyInput>
    /**
     * Filter which providers to update
     */
    where?: providersWhereInput
    /**
     * Limit how many providers to update.
     */
    limit?: number
  }

  /**
   * providers updateManyAndReturn
   */
  export type providersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * The data used to update providers.
     */
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyInput>
    /**
     * Filter which providers to update
     */
    where?: providersWhereInput
    /**
     * Limit how many providers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * providers upsert
   */
  export type providersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * The filter to search for the providers to update in case it exists.
     */
    where: providersWhereUniqueInput
    /**
     * In case the providers found by the `where` argument doesn't exist, create a new providers with this data.
     */
    create: XOR<providersCreateInput, providersUncheckedCreateInput>
    /**
     * In case the providers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<providersUpdateInput, providersUncheckedUpdateInput>
  }

  /**
   * providers delete
   */
  export type providersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter which providers to delete.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers deleteMany
   */
  export type providersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which providers to delete
     */
    where?: providersWhereInput
    /**
     * Limit how many providers to delete.
     */
    limit?: number
  }

  /**
   * providers.appointments
   */
  export type providers$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
    orderBy?: appointmentsOrderByWithRelationInput | appointmentsOrderByWithRelationInput[]
    cursor?: appointmentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentsScalarFieldEnum | AppointmentsScalarFieldEnum[]
  }

  /**
   * providers.medical_history
   */
  export type providers$medical_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the medical_history
     */
    select?: medical_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the medical_history
     */
    omit?: medical_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: medical_historyInclude<ExtArgs> | null
    where?: medical_historyWhereInput
    orderBy?: medical_historyOrderByWithRelationInput | medical_historyOrderByWithRelationInput[]
    cursor?: medical_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Medical_historyScalarFieldEnum | Medical_historyScalarFieldEnum[]
  }

  /**
   * providers.payouts
   */
  export type providers$payoutsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payouts
     */
    select?: payoutsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payouts
     */
    omit?: payoutsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: payoutsInclude<ExtArgs> | null
    where?: payoutsWhereInput
    orderBy?: payoutsOrderByWithRelationInput | payoutsOrderByWithRelationInput[]
    cursor?: payoutsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayoutsScalarFieldEnum | PayoutsScalarFieldEnum[]
  }

  /**
   * providers.provider_ads
   */
  export type providers$provider_adsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_ads
     */
    select?: provider_adsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_ads
     */
    omit?: provider_adsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_adsInclude<ExtArgs> | null
    where?: provider_adsWhereInput
    orderBy?: provider_adsOrderByWithRelationInput | provider_adsOrderByWithRelationInput[]
    cursor?: provider_adsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Provider_adsScalarFieldEnum | Provider_adsScalarFieldEnum[]
  }

  /**
   * providers.provider_bank_details
   */
  export type providers$provider_bank_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_bank_details
     */
    select?: provider_bank_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_bank_details
     */
    omit?: provider_bank_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_bank_detailsInclude<ExtArgs> | null
    where?: provider_bank_detailsWhereInput
    orderBy?: provider_bank_detailsOrderByWithRelationInput | provider_bank_detailsOrderByWithRelationInput[]
    cursor?: provider_bank_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Provider_bank_detailsScalarFieldEnum | Provider_bank_detailsScalarFieldEnum[]
  }

  /**
   * providers.provider_branches
   */
  export type providers$provider_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    where?: provider_branchesWhereInput
    orderBy?: provider_branchesOrderByWithRelationInput | provider_branchesOrderByWithRelationInput[]
    cursor?: provider_branchesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Provider_branchesScalarFieldEnum | Provider_branchesScalarFieldEnum[]
  }

  /**
   * providers.provider_catalog
   */
  export type providers$provider_catalogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_catalog
     */
    select?: provider_catalogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_catalog
     */
    omit?: provider_catalogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_catalogInclude<ExtArgs> | null
    where?: provider_catalogWhereInput
    orderBy?: provider_catalogOrderByWithRelationInput | provider_catalogOrderByWithRelationInput[]
    cursor?: provider_catalogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Provider_catalogScalarFieldEnum | Provider_catalogScalarFieldEnum[]
  }

  /**
   * providers.service_categories
   */
  export type providers$service_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
    where?: service_categoriesWhereInput
  }

  /**
   * providers.users
   */
  export type providers$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * providers without action
   */
  export type providersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
  }


  /**
   * Model reviews
   */

  export type AggregateReviews = {
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  export type ReviewsAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewsSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewsMinAggregateOutputType = {
    id: string | null
    patient_id: string | null
    branch_id: string | null
    appointment_id: string | null
    rating: number | null
    comment: string | null
    created_at: Date | null
  }

  export type ReviewsMaxAggregateOutputType = {
    id: string | null
    patient_id: string | null
    branch_id: string | null
    appointment_id: string | null
    rating: number | null
    comment: string | null
    created_at: Date | null
  }

  export type ReviewsCountAggregateOutputType = {
    id: number
    patient_id: number
    branch_id: number
    appointment_id: number
    rating: number
    comment: number
    created_at: number
    _all: number
  }


  export type ReviewsAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewsSumAggregateInputType = {
    rating?: true
  }

  export type ReviewsMinAggregateInputType = {
    id?: true
    patient_id?: true
    branch_id?: true
    appointment_id?: true
    rating?: true
    comment?: true
    created_at?: true
  }

  export type ReviewsMaxAggregateInputType = {
    id?: true
    patient_id?: true
    branch_id?: true
    appointment_id?: true
    rating?: true
    comment?: true
    created_at?: true
  }

  export type ReviewsCountAggregateInputType = {
    id?: true
    patient_id?: true
    branch_id?: true
    appointment_id?: true
    rating?: true
    comment?: true
    created_at?: true
    _all?: true
  }

  export type ReviewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to aggregate.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reviews
    **/
    _count?: true | ReviewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewsMaxAggregateInputType
  }

  export type GetReviewsAggregateType<T extends ReviewsAggregateArgs> = {
        [P in keyof T & keyof AggregateReviews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviews[P]>
      : GetScalarType<T[P], AggregateReviews[P]>
  }




  export type reviewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reviewsWhereInput
    orderBy?: reviewsOrderByWithAggregationInput | reviewsOrderByWithAggregationInput[]
    by: ReviewsScalarFieldEnum[] | ReviewsScalarFieldEnum
    having?: reviewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewsCountAggregateInputType | true
    _avg?: ReviewsAvgAggregateInputType
    _sum?: ReviewsSumAggregateInputType
    _min?: ReviewsMinAggregateInputType
    _max?: ReviewsMaxAggregateInputType
  }

  export type ReviewsGroupByOutputType = {
    id: string
    patient_id: string | null
    branch_id: string | null
    appointment_id: string | null
    rating: number | null
    comment: string | null
    created_at: Date | null
    _count: ReviewsCountAggregateOutputType | null
    _avg: ReviewsAvgAggregateOutputType | null
    _sum: ReviewsSumAggregateOutputType | null
    _min: ReviewsMinAggregateOutputType | null
    _max: ReviewsMaxAggregateOutputType | null
  }

  type GetReviewsGroupByPayload<T extends reviewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewsGroupByOutputType[P]>
        }
      >
    >


  export type reviewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    appointment_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    appointments?: boolean | reviews$appointmentsArgs<ExtArgs>
    provider_branches?: boolean | reviews$provider_branchesArgs<ExtArgs>
    patients?: boolean | reviews$patientsArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    appointment_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    appointments?: boolean | reviews$appointmentsArgs<ExtArgs>
    provider_branches?: boolean | reviews$provider_branchesArgs<ExtArgs>
    patients?: boolean | reviews$patientsArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    appointment_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
    appointments?: boolean | reviews$appointmentsArgs<ExtArgs>
    provider_branches?: boolean | reviews$provider_branchesArgs<ExtArgs>
    patients?: boolean | reviews$patientsArgs<ExtArgs>
  }, ExtArgs["result"]["reviews"]>

  export type reviewsSelectScalar = {
    id?: boolean
    patient_id?: boolean
    branch_id?: boolean
    appointment_id?: boolean
    rating?: boolean
    comment?: boolean
    created_at?: boolean
  }

  export type reviewsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "patient_id" | "branch_id" | "appointment_id" | "rating" | "comment" | "created_at", ExtArgs["result"]["reviews"]>
  export type reviewsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | reviews$appointmentsArgs<ExtArgs>
    provider_branches?: boolean | reviews$provider_branchesArgs<ExtArgs>
    patients?: boolean | reviews$patientsArgs<ExtArgs>
  }
  export type reviewsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | reviews$appointmentsArgs<ExtArgs>
    provider_branches?: boolean | reviews$provider_branchesArgs<ExtArgs>
    patients?: boolean | reviews$patientsArgs<ExtArgs>
  }
  export type reviewsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | reviews$appointmentsArgs<ExtArgs>
    provider_branches?: boolean | reviews$provider_branchesArgs<ExtArgs>
    patients?: boolean | reviews$patientsArgs<ExtArgs>
  }

  export type $reviewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reviews"
    objects: {
      appointments: Prisma.$appointmentsPayload<ExtArgs> | null
      provider_branches: Prisma.$provider_branchesPayload<ExtArgs> | null
      patients: Prisma.$patientsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patient_id: string | null
      branch_id: string | null
      appointment_id: string | null
      rating: number | null
      comment: string | null
      created_at: Date | null
    }, ExtArgs["result"]["reviews"]>
    composites: {}
  }

  type reviewsGetPayload<S extends boolean | null | undefined | reviewsDefaultArgs> = $Result.GetResult<Prisma.$reviewsPayload, S>

  type reviewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reviewsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewsCountAggregateInputType | true
    }

  export interface reviewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reviews'], meta: { name: 'reviews' } }
    /**
     * Find zero or one Reviews that matches the filter.
     * @param {reviewsFindUniqueArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reviewsFindUniqueArgs>(args: SelectSubset<T, reviewsFindUniqueArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reviews that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reviewsFindUniqueOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reviewsFindUniqueOrThrowArgs>(args: SelectSubset<T, reviewsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reviewsFindFirstArgs>(args?: SelectSubset<T, reviewsFindFirstArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reviews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindFirstOrThrowArgs} args - Arguments to find a Reviews
     * @example
     * // Get one Reviews
     * const reviews = await prisma.reviews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reviewsFindFirstOrThrowArgs>(args?: SelectSubset<T, reviewsFindFirstOrThrowArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.reviews.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.reviews.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewsWithIdOnly = await prisma.reviews.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reviewsFindManyArgs>(args?: SelectSubset<T, reviewsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reviews.
     * @param {reviewsCreateArgs} args - Arguments to create a Reviews.
     * @example
     * // Create one Reviews
     * const Reviews = await prisma.reviews.create({
     *   data: {
     *     // ... data to create a Reviews
     *   }
     * })
     * 
     */
    create<T extends reviewsCreateArgs>(args: SelectSubset<T, reviewsCreateArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {reviewsCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reviewsCreateManyArgs>(args?: SelectSubset<T, reviewsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {reviewsCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const reviews = await prisma.reviews.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewsWithIdOnly = await prisma.reviews.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reviewsCreateManyAndReturnArgs>(args?: SelectSubset<T, reviewsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reviews.
     * @param {reviewsDeleteArgs} args - Arguments to delete one Reviews.
     * @example
     * // Delete one Reviews
     * const Reviews = await prisma.reviews.delete({
     *   where: {
     *     // ... filter to delete one Reviews
     *   }
     * })
     * 
     */
    delete<T extends reviewsDeleteArgs>(args: SelectSubset<T, reviewsDeleteArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reviews.
     * @param {reviewsUpdateArgs} args - Arguments to update one Reviews.
     * @example
     * // Update one Reviews
     * const reviews = await prisma.reviews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reviewsUpdateArgs>(args: SelectSubset<T, reviewsUpdateArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {reviewsDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.reviews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reviewsDeleteManyArgs>(args?: SelectSubset<T, reviewsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reviewsUpdateManyArgs>(args: SelectSubset<T, reviewsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {reviewsUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const reviews = await prisma.reviews.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewsWithIdOnly = await prisma.reviews.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reviewsUpdateManyAndReturnArgs>(args: SelectSubset<T, reviewsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reviews.
     * @param {reviewsUpsertArgs} args - Arguments to update or create a Reviews.
     * @example
     * // Update or create a Reviews
     * const reviews = await prisma.reviews.upsert({
     *   create: {
     *     // ... data to create a Reviews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reviews we want to update
     *   }
     * })
     */
    upsert<T extends reviewsUpsertArgs>(args: SelectSubset<T, reviewsUpsertArgs<ExtArgs>>): Prisma__reviewsClient<$Result.GetResult<Prisma.$reviewsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.reviews.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends reviewsCountArgs>(
      args?: Subset<T, reviewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewsAggregateArgs>(args: Subset<T, ReviewsAggregateArgs>): Prisma.PrismaPromise<GetReviewsAggregateType<T>>

    /**
     * Group by Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reviewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reviewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reviewsGroupByArgs['orderBy'] }
        : { orderBy?: reviewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reviewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reviews model
   */
  readonly fields: reviewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reviews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reviewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends reviews$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, reviews$appointmentsArgs<ExtArgs>>): Prisma__appointmentsClient<$Result.GetResult<Prisma.$appointmentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    provider_branches<T extends reviews$provider_branchesArgs<ExtArgs> = {}>(args?: Subset<T, reviews$provider_branchesArgs<ExtArgs>>): Prisma__provider_branchesClient<$Result.GetResult<Prisma.$provider_branchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    patients<T extends reviews$patientsArgs<ExtArgs> = {}>(args?: Subset<T, reviews$patientsArgs<ExtArgs>>): Prisma__patientsClient<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reviews model
   */
  interface reviewsFieldRefs {
    readonly id: FieldRef<"reviews", 'String'>
    readonly patient_id: FieldRef<"reviews", 'String'>
    readonly branch_id: FieldRef<"reviews", 'String'>
    readonly appointment_id: FieldRef<"reviews", 'String'>
    readonly rating: FieldRef<"reviews", 'Int'>
    readonly comment: FieldRef<"reviews", 'String'>
    readonly created_at: FieldRef<"reviews", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reviews findUnique
   */
  export type reviewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews findUniqueOrThrow
   */
  export type reviewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews findFirst
   */
  export type reviewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews findFirstOrThrow
   */
  export type reviewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reviews.
     */
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews findMany
   */
  export type reviewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter, which reviews to fetch.
     */
    where?: reviewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reviews to fetch.
     */
    orderBy?: reviewsOrderByWithRelationInput | reviewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reviews.
     */
    cursor?: reviewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reviews.
     */
    skip?: number
    distinct?: ReviewsScalarFieldEnum | ReviewsScalarFieldEnum[]
  }

  /**
   * reviews create
   */
  export type reviewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The data needed to create a reviews.
     */
    data: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
  }

  /**
   * reviews createMany
   */
  export type reviewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reviews.
     */
    data: reviewsCreateManyInput | reviewsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reviews createManyAndReturn
   */
  export type reviewsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The data used to create many reviews.
     */
    data: reviewsCreateManyInput | reviewsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviews update
   */
  export type reviewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The data needed to update a reviews.
     */
    data: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
    /**
     * Choose, which reviews to update.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews updateMany
   */
  export type reviewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
  }

  /**
   * reviews updateManyAndReturn
   */
  export type reviewsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * The data used to update reviews.
     */
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyInput>
    /**
     * Filter which reviews to update
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * reviews upsert
   */
  export type reviewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * The filter to search for the reviews to update in case it exists.
     */
    where: reviewsWhereUniqueInput
    /**
     * In case the reviews found by the `where` argument doesn't exist, create a new reviews with this data.
     */
    create: XOR<reviewsCreateInput, reviewsUncheckedCreateInput>
    /**
     * In case the reviews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reviewsUpdateInput, reviewsUncheckedUpdateInput>
  }

  /**
   * reviews delete
   */
  export type reviewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
    /**
     * Filter which reviews to delete.
     */
    where: reviewsWhereUniqueInput
  }

  /**
   * reviews deleteMany
   */
  export type reviewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reviews to delete
     */
    where?: reviewsWhereInput
    /**
     * Limit how many reviews to delete.
     */
    limit?: number
  }

  /**
   * reviews.appointments
   */
  export type reviews$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the appointments
     */
    select?: appointmentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the appointments
     */
    omit?: appointmentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: appointmentsInclude<ExtArgs> | null
    where?: appointmentsWhereInput
  }

  /**
   * reviews.provider_branches
   */
  export type reviews$provider_branchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the provider_branches
     */
    select?: provider_branchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the provider_branches
     */
    omit?: provider_branchesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: provider_branchesInclude<ExtArgs> | null
    where?: provider_branchesWhereInput
  }

  /**
   * reviews.patients
   */
  export type reviews$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    where?: patientsWhereInput
  }

  /**
   * reviews without action
   */
  export type reviewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reviews
     */
    select?: reviewsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reviews
     */
    omit?: reviewsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: reviewsInclude<ExtArgs> | null
  }


  /**
   * Model service_categories
   */

  export type AggregateService_categories = {
    _count: Service_categoriesCountAggregateOutputType | null
    _avg: Service_categoriesAvgAggregateOutputType | null
    _sum: Service_categoriesSumAggregateOutputType | null
    _min: Service_categoriesMinAggregateOutputType | null
    _max: Service_categoriesMaxAggregateOutputType | null
  }

  export type Service_categoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type Service_categoriesSumAggregateOutputType = {
    id: number | null
  }

  export type Service_categoriesMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    default_color_hex: string | null
    allows_booking: boolean | null
  }

  export type Service_categoriesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    default_color_hex: string | null
    allows_booking: boolean | null
  }

  export type Service_categoriesCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    default_color_hex: number
    allows_booking: number
    _all: number
  }


  export type Service_categoriesAvgAggregateInputType = {
    id?: true
  }

  export type Service_categoriesSumAggregateInputType = {
    id?: true
  }

  export type Service_categoriesMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    default_color_hex?: true
    allows_booking?: true
  }

  export type Service_categoriesMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    default_color_hex?: true
    allows_booking?: true
  }

  export type Service_categoriesCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    default_color_hex?: true
    allows_booking?: true
    _all?: true
  }

  export type Service_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_categories to aggregate.
     */
    where?: service_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_categories to fetch.
     */
    orderBy?: service_categoriesOrderByWithRelationInput | service_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: service_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned service_categories
    **/
    _count?: true | Service_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Service_categoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Service_categoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Service_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Service_categoriesMaxAggregateInputType
  }

  export type GetService_categoriesAggregateType<T extends Service_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateService_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService_categories[P]>
      : GetScalarType<T[P], AggregateService_categories[P]>
  }




  export type service_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: service_categoriesWhereInput
    orderBy?: service_categoriesOrderByWithAggregationInput | service_categoriesOrderByWithAggregationInput[]
    by: Service_categoriesScalarFieldEnum[] | Service_categoriesScalarFieldEnum
    having?: service_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Service_categoriesCountAggregateInputType | true
    _avg?: Service_categoriesAvgAggregateInputType
    _sum?: Service_categoriesSumAggregateInputType
    _min?: Service_categoriesMinAggregateInputType
    _max?: Service_categoriesMaxAggregateInputType
  }

  export type Service_categoriesGroupByOutputType = {
    id: number
    name: string
    slug: string
    default_color_hex: string | null
    allows_booking: boolean | null
    _count: Service_categoriesCountAggregateOutputType | null
    _avg: Service_categoriesAvgAggregateOutputType | null
    _sum: Service_categoriesSumAggregateOutputType | null
    _min: Service_categoriesMinAggregateOutputType | null
    _max: Service_categoriesMaxAggregateOutputType | null
  }

  type GetService_categoriesGroupByPayload<T extends service_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Service_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Service_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Service_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Service_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type service_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    default_color_hex?: boolean
    allows_booking?: boolean
    providers?: boolean | service_categories$providersArgs<ExtArgs>
    _count?: boolean | Service_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service_categories"]>

  export type service_categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    default_color_hex?: boolean
    allows_booking?: boolean
  }, ExtArgs["result"]["service_categories"]>

  export type service_categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    default_color_hex?: boolean
    allows_booking?: boolean
  }, ExtArgs["result"]["service_categories"]>

  export type service_categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    default_color_hex?: boolean
    allows_booking?: boolean
  }

  export type service_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "default_color_hex" | "allows_booking", ExtArgs["result"]["service_categories"]>
  export type service_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providers?: boolean | service_categories$providersArgs<ExtArgs>
    _count?: boolean | Service_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type service_categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type service_categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $service_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "service_categories"
    objects: {
      providers: Prisma.$providersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      default_color_hex: string | null
      allows_booking: boolean | null
    }, ExtArgs["result"]["service_categories"]>
    composites: {}
  }

  type service_categoriesGetPayload<S extends boolean | null | undefined | service_categoriesDefaultArgs> = $Result.GetResult<Prisma.$service_categoriesPayload, S>

  type service_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<service_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Service_categoriesCountAggregateInputType | true
    }

  export interface service_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['service_categories'], meta: { name: 'service_categories' } }
    /**
     * Find zero or one Service_categories that matches the filter.
     * @param {service_categoriesFindUniqueArgs} args - Arguments to find a Service_categories
     * @example
     * // Get one Service_categories
     * const service_categories = await prisma.service_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends service_categoriesFindUniqueArgs>(args: SelectSubset<T, service_categoriesFindUniqueArgs<ExtArgs>>): Prisma__service_categoriesClient<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {service_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Service_categories
     * @example
     * // Get one Service_categories
     * const service_categories = await prisma.service_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends service_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, service_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__service_categoriesClient<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoriesFindFirstArgs} args - Arguments to find a Service_categories
     * @example
     * // Get one Service_categories
     * const service_categories = await prisma.service_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends service_categoriesFindFirstArgs>(args?: SelectSubset<T, service_categoriesFindFirstArgs<ExtArgs>>): Prisma__service_categoriesClient<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoriesFindFirstOrThrowArgs} args - Arguments to find a Service_categories
     * @example
     * // Get one Service_categories
     * const service_categories = await prisma.service_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends service_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, service_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__service_categoriesClient<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Service_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Service_categories
     * const service_categories = await prisma.service_categories.findMany()
     * 
     * // Get first 10 Service_categories
     * const service_categories = await prisma.service_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const service_categoriesWithIdOnly = await prisma.service_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends service_categoriesFindManyArgs>(args?: SelectSubset<T, service_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service_categories.
     * @param {service_categoriesCreateArgs} args - Arguments to create a Service_categories.
     * @example
     * // Create one Service_categories
     * const Service_categories = await prisma.service_categories.create({
     *   data: {
     *     // ... data to create a Service_categories
     *   }
     * })
     * 
     */
    create<T extends service_categoriesCreateArgs>(args: SelectSubset<T, service_categoriesCreateArgs<ExtArgs>>): Prisma__service_categoriesClient<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Service_categories.
     * @param {service_categoriesCreateManyArgs} args - Arguments to create many Service_categories.
     * @example
     * // Create many Service_categories
     * const service_categories = await prisma.service_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends service_categoriesCreateManyArgs>(args?: SelectSubset<T, service_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Service_categories and returns the data saved in the database.
     * @param {service_categoriesCreateManyAndReturnArgs} args - Arguments to create many Service_categories.
     * @example
     * // Create many Service_categories
     * const service_categories = await prisma.service_categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Service_categories and only return the `id`
     * const service_categoriesWithIdOnly = await prisma.service_categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends service_categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, service_categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service_categories.
     * @param {service_categoriesDeleteArgs} args - Arguments to delete one Service_categories.
     * @example
     * // Delete one Service_categories
     * const Service_categories = await prisma.service_categories.delete({
     *   where: {
     *     // ... filter to delete one Service_categories
     *   }
     * })
     * 
     */
    delete<T extends service_categoriesDeleteArgs>(args: SelectSubset<T, service_categoriesDeleteArgs<ExtArgs>>): Prisma__service_categoriesClient<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service_categories.
     * @param {service_categoriesUpdateArgs} args - Arguments to update one Service_categories.
     * @example
     * // Update one Service_categories
     * const service_categories = await prisma.service_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends service_categoriesUpdateArgs>(args: SelectSubset<T, service_categoriesUpdateArgs<ExtArgs>>): Prisma__service_categoriesClient<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Service_categories.
     * @param {service_categoriesDeleteManyArgs} args - Arguments to filter Service_categories to delete.
     * @example
     * // Delete a few Service_categories
     * const { count } = await prisma.service_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends service_categoriesDeleteManyArgs>(args?: SelectSubset<T, service_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Service_categories
     * const service_categories = await prisma.service_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends service_categoriesUpdateManyArgs>(args: SelectSubset<T, service_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Service_categories and returns the data updated in the database.
     * @param {service_categoriesUpdateManyAndReturnArgs} args - Arguments to update many Service_categories.
     * @example
     * // Update many Service_categories
     * const service_categories = await prisma.service_categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Service_categories and only return the `id`
     * const service_categoriesWithIdOnly = await prisma.service_categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends service_categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, service_categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service_categories.
     * @param {service_categoriesUpsertArgs} args - Arguments to update or create a Service_categories.
     * @example
     * // Update or create a Service_categories
     * const service_categories = await prisma.service_categories.upsert({
     *   create: {
     *     // ... data to create a Service_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service_categories we want to update
     *   }
     * })
     */
    upsert<T extends service_categoriesUpsertArgs>(args: SelectSubset<T, service_categoriesUpsertArgs<ExtArgs>>): Prisma__service_categoriesClient<$Result.GetResult<Prisma.$service_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Service_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoriesCountArgs} args - Arguments to filter Service_categories to count.
     * @example
     * // Count the number of Service_categories
     * const count = await prisma.service_categories.count({
     *   where: {
     *     // ... the filter for the Service_categories we want to count
     *   }
     * })
    **/
    count<T extends service_categoriesCountArgs>(
      args?: Subset<T, service_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Service_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Service_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Service_categoriesAggregateArgs>(args: Subset<T, Service_categoriesAggregateArgs>): Prisma.PrismaPromise<GetService_categoriesAggregateType<T>>

    /**
     * Group by Service_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {service_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends service_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: service_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: service_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, service_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetService_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the service_categories model
   */
  readonly fields: service_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for service_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__service_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    providers<T extends service_categories$providersArgs<ExtArgs> = {}>(args?: Subset<T, service_categories$providersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the service_categories model
   */
  interface service_categoriesFieldRefs {
    readonly id: FieldRef<"service_categories", 'Int'>
    readonly name: FieldRef<"service_categories", 'String'>
    readonly slug: FieldRef<"service_categories", 'String'>
    readonly default_color_hex: FieldRef<"service_categories", 'String'>
    readonly allows_booking: FieldRef<"service_categories", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * service_categories findUnique
   */
  export type service_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which service_categories to fetch.
     */
    where: service_categoriesWhereUniqueInput
  }

  /**
   * service_categories findUniqueOrThrow
   */
  export type service_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which service_categories to fetch.
     */
    where: service_categoriesWhereUniqueInput
  }

  /**
   * service_categories findFirst
   */
  export type service_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which service_categories to fetch.
     */
    where?: service_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_categories to fetch.
     */
    orderBy?: service_categoriesOrderByWithRelationInput | service_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_categories.
     */
    cursor?: service_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_categories.
     */
    distinct?: Service_categoriesScalarFieldEnum | Service_categoriesScalarFieldEnum[]
  }

  /**
   * service_categories findFirstOrThrow
   */
  export type service_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which service_categories to fetch.
     */
    where?: service_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_categories to fetch.
     */
    orderBy?: service_categoriesOrderByWithRelationInput | service_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for service_categories.
     */
    cursor?: service_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of service_categories.
     */
    distinct?: Service_categoriesScalarFieldEnum | Service_categoriesScalarFieldEnum[]
  }

  /**
   * service_categories findMany
   */
  export type service_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which service_categories to fetch.
     */
    where?: service_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of service_categories to fetch.
     */
    orderBy?: service_categoriesOrderByWithRelationInput | service_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing service_categories.
     */
    cursor?: service_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` service_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` service_categories.
     */
    skip?: number
    distinct?: Service_categoriesScalarFieldEnum | Service_categoriesScalarFieldEnum[]
  }

  /**
   * service_categories create
   */
  export type service_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a service_categories.
     */
    data: XOR<service_categoriesCreateInput, service_categoriesUncheckedCreateInput>
  }

  /**
   * service_categories createMany
   */
  export type service_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many service_categories.
     */
    data: service_categoriesCreateManyInput | service_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_categories createManyAndReturn
   */
  export type service_categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many service_categories.
     */
    data: service_categoriesCreateManyInput | service_categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * service_categories update
   */
  export type service_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a service_categories.
     */
    data: XOR<service_categoriesUpdateInput, service_categoriesUncheckedUpdateInput>
    /**
     * Choose, which service_categories to update.
     */
    where: service_categoriesWhereUniqueInput
  }

  /**
   * service_categories updateMany
   */
  export type service_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update service_categories.
     */
    data: XOR<service_categoriesUpdateManyMutationInput, service_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which service_categories to update
     */
    where?: service_categoriesWhereInput
    /**
     * Limit how many service_categories to update.
     */
    limit?: number
  }

  /**
   * service_categories updateManyAndReturn
   */
  export type service_categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * The data used to update service_categories.
     */
    data: XOR<service_categoriesUpdateManyMutationInput, service_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which service_categories to update
     */
    where?: service_categoriesWhereInput
    /**
     * Limit how many service_categories to update.
     */
    limit?: number
  }

  /**
   * service_categories upsert
   */
  export type service_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the service_categories to update in case it exists.
     */
    where: service_categoriesWhereUniqueInput
    /**
     * In case the service_categories found by the `where` argument doesn't exist, create a new service_categories with this data.
     */
    create: XOR<service_categoriesCreateInput, service_categoriesUncheckedCreateInput>
    /**
     * In case the service_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<service_categoriesUpdateInput, service_categoriesUncheckedUpdateInput>
  }

  /**
   * service_categories delete
   */
  export type service_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
    /**
     * Filter which service_categories to delete.
     */
    where: service_categoriesWhereUniqueInput
  }

  /**
   * service_categories deleteMany
   */
  export type service_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which service_categories to delete
     */
    where?: service_categoriesWhereInput
    /**
     * Limit how many service_categories to delete.
     */
    limit?: number
  }

  /**
   * service_categories.providers
   */
  export type service_categories$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    cursor?: providersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * service_categories without action
   */
  export type service_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the service_categories
     */
    select?: service_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the service_categories
     */
    omit?: service_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: service_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    token: string | null
    device_info: string | null
    expires_at: Date | null
    created_at: Date | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    token: string | null
    device_info: string | null
    expires_at: Date | null
    created_at: Date | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    user_id: number
    token: number
    device_info: number
    expires_at: number
    created_at: number
    _all: number
  }


  export type SessionsMinAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    device_info?: true
    expires_at?: true
    created_at?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    device_info?: true
    expires_at?: true
    created_at?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    user_id?: true
    token?: true
    device_info?: true
    expires_at?: true
    created_at?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: string
    user_id: string | null
    token: string
    device_info: string | null
    expires_at: Date
    created_at: Date | null
    _count: SessionsCountAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    device_info?: boolean
    expires_at?: boolean
    created_at?: boolean
    users?: boolean | sessions$usersArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    device_info?: boolean
    expires_at?: boolean
    created_at?: boolean
    users?: boolean | sessions$usersArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    token?: boolean
    device_info?: boolean
    expires_at?: boolean
    created_at?: boolean
    users?: boolean | sessions$usersArgs<ExtArgs>
  }, ExtArgs["result"]["sessions"]>

  export type sessionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    token?: boolean
    device_info?: boolean
    expires_at?: boolean
    created_at?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "token" | "device_info" | "expires_at" | "created_at", ExtArgs["result"]["sessions"]>
  export type sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | sessions$usersArgs<ExtArgs>
  }
  export type sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | sessions$usersArgs<ExtArgs>
  }
  export type sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | sessions$usersArgs<ExtArgs>
  }

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string | null
      token: string
      device_info: string | null
      expires_at: Date
      created_at: Date | null
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {sessionsCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionsWithIdOnly = await prisma.sessions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {sessionsUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionsWithIdOnly = await prisma.sessions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends sessions$usersArgs<ExtArgs> = {}>(args?: Subset<T, sessions$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'String'>
    readonly user_id: FieldRef<"sessions", 'String'>
    readonly token: FieldRef<"sessions", 'String'>
    readonly device_info: FieldRef<"sessions", 'String'>
    readonly expires_at: FieldRef<"sessions", 'DateTime'>
    readonly created_at: FieldRef<"sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions createManyAndReturn
   */
  export type sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions updateManyAndReturn
   */
  export type sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions.users
   */
  export type sessions$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    role: $Enums.enum_roles | null
    profile_picture_url: string | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password_hash: string | null
    role: $Enums.enum_roles | null
    profile_picture_url: string | null
    is_active: boolean | null
    created_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    password_hash: number
    role: number
    profile_picture_url: number
    is_active: number
    created_at: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    profile_picture_url?: true
    is_active?: true
    created_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    profile_picture_url?: true
    is_active?: true
    created_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    password_hash?: true
    role?: true
    profile_picture_url?: true
    is_active?: true
    created_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    password_hash: string
    role: $Enums.enum_roles | null
    profile_picture_url: string | null
    is_active: boolean | null
    created_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    profile_picture_url?: boolean
    is_active?: boolean
    created_at?: boolean
    patients?: boolean | users$patientsArgs<ExtArgs>
    providers?: boolean | users$providersArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    profile_picture_url?: boolean
    is_active?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    profile_picture_url?: boolean
    is_active?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    password_hash?: boolean
    role?: boolean
    profile_picture_url?: boolean
    is_active?: boolean
    created_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password_hash" | "role" | "profile_picture_url" | "is_active" | "created_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patients?: boolean | users$patientsArgs<ExtArgs>
    providers?: boolean | users$providersArgs<ExtArgs>
    sessions?: boolean | users$sessionsArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      patients: Prisma.$patientsPayload<ExtArgs>[]
      providers: Prisma.$providersPayload<ExtArgs>[]
      sessions: Prisma.$sessionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password_hash: string
      role: $Enums.enum_roles | null
      profile_picture_url: string | null
      is_active: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patients<T extends users$patientsArgs<ExtArgs> = {}>(args?: Subset<T, users$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$patientsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    providers<T extends users$providersArgs<ExtArgs> = {}>(args?: Subset<T, users$providersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends users$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, users$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password_hash: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'enum_roles'>
    readonly profile_picture_url: FieldRef<"users", 'String'>
    readonly is_active: FieldRef<"users", 'Boolean'>
    readonly created_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.patients
   */
  export type users$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the patients
     */
    select?: patientsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the patients
     */
    omit?: patientsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: patientsInclude<ExtArgs> | null
    where?: patientsWhereInput
    orderBy?: patientsOrderByWithRelationInput | patientsOrderByWithRelationInput[]
    cursor?: patientsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientsScalarFieldEnum | PatientsScalarFieldEnum[]
  }

  /**
   * users.providers
   */
  export type users$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    cursor?: providersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * users.sessions
   */
  export type users$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: sessionsInclude<ExtArgs> | null
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    cursor?: sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AppointmentsScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    branch_id: 'branch_id',
    provider_id: 'provider_id',
    scheduled_for: 'scheduled_for',
    status: 'status',
    reason: 'reason',
    is_paid: 'is_paid'
  };

  export type AppointmentsScalarFieldEnum = (typeof AppointmentsScalarFieldEnum)[keyof typeof AppointmentsScalarFieldEnum]


  export const CitiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    state: 'state',
    country: 'country'
  };

  export type CitiesScalarFieldEnum = (typeof CitiesScalarFieldEnum)[keyof typeof CitiesScalarFieldEnum]


  export const Medical_historyScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    provider_id: 'provider_id',
    doctor_name_snapshot: 'doctor_name_snapshot',
    specialty_snapshot: 'specialty_snapshot',
    diagnosis: 'diagnosis',
    date: 'date',
    treatment: 'treatment',
    indications: 'indications',
    observations: 'observations',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Medical_historyScalarFieldEnum = (typeof Medical_historyScalarFieldEnum)[keyof typeof Medical_historyScalarFieldEnum]


  export const NotificationsScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    type: 'type',
    title: 'title',
    body: 'body',
    is_read: 'is_read',
    data: 'data',
    created_at: 'created_at'
  };

  export type NotificationsScalarFieldEnum = (typeof NotificationsScalarFieldEnum)[keyof typeof NotificationsScalarFieldEnum]


  export const Patient_favoritesScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    branch_id: 'branch_id',
    created_at: 'created_at'
  };

  export type Patient_favoritesScalarFieldEnum = (typeof Patient_favoritesScalarFieldEnum)[keyof typeof Patient_favoritesScalarFieldEnum]


  export const PatientsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    full_name: 'full_name',
    identification: 'identification',
    phone: 'phone',
    birth_date: 'birth_date',
    address_text: 'address_text'
  };

  export type PatientsScalarFieldEnum = (typeof PatientsScalarFieldEnum)[keyof typeof PatientsScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    appointment_id: 'appointment_id',
    payout_id: 'payout_id',
    stripe_payment_intent_id: 'stripe_payment_intent_id',
    amount_total: 'amount_total',
    platform_fee: 'platform_fee',
    provider_amount: 'provider_amount',
    status: 'status',
    created_at: 'created_at'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const PayoutsScalarFieldEnum: {
    id: 'id',
    provider_id: 'provider_id',
    total_amount: 'total_amount',
    currency: 'currency',
    status: 'status',
    reference_number: 'reference_number',
    period_start: 'period_start',
    period_end: 'period_end',
    created_at: 'created_at'
  };

  export type PayoutsScalarFieldEnum = (typeof PayoutsScalarFieldEnum)[keyof typeof PayoutsScalarFieldEnum]


  export const Provider_adsScalarFieldEnum: {
    id: 'id',
    provider_id: 'provider_id',
    badge_text: 'badge_text',
    title: 'title',
    subtitle: 'subtitle',
    image_url: 'image_url',
    action_text: 'action_text',
    bg_color_hex: 'bg_color_hex',
    accent_color_hex: 'accent_color_hex',
    target_screen: 'target_screen',
    target_id: 'target_id',
    start_date: 'start_date',
    end_date: 'end_date',
    is_active: 'is_active',
    priority_order: 'priority_order'
  };

  export type Provider_adsScalarFieldEnum = (typeof Provider_adsScalarFieldEnum)[keyof typeof Provider_adsScalarFieldEnum]


  export const Provider_bank_detailsScalarFieldEnum: {
    id: 'id',
    provider_id: 'provider_id',
    bank_name: 'bank_name',
    account_number: 'account_number',
    account_type: 'account_type',
    account_holder_name: 'account_holder_name',
    holder_identification: 'holder_identification',
    is_verified: 'is_verified',
    updated_at: 'updated_at'
  };

  export type Provider_bank_detailsScalarFieldEnum = (typeof Provider_bank_detailsScalarFieldEnum)[keyof typeof Provider_bank_detailsScalarFieldEnum]


  export const Provider_branchesScalarFieldEnum: {
    id: 'id',
    provider_id: 'provider_id',
    city_id: 'city_id',
    name: 'name',
    description: 'description',
    address_text: 'address_text',
    latitude: 'latitude',
    longitude: 'longitude',
    phone_contact: 'phone_contact',
    email_contact: 'email_contact',
    image_url: 'image_url',
    opening_hours_text: 'opening_hours_text',
    is_24h: 'is_24h',
    has_delivery: 'has_delivery',
    rating_cache: 'rating_cache',
    is_main: 'is_main',
    is_active: 'is_active'
  };

  export type Provider_branchesScalarFieldEnum = (typeof Provider_branchesScalarFieldEnum)[keyof typeof Provider_branchesScalarFieldEnum]


  export const Provider_catalogScalarFieldEnum: {
    id: 'id',
    provider_id: 'provider_id',
    type: 'type',
    name: 'name',
    description: 'description',
    price: 'price',
    is_available: 'is_available',
    image_url: 'image_url'
  };

  export type Provider_catalogScalarFieldEnum = (typeof Provider_catalogScalarFieldEnum)[keyof typeof Provider_catalogScalarFieldEnum]


  export const Provider_schedulesScalarFieldEnum: {
    id: 'id',
    branch_id: 'branch_id',
    day_of_week: 'day_of_week',
    start_time: 'start_time',
    end_time: 'end_time'
  };

  export type Provider_schedulesScalarFieldEnum = (typeof Provider_schedulesScalarFieldEnum)[keyof typeof Provider_schedulesScalarFieldEnum]


  export const ProvidersScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    category_id: 'category_id',
    commercial_name: 'commercial_name',
    logo_url: 'logo_url',
    description: 'description',
    verification_status: 'verification_status',
    commission_percentage: 'commission_percentage'
  };

  export type ProvidersScalarFieldEnum = (typeof ProvidersScalarFieldEnum)[keyof typeof ProvidersScalarFieldEnum]


  export const ReviewsScalarFieldEnum: {
    id: 'id',
    patient_id: 'patient_id',
    branch_id: 'branch_id',
    appointment_id: 'appointment_id',
    rating: 'rating',
    comment: 'comment',
    created_at: 'created_at'
  };

  export type ReviewsScalarFieldEnum = (typeof ReviewsScalarFieldEnum)[keyof typeof ReviewsScalarFieldEnum]


  export const Service_categoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    default_color_hex: 'default_color_hex',
    allows_booking: 'allows_booking'
  };

  export type Service_categoriesScalarFieldEnum = (typeof Service_categoriesScalarFieldEnum)[keyof typeof Service_categoriesScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    token: 'token',
    device_info: 'device_info',
    expires_at: 'expires_at',
    created_at: 'created_at'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password_hash: 'password_hash',
    role: 'role',
    profile_picture_url: 'profile_picture_url',
    is_active: 'is_active',
    created_at: 'created_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'enum_notif_types'
   */
  export type Enumenum_notif_typesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_notif_types'>
    


  /**
   * Reference to a field of type 'enum_notif_types[]'
   */
  export type ListEnumenum_notif_typesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_notif_types[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'enum_roles'
   */
  export type Enumenum_rolesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_roles'>
    


  /**
   * Reference to a field of type 'enum_roles[]'
   */
  export type ListEnumenum_rolesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'enum_roles[]'>
    
  /**
   * Deep Input Types
   */


  export type appointmentsWhereInput = {
    AND?: appointmentsWhereInput | appointmentsWhereInput[]
    OR?: appointmentsWhereInput[]
    NOT?: appointmentsWhereInput | appointmentsWhereInput[]
    id?: UuidFilter<"appointments"> | string
    patient_id?: UuidNullableFilter<"appointments"> | string | null
    branch_id?: UuidNullableFilter<"appointments"> | string | null
    provider_id?: UuidNullableFilter<"appointments"> | string | null
    scheduled_for?: DateTimeNullableFilter<"appointments"> | Date | string | null
    status?: StringNullableFilter<"appointments"> | string | null
    reason?: StringNullableFilter<"appointments"> | string | null
    is_paid?: BoolNullableFilter<"appointments"> | boolean | null
    provider_branches?: XOR<Provider_branchesNullableScalarRelationFilter, provider_branchesWhereInput> | null
    patients?: XOR<PatientsNullableScalarRelationFilter, patientsWhereInput> | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
    payments?: PaymentsListRelationFilter
    reviews?: ReviewsListRelationFilter
  }

  export type appointmentsOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    provider_id?: SortOrderInput | SortOrder
    scheduled_for?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    is_paid?: SortOrderInput | SortOrder
    provider_branches?: provider_branchesOrderByWithRelationInput
    patients?: patientsOrderByWithRelationInput
    providers?: providersOrderByWithRelationInput
    payments?: paymentsOrderByRelationAggregateInput
    reviews?: reviewsOrderByRelationAggregateInput
  }

  export type appointmentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: appointmentsWhereInput | appointmentsWhereInput[]
    OR?: appointmentsWhereInput[]
    NOT?: appointmentsWhereInput | appointmentsWhereInput[]
    patient_id?: UuidNullableFilter<"appointments"> | string | null
    branch_id?: UuidNullableFilter<"appointments"> | string | null
    provider_id?: UuidNullableFilter<"appointments"> | string | null
    scheduled_for?: DateTimeNullableFilter<"appointments"> | Date | string | null
    status?: StringNullableFilter<"appointments"> | string | null
    reason?: StringNullableFilter<"appointments"> | string | null
    is_paid?: BoolNullableFilter<"appointments"> | boolean | null
    provider_branches?: XOR<Provider_branchesNullableScalarRelationFilter, provider_branchesWhereInput> | null
    patients?: XOR<PatientsNullableScalarRelationFilter, patientsWhereInput> | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
    payments?: PaymentsListRelationFilter
    reviews?: ReviewsListRelationFilter
  }, "id">

  export type appointmentsOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    provider_id?: SortOrderInput | SortOrder
    scheduled_for?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    is_paid?: SortOrderInput | SortOrder
    _count?: appointmentsCountOrderByAggregateInput
    _max?: appointmentsMaxOrderByAggregateInput
    _min?: appointmentsMinOrderByAggregateInput
  }

  export type appointmentsScalarWhereWithAggregatesInput = {
    AND?: appointmentsScalarWhereWithAggregatesInput | appointmentsScalarWhereWithAggregatesInput[]
    OR?: appointmentsScalarWhereWithAggregatesInput[]
    NOT?: appointmentsScalarWhereWithAggregatesInput | appointmentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"appointments"> | string
    patient_id?: UuidNullableWithAggregatesFilter<"appointments"> | string | null
    branch_id?: UuidNullableWithAggregatesFilter<"appointments"> | string | null
    provider_id?: UuidNullableWithAggregatesFilter<"appointments"> | string | null
    scheduled_for?: DateTimeNullableWithAggregatesFilter<"appointments"> | Date | string | null
    status?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    reason?: StringNullableWithAggregatesFilter<"appointments"> | string | null
    is_paid?: BoolNullableWithAggregatesFilter<"appointments"> | boolean | null
  }

  export type citiesWhereInput = {
    AND?: citiesWhereInput | citiesWhereInput[]
    OR?: citiesWhereInput[]
    NOT?: citiesWhereInput | citiesWhereInput[]
    id?: UuidFilter<"cities"> | string
    name?: StringFilter<"cities"> | string
    state?: StringNullableFilter<"cities"> | string | null
    country?: StringNullableFilter<"cities"> | string | null
    provider_branches?: Provider_branchesListRelationFilter
  }

  export type citiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    provider_branches?: provider_branchesOrderByRelationAggregateInput
  }

  export type citiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: citiesWhereInput | citiesWhereInput[]
    OR?: citiesWhereInput[]
    NOT?: citiesWhereInput | citiesWhereInput[]
    name?: StringFilter<"cities"> | string
    state?: StringNullableFilter<"cities"> | string | null
    country?: StringNullableFilter<"cities"> | string | null
    provider_branches?: Provider_branchesListRelationFilter
  }, "id">

  export type citiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    _count?: citiesCountOrderByAggregateInput
    _max?: citiesMaxOrderByAggregateInput
    _min?: citiesMinOrderByAggregateInput
  }

  export type citiesScalarWhereWithAggregatesInput = {
    AND?: citiesScalarWhereWithAggregatesInput | citiesScalarWhereWithAggregatesInput[]
    OR?: citiesScalarWhereWithAggregatesInput[]
    NOT?: citiesScalarWhereWithAggregatesInput | citiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"cities"> | string
    name?: StringWithAggregatesFilter<"cities"> | string
    state?: StringNullableWithAggregatesFilter<"cities"> | string | null
    country?: StringNullableWithAggregatesFilter<"cities"> | string | null
  }

  export type medical_historyWhereInput = {
    AND?: medical_historyWhereInput | medical_historyWhereInput[]
    OR?: medical_historyWhereInput[]
    NOT?: medical_historyWhereInput | medical_historyWhereInput[]
    id?: UuidFilter<"medical_history"> | string
    patient_id?: UuidNullableFilter<"medical_history"> | string | null
    provider_id?: UuidNullableFilter<"medical_history"> | string | null
    doctor_name_snapshot?: StringNullableFilter<"medical_history"> | string | null
    specialty_snapshot?: StringNullableFilter<"medical_history"> | string | null
    diagnosis?: StringNullableFilter<"medical_history"> | string | null
    date?: DateTimeNullableFilter<"medical_history"> | Date | string | null
    treatment?: StringNullableFilter<"medical_history"> | string | null
    indications?: StringNullableFilter<"medical_history"> | string | null
    observations?: StringNullableFilter<"medical_history"> | string | null
    created_at?: DateTimeNullableFilter<"medical_history"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"medical_history"> | Date | string | null
    patients?: XOR<PatientsNullableScalarRelationFilter, patientsWhereInput> | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
  }

  export type medical_historyOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrderInput | SortOrder
    provider_id?: SortOrderInput | SortOrder
    doctor_name_snapshot?: SortOrderInput | SortOrder
    specialty_snapshot?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    treatment?: SortOrderInput | SortOrder
    indications?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    patients?: patientsOrderByWithRelationInput
    providers?: providersOrderByWithRelationInput
  }

  export type medical_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: medical_historyWhereInput | medical_historyWhereInput[]
    OR?: medical_historyWhereInput[]
    NOT?: medical_historyWhereInput | medical_historyWhereInput[]
    patient_id?: UuidNullableFilter<"medical_history"> | string | null
    provider_id?: UuidNullableFilter<"medical_history"> | string | null
    doctor_name_snapshot?: StringNullableFilter<"medical_history"> | string | null
    specialty_snapshot?: StringNullableFilter<"medical_history"> | string | null
    diagnosis?: StringNullableFilter<"medical_history"> | string | null
    date?: DateTimeNullableFilter<"medical_history"> | Date | string | null
    treatment?: StringNullableFilter<"medical_history"> | string | null
    indications?: StringNullableFilter<"medical_history"> | string | null
    observations?: StringNullableFilter<"medical_history"> | string | null
    created_at?: DateTimeNullableFilter<"medical_history"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"medical_history"> | Date | string | null
    patients?: XOR<PatientsNullableScalarRelationFilter, patientsWhereInput> | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
  }, "id">

  export type medical_historyOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrderInput | SortOrder
    provider_id?: SortOrderInput | SortOrder
    doctor_name_snapshot?: SortOrderInput | SortOrder
    specialty_snapshot?: SortOrderInput | SortOrder
    diagnosis?: SortOrderInput | SortOrder
    date?: SortOrderInput | SortOrder
    treatment?: SortOrderInput | SortOrder
    indications?: SortOrderInput | SortOrder
    observations?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: medical_historyCountOrderByAggregateInput
    _max?: medical_historyMaxOrderByAggregateInput
    _min?: medical_historyMinOrderByAggregateInput
  }

  export type medical_historyScalarWhereWithAggregatesInput = {
    AND?: medical_historyScalarWhereWithAggregatesInput | medical_historyScalarWhereWithAggregatesInput[]
    OR?: medical_historyScalarWhereWithAggregatesInput[]
    NOT?: medical_historyScalarWhereWithAggregatesInput | medical_historyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"medical_history"> | string
    patient_id?: UuidNullableWithAggregatesFilter<"medical_history"> | string | null
    provider_id?: UuidNullableWithAggregatesFilter<"medical_history"> | string | null
    doctor_name_snapshot?: StringNullableWithAggregatesFilter<"medical_history"> | string | null
    specialty_snapshot?: StringNullableWithAggregatesFilter<"medical_history"> | string | null
    diagnosis?: StringNullableWithAggregatesFilter<"medical_history"> | string | null
    date?: DateTimeNullableWithAggregatesFilter<"medical_history"> | Date | string | null
    treatment?: StringNullableWithAggregatesFilter<"medical_history"> | string | null
    indications?: StringNullableWithAggregatesFilter<"medical_history"> | string | null
    observations?: StringNullableWithAggregatesFilter<"medical_history"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"medical_history"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"medical_history"> | Date | string | null
  }

  export type notificationsWhereInput = {
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    id?: UuidFilter<"notifications"> | string
    patient_id?: UuidFilter<"notifications"> | string
    type?: Enumenum_notif_typesFilter<"notifications"> | $Enums.enum_notif_types
    title?: StringFilter<"notifications"> | string
    body?: StringFilter<"notifications"> | string
    is_read?: BoolNullableFilter<"notifications"> | boolean | null
    data?: JsonNullableFilter<"notifications">
    created_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
  }

  export type notificationsOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    is_read?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    patients?: patientsOrderByWithRelationInput
  }

  export type notificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: notificationsWhereInput | notificationsWhereInput[]
    OR?: notificationsWhereInput[]
    NOT?: notificationsWhereInput | notificationsWhereInput[]
    patient_id?: UuidFilter<"notifications"> | string
    type?: Enumenum_notif_typesFilter<"notifications"> | $Enums.enum_notif_types
    title?: StringFilter<"notifications"> | string
    body?: StringFilter<"notifications"> | string
    is_read?: BoolNullableFilter<"notifications"> | boolean | null
    data?: JsonNullableFilter<"notifications">
    created_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
    patients?: XOR<PatientsScalarRelationFilter, patientsWhereInput>
  }, "id">

  export type notificationsOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    is_read?: SortOrderInput | SortOrder
    data?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: notificationsCountOrderByAggregateInput
    _max?: notificationsMaxOrderByAggregateInput
    _min?: notificationsMinOrderByAggregateInput
  }

  export type notificationsScalarWhereWithAggregatesInput = {
    AND?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    OR?: notificationsScalarWhereWithAggregatesInput[]
    NOT?: notificationsScalarWhereWithAggregatesInput | notificationsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"notifications"> | string
    patient_id?: UuidWithAggregatesFilter<"notifications"> | string
    type?: Enumenum_notif_typesWithAggregatesFilter<"notifications"> | $Enums.enum_notif_types
    title?: StringWithAggregatesFilter<"notifications"> | string
    body?: StringWithAggregatesFilter<"notifications"> | string
    is_read?: BoolNullableWithAggregatesFilter<"notifications"> | boolean | null
    data?: JsonNullableWithAggregatesFilter<"notifications">
    created_at?: DateTimeNullableWithAggregatesFilter<"notifications"> | Date | string | null
  }

  export type patient_favoritesWhereInput = {
    AND?: patient_favoritesWhereInput | patient_favoritesWhereInput[]
    OR?: patient_favoritesWhereInput[]
    NOT?: patient_favoritesWhereInput | patient_favoritesWhereInput[]
    id?: UuidFilter<"patient_favorites"> | string
    patient_id?: UuidNullableFilter<"patient_favorites"> | string | null
    branch_id?: UuidNullableFilter<"patient_favorites"> | string | null
    created_at?: DateTimeNullableFilter<"patient_favorites"> | Date | string | null
    provider_branches?: XOR<Provider_branchesNullableScalarRelationFilter, provider_branchesWhereInput> | null
    patients?: XOR<PatientsNullableScalarRelationFilter, patientsWhereInput> | null
  }

  export type patient_favoritesOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    provider_branches?: provider_branchesOrderByWithRelationInput
    patients?: patientsOrderByWithRelationInput
  }

  export type patient_favoritesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: patient_favoritesWhereInput | patient_favoritesWhereInput[]
    OR?: patient_favoritesWhereInput[]
    NOT?: patient_favoritesWhereInput | patient_favoritesWhereInput[]
    patient_id?: UuidNullableFilter<"patient_favorites"> | string | null
    branch_id?: UuidNullableFilter<"patient_favorites"> | string | null
    created_at?: DateTimeNullableFilter<"patient_favorites"> | Date | string | null
    provider_branches?: XOR<Provider_branchesNullableScalarRelationFilter, provider_branchesWhereInput> | null
    patients?: XOR<PatientsNullableScalarRelationFilter, patientsWhereInput> | null
  }, "id">

  export type patient_favoritesOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: patient_favoritesCountOrderByAggregateInput
    _max?: patient_favoritesMaxOrderByAggregateInput
    _min?: patient_favoritesMinOrderByAggregateInput
  }

  export type patient_favoritesScalarWhereWithAggregatesInput = {
    AND?: patient_favoritesScalarWhereWithAggregatesInput | patient_favoritesScalarWhereWithAggregatesInput[]
    OR?: patient_favoritesScalarWhereWithAggregatesInput[]
    NOT?: patient_favoritesScalarWhereWithAggregatesInput | patient_favoritesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"patient_favorites"> | string
    patient_id?: UuidNullableWithAggregatesFilter<"patient_favorites"> | string | null
    branch_id?: UuidNullableWithAggregatesFilter<"patient_favorites"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"patient_favorites"> | Date | string | null
  }

  export type patientsWhereInput = {
    AND?: patientsWhereInput | patientsWhereInput[]
    OR?: patientsWhereInput[]
    NOT?: patientsWhereInput | patientsWhereInput[]
    id?: UuidFilter<"patients"> | string
    user_id?: UuidNullableFilter<"patients"> | string | null
    full_name?: StringFilter<"patients"> | string
    identification?: StringNullableFilter<"patients"> | string | null
    phone?: StringNullableFilter<"patients"> | string | null
    birth_date?: DateTimeNullableFilter<"patients"> | Date | string | null
    address_text?: StringNullableFilter<"patients"> | string | null
    appointments?: AppointmentsListRelationFilter
    medical_history?: Medical_historyListRelationFilter
    notifications?: NotificationsListRelationFilter
    patient_favorites?: Patient_favoritesListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    reviews?: ReviewsListRelationFilter
  }

  export type patientsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    full_name?: SortOrder
    identification?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    address_text?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByRelationAggregateInput
    medical_history?: medical_historyOrderByRelationAggregateInput
    notifications?: notificationsOrderByRelationAggregateInput
    patient_favorites?: patient_favoritesOrderByRelationAggregateInput
    users?: usersOrderByWithRelationInput
    reviews?: reviewsOrderByRelationAggregateInput
  }

  export type patientsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: patientsWhereInput | patientsWhereInput[]
    OR?: patientsWhereInput[]
    NOT?: patientsWhereInput | patientsWhereInput[]
    user_id?: UuidNullableFilter<"patients"> | string | null
    full_name?: StringFilter<"patients"> | string
    identification?: StringNullableFilter<"patients"> | string | null
    phone?: StringNullableFilter<"patients"> | string | null
    birth_date?: DateTimeNullableFilter<"patients"> | Date | string | null
    address_text?: StringNullableFilter<"patients"> | string | null
    appointments?: AppointmentsListRelationFilter
    medical_history?: Medical_historyListRelationFilter
    notifications?: NotificationsListRelationFilter
    patient_favorites?: Patient_favoritesListRelationFilter
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
    reviews?: ReviewsListRelationFilter
  }, "id">

  export type patientsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    full_name?: SortOrder
    identification?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birth_date?: SortOrderInput | SortOrder
    address_text?: SortOrderInput | SortOrder
    _count?: patientsCountOrderByAggregateInput
    _max?: patientsMaxOrderByAggregateInput
    _min?: patientsMinOrderByAggregateInput
  }

  export type patientsScalarWhereWithAggregatesInput = {
    AND?: patientsScalarWhereWithAggregatesInput | patientsScalarWhereWithAggregatesInput[]
    OR?: patientsScalarWhereWithAggregatesInput[]
    NOT?: patientsScalarWhereWithAggregatesInput | patientsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"patients"> | string
    user_id?: UuidNullableWithAggregatesFilter<"patients"> | string | null
    full_name?: StringWithAggregatesFilter<"patients"> | string
    identification?: StringNullableWithAggregatesFilter<"patients"> | string | null
    phone?: StringNullableWithAggregatesFilter<"patients"> | string | null
    birth_date?: DateTimeNullableWithAggregatesFilter<"patients"> | Date | string | null
    address_text?: StringNullableWithAggregatesFilter<"patients"> | string | null
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: UuidFilter<"payments"> | string
    appointment_id?: UuidNullableFilter<"payments"> | string | null
    payout_id?: UuidNullableFilter<"payments"> | string | null
    stripe_payment_intent_id?: StringNullableFilter<"payments"> | string | null
    amount_total?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    platform_fee?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    provider_amount?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    appointments?: XOR<AppointmentsNullableScalarRelationFilter, appointmentsWhereInput> | null
    payouts?: XOR<PayoutsNullableScalarRelationFilter, payoutsWhereInput> | null
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    appointment_id?: SortOrderInput | SortOrder
    payout_id?: SortOrderInput | SortOrder
    stripe_payment_intent_id?: SortOrderInput | SortOrder
    amount_total?: SortOrderInput | SortOrder
    platform_fee?: SortOrderInput | SortOrder
    provider_amount?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByWithRelationInput
    payouts?: payoutsOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    appointment_id?: UuidNullableFilter<"payments"> | string | null
    payout_id?: UuidNullableFilter<"payments"> | string | null
    stripe_payment_intent_id?: StringNullableFilter<"payments"> | string | null
    amount_total?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    platform_fee?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    provider_amount?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    appointments?: XOR<AppointmentsNullableScalarRelationFilter, appointmentsWhereInput> | null
    payouts?: XOR<PayoutsNullableScalarRelationFilter, payoutsWhereInput> | null
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    appointment_id?: SortOrderInput | SortOrder
    payout_id?: SortOrderInput | SortOrder
    stripe_payment_intent_id?: SortOrderInput | SortOrder
    amount_total?: SortOrderInput | SortOrder
    platform_fee?: SortOrderInput | SortOrder
    provider_amount?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"payments"> | string
    appointment_id?: UuidNullableWithAggregatesFilter<"payments"> | string | null
    payout_id?: UuidNullableWithAggregatesFilter<"payments"> | string | null
    stripe_payment_intent_id?: StringNullableWithAggregatesFilter<"payments"> | string | null
    amount_total?: DecimalNullableWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    platform_fee?: DecimalNullableWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    provider_amount?: DecimalNullableWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableWithAggregatesFilter<"payments"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
  }

  export type payoutsWhereInput = {
    AND?: payoutsWhereInput | payoutsWhereInput[]
    OR?: payoutsWhereInput[]
    NOT?: payoutsWhereInput | payoutsWhereInput[]
    id?: UuidFilter<"payouts"> | string
    provider_id?: UuidNullableFilter<"payouts"> | string | null
    total_amount?: DecimalNullableFilter<"payouts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"payouts"> | string | null
    status?: StringNullableFilter<"payouts"> | string | null
    reference_number?: StringNullableFilter<"payouts"> | string | null
    period_start?: DateTimeNullableFilter<"payouts"> | Date | string | null
    period_end?: DateTimeNullableFilter<"payouts"> | Date | string | null
    created_at?: DateTimeNullableFilter<"payouts"> | Date | string | null
    payments?: PaymentsListRelationFilter
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
  }

  export type payoutsOrderByWithRelationInput = {
    id?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    reference_number?: SortOrderInput | SortOrder
    period_start?: SortOrderInput | SortOrder
    period_end?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    payments?: paymentsOrderByRelationAggregateInput
    providers?: providersOrderByWithRelationInput
  }

  export type payoutsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: payoutsWhereInput | payoutsWhereInput[]
    OR?: payoutsWhereInput[]
    NOT?: payoutsWhereInput | payoutsWhereInput[]
    provider_id?: UuidNullableFilter<"payouts"> | string | null
    total_amount?: DecimalNullableFilter<"payouts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"payouts"> | string | null
    status?: StringNullableFilter<"payouts"> | string | null
    reference_number?: StringNullableFilter<"payouts"> | string | null
    period_start?: DateTimeNullableFilter<"payouts"> | Date | string | null
    period_end?: DateTimeNullableFilter<"payouts"> | Date | string | null
    created_at?: DateTimeNullableFilter<"payouts"> | Date | string | null
    payments?: PaymentsListRelationFilter
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
  }, "id">

  export type payoutsOrderByWithAggregationInput = {
    id?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    total_amount?: SortOrderInput | SortOrder
    currency?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    reference_number?: SortOrderInput | SortOrder
    period_start?: SortOrderInput | SortOrder
    period_end?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: payoutsCountOrderByAggregateInput
    _avg?: payoutsAvgOrderByAggregateInput
    _max?: payoutsMaxOrderByAggregateInput
    _min?: payoutsMinOrderByAggregateInput
    _sum?: payoutsSumOrderByAggregateInput
  }

  export type payoutsScalarWhereWithAggregatesInput = {
    AND?: payoutsScalarWhereWithAggregatesInput | payoutsScalarWhereWithAggregatesInput[]
    OR?: payoutsScalarWhereWithAggregatesInput[]
    NOT?: payoutsScalarWhereWithAggregatesInput | payoutsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"payouts"> | string
    provider_id?: UuidNullableWithAggregatesFilter<"payouts"> | string | null
    total_amount?: DecimalNullableWithAggregatesFilter<"payouts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableWithAggregatesFilter<"payouts"> | string | null
    status?: StringNullableWithAggregatesFilter<"payouts"> | string | null
    reference_number?: StringNullableWithAggregatesFilter<"payouts"> | string | null
    period_start?: DateTimeNullableWithAggregatesFilter<"payouts"> | Date | string | null
    period_end?: DateTimeNullableWithAggregatesFilter<"payouts"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"payouts"> | Date | string | null
  }

  export type provider_adsWhereInput = {
    AND?: provider_adsWhereInput | provider_adsWhereInput[]
    OR?: provider_adsWhereInput[]
    NOT?: provider_adsWhereInput | provider_adsWhereInput[]
    id?: UuidFilter<"provider_ads"> | string
    provider_id?: UuidNullableFilter<"provider_ads"> | string | null
    badge_text?: StringNullableFilter<"provider_ads"> | string | null
    title?: StringNullableFilter<"provider_ads"> | string | null
    subtitle?: StringNullableFilter<"provider_ads"> | string | null
    image_url?: StringNullableFilter<"provider_ads"> | string | null
    action_text?: StringNullableFilter<"provider_ads"> | string | null
    bg_color_hex?: StringNullableFilter<"provider_ads"> | string | null
    accent_color_hex?: StringNullableFilter<"provider_ads"> | string | null
    target_screen?: StringNullableFilter<"provider_ads"> | string | null
    target_id?: StringNullableFilter<"provider_ads"> | string | null
    start_date?: DateTimeNullableFilter<"provider_ads"> | Date | string | null
    end_date?: DateTimeNullableFilter<"provider_ads"> | Date | string | null
    is_active?: BoolNullableFilter<"provider_ads"> | boolean | null
    priority_order?: IntNullableFilter<"provider_ads"> | number | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
  }

  export type provider_adsOrderByWithRelationInput = {
    id?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    badge_text?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    action_text?: SortOrderInput | SortOrder
    bg_color_hex?: SortOrderInput | SortOrder
    accent_color_hex?: SortOrderInput | SortOrder
    target_screen?: SortOrderInput | SortOrder
    target_id?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    priority_order?: SortOrderInput | SortOrder
    providers?: providersOrderByWithRelationInput
  }

  export type provider_adsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: provider_adsWhereInput | provider_adsWhereInput[]
    OR?: provider_adsWhereInput[]
    NOT?: provider_adsWhereInput | provider_adsWhereInput[]
    provider_id?: UuidNullableFilter<"provider_ads"> | string | null
    badge_text?: StringNullableFilter<"provider_ads"> | string | null
    title?: StringNullableFilter<"provider_ads"> | string | null
    subtitle?: StringNullableFilter<"provider_ads"> | string | null
    image_url?: StringNullableFilter<"provider_ads"> | string | null
    action_text?: StringNullableFilter<"provider_ads"> | string | null
    bg_color_hex?: StringNullableFilter<"provider_ads"> | string | null
    accent_color_hex?: StringNullableFilter<"provider_ads"> | string | null
    target_screen?: StringNullableFilter<"provider_ads"> | string | null
    target_id?: StringNullableFilter<"provider_ads"> | string | null
    start_date?: DateTimeNullableFilter<"provider_ads"> | Date | string | null
    end_date?: DateTimeNullableFilter<"provider_ads"> | Date | string | null
    is_active?: BoolNullableFilter<"provider_ads"> | boolean | null
    priority_order?: IntNullableFilter<"provider_ads"> | number | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
  }, "id">

  export type provider_adsOrderByWithAggregationInput = {
    id?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    badge_text?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    subtitle?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    action_text?: SortOrderInput | SortOrder
    bg_color_hex?: SortOrderInput | SortOrder
    accent_color_hex?: SortOrderInput | SortOrder
    target_screen?: SortOrderInput | SortOrder
    target_id?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    priority_order?: SortOrderInput | SortOrder
    _count?: provider_adsCountOrderByAggregateInput
    _avg?: provider_adsAvgOrderByAggregateInput
    _max?: provider_adsMaxOrderByAggregateInput
    _min?: provider_adsMinOrderByAggregateInput
    _sum?: provider_adsSumOrderByAggregateInput
  }

  export type provider_adsScalarWhereWithAggregatesInput = {
    AND?: provider_adsScalarWhereWithAggregatesInput | provider_adsScalarWhereWithAggregatesInput[]
    OR?: provider_adsScalarWhereWithAggregatesInput[]
    NOT?: provider_adsScalarWhereWithAggregatesInput | provider_adsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"provider_ads"> | string
    provider_id?: UuidNullableWithAggregatesFilter<"provider_ads"> | string | null
    badge_text?: StringNullableWithAggregatesFilter<"provider_ads"> | string | null
    title?: StringNullableWithAggregatesFilter<"provider_ads"> | string | null
    subtitle?: StringNullableWithAggregatesFilter<"provider_ads"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"provider_ads"> | string | null
    action_text?: StringNullableWithAggregatesFilter<"provider_ads"> | string | null
    bg_color_hex?: StringNullableWithAggregatesFilter<"provider_ads"> | string | null
    accent_color_hex?: StringNullableWithAggregatesFilter<"provider_ads"> | string | null
    target_screen?: StringNullableWithAggregatesFilter<"provider_ads"> | string | null
    target_id?: StringNullableWithAggregatesFilter<"provider_ads"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"provider_ads"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"provider_ads"> | Date | string | null
    is_active?: BoolNullableWithAggregatesFilter<"provider_ads"> | boolean | null
    priority_order?: IntNullableWithAggregatesFilter<"provider_ads"> | number | null
  }

  export type provider_bank_detailsWhereInput = {
    AND?: provider_bank_detailsWhereInput | provider_bank_detailsWhereInput[]
    OR?: provider_bank_detailsWhereInput[]
    NOT?: provider_bank_detailsWhereInput | provider_bank_detailsWhereInput[]
    id?: UuidFilter<"provider_bank_details"> | string
    provider_id?: UuidNullableFilter<"provider_bank_details"> | string | null
    bank_name?: StringNullableFilter<"provider_bank_details"> | string | null
    account_number?: StringNullableFilter<"provider_bank_details"> | string | null
    account_type?: StringNullableFilter<"provider_bank_details"> | string | null
    account_holder_name?: StringNullableFilter<"provider_bank_details"> | string | null
    holder_identification?: StringNullableFilter<"provider_bank_details"> | string | null
    is_verified?: BoolNullableFilter<"provider_bank_details"> | boolean | null
    updated_at?: DateTimeNullableFilter<"provider_bank_details"> | Date | string | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
  }

  export type provider_bank_detailsOrderByWithRelationInput = {
    id?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    bank_name?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    account_holder_name?: SortOrderInput | SortOrder
    holder_identification?: SortOrderInput | SortOrder
    is_verified?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    providers?: providersOrderByWithRelationInput
  }

  export type provider_bank_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: provider_bank_detailsWhereInput | provider_bank_detailsWhereInput[]
    OR?: provider_bank_detailsWhereInput[]
    NOT?: provider_bank_detailsWhereInput | provider_bank_detailsWhereInput[]
    provider_id?: UuidNullableFilter<"provider_bank_details"> | string | null
    bank_name?: StringNullableFilter<"provider_bank_details"> | string | null
    account_number?: StringNullableFilter<"provider_bank_details"> | string | null
    account_type?: StringNullableFilter<"provider_bank_details"> | string | null
    account_holder_name?: StringNullableFilter<"provider_bank_details"> | string | null
    holder_identification?: StringNullableFilter<"provider_bank_details"> | string | null
    is_verified?: BoolNullableFilter<"provider_bank_details"> | boolean | null
    updated_at?: DateTimeNullableFilter<"provider_bank_details"> | Date | string | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
  }, "id">

  export type provider_bank_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    bank_name?: SortOrderInput | SortOrder
    account_number?: SortOrderInput | SortOrder
    account_type?: SortOrderInput | SortOrder
    account_holder_name?: SortOrderInput | SortOrder
    holder_identification?: SortOrderInput | SortOrder
    is_verified?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: provider_bank_detailsCountOrderByAggregateInput
    _max?: provider_bank_detailsMaxOrderByAggregateInput
    _min?: provider_bank_detailsMinOrderByAggregateInput
  }

  export type provider_bank_detailsScalarWhereWithAggregatesInput = {
    AND?: provider_bank_detailsScalarWhereWithAggregatesInput | provider_bank_detailsScalarWhereWithAggregatesInput[]
    OR?: provider_bank_detailsScalarWhereWithAggregatesInput[]
    NOT?: provider_bank_detailsScalarWhereWithAggregatesInput | provider_bank_detailsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"provider_bank_details"> | string
    provider_id?: UuidNullableWithAggregatesFilter<"provider_bank_details"> | string | null
    bank_name?: StringNullableWithAggregatesFilter<"provider_bank_details"> | string | null
    account_number?: StringNullableWithAggregatesFilter<"provider_bank_details"> | string | null
    account_type?: StringNullableWithAggregatesFilter<"provider_bank_details"> | string | null
    account_holder_name?: StringNullableWithAggregatesFilter<"provider_bank_details"> | string | null
    holder_identification?: StringNullableWithAggregatesFilter<"provider_bank_details"> | string | null
    is_verified?: BoolNullableWithAggregatesFilter<"provider_bank_details"> | boolean | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"provider_bank_details"> | Date | string | null
  }

  export type provider_branchesWhereInput = {
    AND?: provider_branchesWhereInput | provider_branchesWhereInput[]
    OR?: provider_branchesWhereInput[]
    NOT?: provider_branchesWhereInput | provider_branchesWhereInput[]
    id?: UuidFilter<"provider_branches"> | string
    provider_id?: UuidNullableFilter<"provider_branches"> | string | null
    city_id?: UuidNullableFilter<"provider_branches"> | string | null
    name?: StringNullableFilter<"provider_branches"> | string | null
    description?: StringNullableFilter<"provider_branches"> | string | null
    address_text?: StringNullableFilter<"provider_branches"> | string | null
    latitude?: FloatNullableFilter<"provider_branches"> | number | null
    longitude?: FloatNullableFilter<"provider_branches"> | number | null
    phone_contact?: StringNullableFilter<"provider_branches"> | string | null
    email_contact?: StringNullableFilter<"provider_branches"> | string | null
    image_url?: StringNullableFilter<"provider_branches"> | string | null
    opening_hours_text?: StringNullableFilter<"provider_branches"> | string | null
    is_24h?: BoolNullableFilter<"provider_branches"> | boolean | null
    has_delivery?: BoolNullableFilter<"provider_branches"> | boolean | null
    rating_cache?: FloatNullableFilter<"provider_branches"> | number | null
    is_main?: BoolNullableFilter<"provider_branches"> | boolean | null
    is_active?: BoolNullableFilter<"provider_branches"> | boolean | null
    appointments?: AppointmentsListRelationFilter
    patient_favorites?: Patient_favoritesListRelationFilter
    cities?: XOR<CitiesNullableScalarRelationFilter, citiesWhereInput> | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
    provider_schedules?: Provider_schedulesListRelationFilter
    reviews?: ReviewsListRelationFilter
  }

  export type provider_branchesOrderByWithRelationInput = {
    id?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    city_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    address_text?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    phone_contact?: SortOrderInput | SortOrder
    email_contact?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    opening_hours_text?: SortOrderInput | SortOrder
    is_24h?: SortOrderInput | SortOrder
    has_delivery?: SortOrderInput | SortOrder
    rating_cache?: SortOrderInput | SortOrder
    is_main?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByRelationAggregateInput
    patient_favorites?: patient_favoritesOrderByRelationAggregateInput
    cities?: citiesOrderByWithRelationInput
    providers?: providersOrderByWithRelationInput
    provider_schedules?: provider_schedulesOrderByRelationAggregateInput
    reviews?: reviewsOrderByRelationAggregateInput
  }

  export type provider_branchesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: provider_branchesWhereInput | provider_branchesWhereInput[]
    OR?: provider_branchesWhereInput[]
    NOT?: provider_branchesWhereInput | provider_branchesWhereInput[]
    provider_id?: UuidNullableFilter<"provider_branches"> | string | null
    city_id?: UuidNullableFilter<"provider_branches"> | string | null
    name?: StringNullableFilter<"provider_branches"> | string | null
    description?: StringNullableFilter<"provider_branches"> | string | null
    address_text?: StringNullableFilter<"provider_branches"> | string | null
    latitude?: FloatNullableFilter<"provider_branches"> | number | null
    longitude?: FloatNullableFilter<"provider_branches"> | number | null
    phone_contact?: StringNullableFilter<"provider_branches"> | string | null
    email_contact?: StringNullableFilter<"provider_branches"> | string | null
    image_url?: StringNullableFilter<"provider_branches"> | string | null
    opening_hours_text?: StringNullableFilter<"provider_branches"> | string | null
    is_24h?: BoolNullableFilter<"provider_branches"> | boolean | null
    has_delivery?: BoolNullableFilter<"provider_branches"> | boolean | null
    rating_cache?: FloatNullableFilter<"provider_branches"> | number | null
    is_main?: BoolNullableFilter<"provider_branches"> | boolean | null
    is_active?: BoolNullableFilter<"provider_branches"> | boolean | null
    appointments?: AppointmentsListRelationFilter
    patient_favorites?: Patient_favoritesListRelationFilter
    cities?: XOR<CitiesNullableScalarRelationFilter, citiesWhereInput> | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
    provider_schedules?: Provider_schedulesListRelationFilter
    reviews?: ReviewsListRelationFilter
  }, "id">

  export type provider_branchesOrderByWithAggregationInput = {
    id?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    city_id?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    address_text?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    phone_contact?: SortOrderInput | SortOrder
    email_contact?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    opening_hours_text?: SortOrderInput | SortOrder
    is_24h?: SortOrderInput | SortOrder
    has_delivery?: SortOrderInput | SortOrder
    rating_cache?: SortOrderInput | SortOrder
    is_main?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    _count?: provider_branchesCountOrderByAggregateInput
    _avg?: provider_branchesAvgOrderByAggregateInput
    _max?: provider_branchesMaxOrderByAggregateInput
    _min?: provider_branchesMinOrderByAggregateInput
    _sum?: provider_branchesSumOrderByAggregateInput
  }

  export type provider_branchesScalarWhereWithAggregatesInput = {
    AND?: provider_branchesScalarWhereWithAggregatesInput | provider_branchesScalarWhereWithAggregatesInput[]
    OR?: provider_branchesScalarWhereWithAggregatesInput[]
    NOT?: provider_branchesScalarWhereWithAggregatesInput | provider_branchesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"provider_branches"> | string
    provider_id?: UuidNullableWithAggregatesFilter<"provider_branches"> | string | null
    city_id?: UuidNullableWithAggregatesFilter<"provider_branches"> | string | null
    name?: StringNullableWithAggregatesFilter<"provider_branches"> | string | null
    description?: StringNullableWithAggregatesFilter<"provider_branches"> | string | null
    address_text?: StringNullableWithAggregatesFilter<"provider_branches"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"provider_branches"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"provider_branches"> | number | null
    phone_contact?: StringNullableWithAggregatesFilter<"provider_branches"> | string | null
    email_contact?: StringNullableWithAggregatesFilter<"provider_branches"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"provider_branches"> | string | null
    opening_hours_text?: StringNullableWithAggregatesFilter<"provider_branches"> | string | null
    is_24h?: BoolNullableWithAggregatesFilter<"provider_branches"> | boolean | null
    has_delivery?: BoolNullableWithAggregatesFilter<"provider_branches"> | boolean | null
    rating_cache?: FloatNullableWithAggregatesFilter<"provider_branches"> | number | null
    is_main?: BoolNullableWithAggregatesFilter<"provider_branches"> | boolean | null
    is_active?: BoolNullableWithAggregatesFilter<"provider_branches"> | boolean | null
  }

  export type provider_catalogWhereInput = {
    AND?: provider_catalogWhereInput | provider_catalogWhereInput[]
    OR?: provider_catalogWhereInput[]
    NOT?: provider_catalogWhereInput | provider_catalogWhereInput[]
    id?: UuidFilter<"provider_catalog"> | string
    provider_id?: UuidNullableFilter<"provider_catalog"> | string | null
    type?: StringNullableFilter<"provider_catalog"> | string | null
    name?: StringNullableFilter<"provider_catalog"> | string | null
    description?: StringNullableFilter<"provider_catalog"> | string | null
    price?: DecimalNullableFilter<"provider_catalog"> | Decimal | DecimalJsLike | number | string | null
    is_available?: BoolNullableFilter<"provider_catalog"> | boolean | null
    image_url?: StringNullableFilter<"provider_catalog"> | string | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
  }

  export type provider_catalogOrderByWithRelationInput = {
    id?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    is_available?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    providers?: providersOrderByWithRelationInput
  }

  export type provider_catalogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: provider_catalogWhereInput | provider_catalogWhereInput[]
    OR?: provider_catalogWhereInput[]
    NOT?: provider_catalogWhereInput | provider_catalogWhereInput[]
    provider_id?: UuidNullableFilter<"provider_catalog"> | string | null
    type?: StringNullableFilter<"provider_catalog"> | string | null
    name?: StringNullableFilter<"provider_catalog"> | string | null
    description?: StringNullableFilter<"provider_catalog"> | string | null
    price?: DecimalNullableFilter<"provider_catalog"> | Decimal | DecimalJsLike | number | string | null
    is_available?: BoolNullableFilter<"provider_catalog"> | boolean | null
    image_url?: StringNullableFilter<"provider_catalog"> | string | null
    providers?: XOR<ProvidersNullableScalarRelationFilter, providersWhereInput> | null
  }, "id">

  export type provider_catalogOrderByWithAggregationInput = {
    id?: SortOrder
    provider_id?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    is_available?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    _count?: provider_catalogCountOrderByAggregateInput
    _avg?: provider_catalogAvgOrderByAggregateInput
    _max?: provider_catalogMaxOrderByAggregateInput
    _min?: provider_catalogMinOrderByAggregateInput
    _sum?: provider_catalogSumOrderByAggregateInput
  }

  export type provider_catalogScalarWhereWithAggregatesInput = {
    AND?: provider_catalogScalarWhereWithAggregatesInput | provider_catalogScalarWhereWithAggregatesInput[]
    OR?: provider_catalogScalarWhereWithAggregatesInput[]
    NOT?: provider_catalogScalarWhereWithAggregatesInput | provider_catalogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"provider_catalog"> | string
    provider_id?: UuidNullableWithAggregatesFilter<"provider_catalog"> | string | null
    type?: StringNullableWithAggregatesFilter<"provider_catalog"> | string | null
    name?: StringNullableWithAggregatesFilter<"provider_catalog"> | string | null
    description?: StringNullableWithAggregatesFilter<"provider_catalog"> | string | null
    price?: DecimalNullableWithAggregatesFilter<"provider_catalog"> | Decimal | DecimalJsLike | number | string | null
    is_available?: BoolNullableWithAggregatesFilter<"provider_catalog"> | boolean | null
    image_url?: StringNullableWithAggregatesFilter<"provider_catalog"> | string | null
  }

  export type provider_schedulesWhereInput = {
    AND?: provider_schedulesWhereInput | provider_schedulesWhereInput[]
    OR?: provider_schedulesWhereInput[]
    NOT?: provider_schedulesWhereInput | provider_schedulesWhereInput[]
    id?: UuidFilter<"provider_schedules"> | string
    branch_id?: UuidNullableFilter<"provider_schedules"> | string | null
    day_of_week?: IntNullableFilter<"provider_schedules"> | number | null
    start_time?: DateTimeNullableFilter<"provider_schedules"> | Date | string | null
    end_time?: DateTimeNullableFilter<"provider_schedules"> | Date | string | null
    provider_branches?: XOR<Provider_branchesNullableScalarRelationFilter, provider_branchesWhereInput> | null
  }

  export type provider_schedulesOrderByWithRelationInput = {
    id?: SortOrder
    branch_id?: SortOrderInput | SortOrder
    day_of_week?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    provider_branches?: provider_branchesOrderByWithRelationInput
  }

  export type provider_schedulesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: provider_schedulesWhereInput | provider_schedulesWhereInput[]
    OR?: provider_schedulesWhereInput[]
    NOT?: provider_schedulesWhereInput | provider_schedulesWhereInput[]
    branch_id?: UuidNullableFilter<"provider_schedules"> | string | null
    day_of_week?: IntNullableFilter<"provider_schedules"> | number | null
    start_time?: DateTimeNullableFilter<"provider_schedules"> | Date | string | null
    end_time?: DateTimeNullableFilter<"provider_schedules"> | Date | string | null
    provider_branches?: XOR<Provider_branchesNullableScalarRelationFilter, provider_branchesWhereInput> | null
  }, "id">

  export type provider_schedulesOrderByWithAggregationInput = {
    id?: SortOrder
    branch_id?: SortOrderInput | SortOrder
    day_of_week?: SortOrderInput | SortOrder
    start_time?: SortOrderInput | SortOrder
    end_time?: SortOrderInput | SortOrder
    _count?: provider_schedulesCountOrderByAggregateInput
    _avg?: provider_schedulesAvgOrderByAggregateInput
    _max?: provider_schedulesMaxOrderByAggregateInput
    _min?: provider_schedulesMinOrderByAggregateInput
    _sum?: provider_schedulesSumOrderByAggregateInput
  }

  export type provider_schedulesScalarWhereWithAggregatesInput = {
    AND?: provider_schedulesScalarWhereWithAggregatesInput | provider_schedulesScalarWhereWithAggregatesInput[]
    OR?: provider_schedulesScalarWhereWithAggregatesInput[]
    NOT?: provider_schedulesScalarWhereWithAggregatesInput | provider_schedulesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"provider_schedules"> | string
    branch_id?: UuidNullableWithAggregatesFilter<"provider_schedules"> | string | null
    day_of_week?: IntNullableWithAggregatesFilter<"provider_schedules"> | number | null
    start_time?: DateTimeNullableWithAggregatesFilter<"provider_schedules"> | Date | string | null
    end_time?: DateTimeNullableWithAggregatesFilter<"provider_schedules"> | Date | string | null
  }

  export type providersWhereInput = {
    AND?: providersWhereInput | providersWhereInput[]
    OR?: providersWhereInput[]
    NOT?: providersWhereInput | providersWhereInput[]
    id?: UuidFilter<"providers"> | string
    user_id?: UuidNullableFilter<"providers"> | string | null
    category_id?: IntNullableFilter<"providers"> | number | null
    commercial_name?: StringNullableFilter<"providers"> | string | null
    logo_url?: StringNullableFilter<"providers"> | string | null
    description?: StringNullableFilter<"providers"> | string | null
    verification_status?: StringNullableFilter<"providers"> | string | null
    commission_percentage?: DecimalNullableFilter<"providers"> | Decimal | DecimalJsLike | number | string | null
    appointments?: AppointmentsListRelationFilter
    medical_history?: Medical_historyListRelationFilter
    payouts?: PayoutsListRelationFilter
    provider_ads?: Provider_adsListRelationFilter
    provider_bank_details?: Provider_bank_detailsListRelationFilter
    provider_branches?: Provider_branchesListRelationFilter
    provider_catalog?: Provider_catalogListRelationFilter
    service_categories?: XOR<Service_categoriesNullableScalarRelationFilter, service_categoriesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type providersOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    commercial_name?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    verification_status?: SortOrderInput | SortOrder
    commission_percentage?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByRelationAggregateInput
    medical_history?: medical_historyOrderByRelationAggregateInput
    payouts?: payoutsOrderByRelationAggregateInput
    provider_ads?: provider_adsOrderByRelationAggregateInput
    provider_bank_details?: provider_bank_detailsOrderByRelationAggregateInput
    provider_branches?: provider_branchesOrderByRelationAggregateInput
    provider_catalog?: provider_catalogOrderByRelationAggregateInput
    service_categories?: service_categoriesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type providersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: providersWhereInput | providersWhereInput[]
    OR?: providersWhereInput[]
    NOT?: providersWhereInput | providersWhereInput[]
    user_id?: UuidNullableFilter<"providers"> | string | null
    category_id?: IntNullableFilter<"providers"> | number | null
    commercial_name?: StringNullableFilter<"providers"> | string | null
    logo_url?: StringNullableFilter<"providers"> | string | null
    description?: StringNullableFilter<"providers"> | string | null
    verification_status?: StringNullableFilter<"providers"> | string | null
    commission_percentage?: DecimalNullableFilter<"providers"> | Decimal | DecimalJsLike | number | string | null
    appointments?: AppointmentsListRelationFilter
    medical_history?: Medical_historyListRelationFilter
    payouts?: PayoutsListRelationFilter
    provider_ads?: Provider_adsListRelationFilter
    provider_bank_details?: Provider_bank_detailsListRelationFilter
    provider_branches?: Provider_branchesListRelationFilter
    provider_catalog?: Provider_catalogListRelationFilter
    service_categories?: XOR<Service_categoriesNullableScalarRelationFilter, service_categoriesWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type providersOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    category_id?: SortOrderInput | SortOrder
    commercial_name?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    verification_status?: SortOrderInput | SortOrder
    commission_percentage?: SortOrderInput | SortOrder
    _count?: providersCountOrderByAggregateInput
    _avg?: providersAvgOrderByAggregateInput
    _max?: providersMaxOrderByAggregateInput
    _min?: providersMinOrderByAggregateInput
    _sum?: providersSumOrderByAggregateInput
  }

  export type providersScalarWhereWithAggregatesInput = {
    AND?: providersScalarWhereWithAggregatesInput | providersScalarWhereWithAggregatesInput[]
    OR?: providersScalarWhereWithAggregatesInput[]
    NOT?: providersScalarWhereWithAggregatesInput | providersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"providers"> | string
    user_id?: UuidNullableWithAggregatesFilter<"providers"> | string | null
    category_id?: IntNullableWithAggregatesFilter<"providers"> | number | null
    commercial_name?: StringNullableWithAggregatesFilter<"providers"> | string | null
    logo_url?: StringNullableWithAggregatesFilter<"providers"> | string | null
    description?: StringNullableWithAggregatesFilter<"providers"> | string | null
    verification_status?: StringNullableWithAggregatesFilter<"providers"> | string | null
    commission_percentage?: DecimalNullableWithAggregatesFilter<"providers"> | Decimal | DecimalJsLike | number | string | null
  }

  export type reviewsWhereInput = {
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    id?: UuidFilter<"reviews"> | string
    patient_id?: UuidNullableFilter<"reviews"> | string | null
    branch_id?: UuidNullableFilter<"reviews"> | string | null
    appointment_id?: UuidNullableFilter<"reviews"> | string | null
    rating?: IntNullableFilter<"reviews"> | number | null
    comment?: StringNullableFilter<"reviews"> | string | null
    created_at?: DateTimeNullableFilter<"reviews"> | Date | string | null
    appointments?: XOR<AppointmentsNullableScalarRelationFilter, appointmentsWhereInput> | null
    provider_branches?: XOR<Provider_branchesNullableScalarRelationFilter, provider_branchesWhereInput> | null
    patients?: XOR<PatientsNullableScalarRelationFilter, patientsWhereInput> | null
  }

  export type reviewsOrderByWithRelationInput = {
    id?: SortOrder
    patient_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    appointment_id?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    appointments?: appointmentsOrderByWithRelationInput
    provider_branches?: provider_branchesOrderByWithRelationInput
    patients?: patientsOrderByWithRelationInput
  }

  export type reviewsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reviewsWhereInput | reviewsWhereInput[]
    OR?: reviewsWhereInput[]
    NOT?: reviewsWhereInput | reviewsWhereInput[]
    patient_id?: UuidNullableFilter<"reviews"> | string | null
    branch_id?: UuidNullableFilter<"reviews"> | string | null
    appointment_id?: UuidNullableFilter<"reviews"> | string | null
    rating?: IntNullableFilter<"reviews"> | number | null
    comment?: StringNullableFilter<"reviews"> | string | null
    created_at?: DateTimeNullableFilter<"reviews"> | Date | string | null
    appointments?: XOR<AppointmentsNullableScalarRelationFilter, appointmentsWhereInput> | null
    provider_branches?: XOR<Provider_branchesNullableScalarRelationFilter, provider_branchesWhereInput> | null
    patients?: XOR<PatientsNullableScalarRelationFilter, patientsWhereInput> | null
  }, "id">

  export type reviewsOrderByWithAggregationInput = {
    id?: SortOrder
    patient_id?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    appointment_id?: SortOrderInput | SortOrder
    rating?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: reviewsCountOrderByAggregateInput
    _avg?: reviewsAvgOrderByAggregateInput
    _max?: reviewsMaxOrderByAggregateInput
    _min?: reviewsMinOrderByAggregateInput
    _sum?: reviewsSumOrderByAggregateInput
  }

  export type reviewsScalarWhereWithAggregatesInput = {
    AND?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    OR?: reviewsScalarWhereWithAggregatesInput[]
    NOT?: reviewsScalarWhereWithAggregatesInput | reviewsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"reviews"> | string
    patient_id?: UuidNullableWithAggregatesFilter<"reviews"> | string | null
    branch_id?: UuidNullableWithAggregatesFilter<"reviews"> | string | null
    appointment_id?: UuidNullableWithAggregatesFilter<"reviews"> | string | null
    rating?: IntNullableWithAggregatesFilter<"reviews"> | number | null
    comment?: StringNullableWithAggregatesFilter<"reviews"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"reviews"> | Date | string | null
  }

  export type service_categoriesWhereInput = {
    AND?: service_categoriesWhereInput | service_categoriesWhereInput[]
    OR?: service_categoriesWhereInput[]
    NOT?: service_categoriesWhereInput | service_categoriesWhereInput[]
    id?: IntFilter<"service_categories"> | number
    name?: StringFilter<"service_categories"> | string
    slug?: StringFilter<"service_categories"> | string
    default_color_hex?: StringNullableFilter<"service_categories"> | string | null
    allows_booking?: BoolNullableFilter<"service_categories"> | boolean | null
    providers?: ProvidersListRelationFilter
  }

  export type service_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    default_color_hex?: SortOrderInput | SortOrder
    allows_booking?: SortOrderInput | SortOrder
    providers?: providersOrderByRelationAggregateInput
  }

  export type service_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: service_categoriesWhereInput | service_categoriesWhereInput[]
    OR?: service_categoriesWhereInput[]
    NOT?: service_categoriesWhereInput | service_categoriesWhereInput[]
    name?: StringFilter<"service_categories"> | string
    slug?: StringFilter<"service_categories"> | string
    default_color_hex?: StringNullableFilter<"service_categories"> | string | null
    allows_booking?: BoolNullableFilter<"service_categories"> | boolean | null
    providers?: ProvidersListRelationFilter
  }, "id">

  export type service_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    default_color_hex?: SortOrderInput | SortOrder
    allows_booking?: SortOrderInput | SortOrder
    _count?: service_categoriesCountOrderByAggregateInput
    _avg?: service_categoriesAvgOrderByAggregateInput
    _max?: service_categoriesMaxOrderByAggregateInput
    _min?: service_categoriesMinOrderByAggregateInput
    _sum?: service_categoriesSumOrderByAggregateInput
  }

  export type service_categoriesScalarWhereWithAggregatesInput = {
    AND?: service_categoriesScalarWhereWithAggregatesInput | service_categoriesScalarWhereWithAggregatesInput[]
    OR?: service_categoriesScalarWhereWithAggregatesInput[]
    NOT?: service_categoriesScalarWhereWithAggregatesInput | service_categoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"service_categories"> | number
    name?: StringWithAggregatesFilter<"service_categories"> | string
    slug?: StringWithAggregatesFilter<"service_categories"> | string
    default_color_hex?: StringNullableWithAggregatesFilter<"service_categories"> | string | null
    allows_booking?: BoolNullableWithAggregatesFilter<"service_categories"> | boolean | null
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: UuidFilter<"sessions"> | string
    user_id?: UuidNullableFilter<"sessions"> | string | null
    token?: StringFilter<"sessions"> | string
    device_info?: StringNullableFilter<"sessions"> | string | null
    expires_at?: DateTimeFilter<"sessions"> | Date | string
    created_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    token?: SortOrder
    device_info?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    created_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    user_id?: UuidNullableFilter<"sessions"> | string | null
    token?: StringFilter<"sessions"> | string
    device_info?: StringNullableFilter<"sessions"> | string | null
    expires_at?: DateTimeFilter<"sessions"> | Date | string
    created_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    token?: SortOrder
    device_info?: SortOrderInput | SortOrder
    expires_at?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"sessions"> | string
    user_id?: UuidNullableWithAggregatesFilter<"sessions"> | string | null
    token?: StringWithAggregatesFilter<"sessions"> | string
    device_info?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    expires_at?: DateTimeWithAggregatesFilter<"sessions"> | Date | string
    created_at?: DateTimeNullableWithAggregatesFilter<"sessions"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: UuidFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    role?: Enumenum_rolesNullableFilter<"users"> | $Enums.enum_roles | null
    profile_picture_url?: StringNullableFilter<"users"> | string | null
    is_active?: BoolNullableFilter<"users"> | boolean | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    patients?: PatientsListRelationFilter
    providers?: ProvidersListRelationFilter
    sessions?: SessionsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrderInput | SortOrder
    profile_picture_url?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    patients?: patientsOrderByRelationAggregateInput
    providers?: providersOrderByRelationAggregateInput
    sessions?: sessionsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    email?: StringFilter<"users"> | string
    password_hash?: StringFilter<"users"> | string
    role?: Enumenum_rolesNullableFilter<"users"> | $Enums.enum_roles | null
    profile_picture_url?: StringNullableFilter<"users"> | string | null
    is_active?: BoolNullableFilter<"users"> | boolean | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    patients?: PatientsListRelationFilter
    providers?: ProvidersListRelationFilter
    sessions?: SessionsListRelationFilter
  }, "id">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrderInput | SortOrder
    profile_picture_url?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password_hash?: StringWithAggregatesFilter<"users"> | string
    role?: Enumenum_rolesNullableWithAggregatesFilter<"users"> | $Enums.enum_roles | null
    profile_picture_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    is_active?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type appointmentsCreateInput = {
    id: string
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    provider_branches?: provider_branchesCreateNestedOneWithoutAppointmentsInput
    patients?: patientsCreateNestedOneWithoutAppointmentsInput
    providers?: providersCreateNestedOneWithoutAppointmentsInput
    payments?: paymentsCreateNestedManyWithoutAppointmentsInput
    reviews?: reviewsCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    provider_id?: string | null
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    payments?: paymentsUncheckedCreateNestedManyWithoutAppointmentsInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_branches?: provider_branchesUpdateOneWithoutAppointmentsNestedInput
    patients?: patientsUpdateOneWithoutAppointmentsNestedInput
    providers?: providersUpdateOneWithoutAppointmentsNestedInput
    payments?: paymentsUpdateManyWithoutAppointmentsNestedInput
    reviews?: reviewsUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payments?: paymentsUncheckedUpdateManyWithoutAppointmentsNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsCreateManyInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    provider_id?: string | null
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
  }

  export type appointmentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type appointmentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type citiesCreateInput = {
    id: string
    name: string
    state?: string | null
    country?: string | null
    provider_branches?: provider_branchesCreateNestedManyWithoutCitiesInput
  }

  export type citiesUncheckedCreateInput = {
    id: string
    name: string
    state?: string | null
    country?: string | null
    provider_branches?: provider_branchesUncheckedCreateNestedManyWithoutCitiesInput
  }

  export type citiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    provider_branches?: provider_branchesUpdateManyWithoutCitiesNestedInput
  }

  export type citiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    provider_branches?: provider_branchesUncheckedUpdateManyWithoutCitiesNestedInput
  }

  export type citiesCreateManyInput = {
    id: string
    name: string
    state?: string | null
    country?: string | null
  }

  export type citiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type citiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type medical_historyCreateInput = {
    id: string
    doctor_name_snapshot?: string | null
    specialty_snapshot?: string | null
    diagnosis?: string | null
    date?: Date | string | null
    treatment?: string | null
    indications?: string | null
    observations?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    patients?: patientsCreateNestedOneWithoutMedical_historyInput
    providers?: providersCreateNestedOneWithoutMedical_historyInput
  }

  export type medical_historyUncheckedCreateInput = {
    id: string
    patient_id?: string | null
    provider_id?: string | null
    doctor_name_snapshot?: string | null
    specialty_snapshot?: string | null
    diagnosis?: string | null
    date?: Date | string | null
    treatment?: string | null
    indications?: string | null
    observations?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type medical_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctor_name_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    specialty_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    indications?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUpdateOneWithoutMedical_historyNestedInput
    providers?: providersUpdateOneWithoutMedical_historyNestedInput
  }

  export type medical_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_name_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    specialty_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    indications?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medical_historyCreateManyInput = {
    id: string
    patient_id?: string | null
    provider_id?: string | null
    doctor_name_snapshot?: string | null
    specialty_snapshot?: string | null
    diagnosis?: string | null
    date?: Date | string | null
    treatment?: string | null
    indications?: string | null
    observations?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type medical_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctor_name_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    specialty_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    indications?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medical_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_name_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    specialty_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    indications?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsCreateInput = {
    id: string
    type: $Enums.enum_notif_types
    title: string
    body: string
    is_read?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    patients: patientsCreateNestedOneWithoutNotificationsInput
  }

  export type notificationsUncheckedCreateInput = {
    id: string
    patient_id: string
    type: $Enums.enum_notif_types
    title: string
    body: string
    is_read?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type notificationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_notif_typesFieldUpdateOperationsInput | $Enums.enum_notif_types
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_notif_typesFieldUpdateOperationsInput | $Enums.enum_notif_types
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsCreateManyInput = {
    id: string
    patient_id: string
    type: $Enums.enum_notif_types
    title: string
    body: string
    is_read?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type notificationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_notif_typesFieldUpdateOperationsInput | $Enums.enum_notif_types
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_notif_typesFieldUpdateOperationsInput | $Enums.enum_notif_types
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_favoritesCreateInput = {
    id: string
    created_at?: Date | string | null
    provider_branches?: provider_branchesCreateNestedOneWithoutPatient_favoritesInput
    patients?: patientsCreateNestedOneWithoutPatient_favoritesInput
  }

  export type patient_favoritesUncheckedCreateInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    created_at?: Date | string | null
  }

  export type patient_favoritesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_branches?: provider_branchesUpdateOneWithoutPatient_favoritesNestedInput
    patients?: patientsUpdateOneWithoutPatient_favoritesNestedInput
  }

  export type patient_favoritesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_favoritesCreateManyInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    created_at?: Date | string | null
  }

  export type patient_favoritesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_favoritesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patientsCreateInput = {
    id: string
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsCreateNestedManyWithoutPatientsInput
    medical_history?: medical_historyCreateNestedManyWithoutPatientsInput
    notifications?: notificationsCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutPatientsInput
    users?: usersCreateNestedOneWithoutPatientsInput
    reviews?: reviewsCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateInput = {
    id: string
    user_id?: string | null
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutPatientsInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutPatientsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutPatientsInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutPatientsNestedInput
    medical_history?: medical_historyUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneWithoutPatientsNestedInput
    reviews?: reviewsUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutPatientsNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutPatientsNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type patientsCreateManyInput = {
    id: string
    user_id?: string | null
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
  }

  export type patientsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type patientsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type paymentsCreateInput = {
    id: string
    stripe_payment_intent_id?: string | null
    amount_total?: Decimal | DecimalJsLike | number | string | null
    platform_fee?: Decimal | DecimalJsLike | number | string | null
    provider_amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
    appointments?: appointmentsCreateNestedOneWithoutPaymentsInput
    payouts?: payoutsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id: string
    appointment_id?: string | null
    payout_id?: string | null
    stripe_payment_intent_id?: string | null
    amount_total?: Decimal | DecimalJsLike | number | string | null
    platform_fee?: Decimal | DecimalJsLike | number | string | null
    provider_amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type paymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    provider_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateOneWithoutPaymentsNestedInput
    payouts?: payoutsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointment_id?: NullableStringFieldUpdateOperationsInput | string | null
    payout_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    provider_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateManyInput = {
    id: string
    appointment_id?: string | null
    payout_id?: string | null
    stripe_payment_intent_id?: string | null
    amount_total?: Decimal | DecimalJsLike | number | string | null
    platform_fee?: Decimal | DecimalJsLike | number | string | null
    provider_amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type paymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    provider_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointment_id?: NullableStringFieldUpdateOperationsInput | string | null
    payout_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    provider_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payoutsCreateInput = {
    id: string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    reference_number?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    created_at?: Date | string | null
    payments?: paymentsCreateNestedManyWithoutPayoutsInput
    providers?: providersCreateNestedOneWithoutPayoutsInput
  }

  export type payoutsUncheckedCreateInput = {
    id: string
    provider_id?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    reference_number?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    created_at?: Date | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutPayoutsInput
  }

  export type payoutsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: paymentsUpdateManyWithoutPayoutsNestedInput
    providers?: providersUpdateOneWithoutPayoutsNestedInput
  }

  export type payoutsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: paymentsUncheckedUpdateManyWithoutPayoutsNestedInput
  }

  export type payoutsCreateManyInput = {
    id: string
    provider_id?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    reference_number?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    created_at?: Date | string | null
  }

  export type payoutsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payoutsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_adsCreateInput = {
    id: string
    badge_text?: string | null
    title?: string | null
    subtitle?: string | null
    image_url?: string | null
    action_text?: string | null
    bg_color_hex?: string | null
    accent_color_hex?: string | null
    target_screen?: string | null
    target_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    priority_order?: number | null
    providers?: providersCreateNestedOneWithoutProvider_adsInput
  }

  export type provider_adsUncheckedCreateInput = {
    id: string
    provider_id?: string | null
    badge_text?: string | null
    title?: string | null
    subtitle?: string | null
    image_url?: string | null
    action_text?: string | null
    bg_color_hex?: string | null
    accent_color_hex?: string | null
    target_screen?: string | null
    target_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    priority_order?: number | null
  }

  export type provider_adsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge_text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    action_text?: NullableStringFieldUpdateOperationsInput | string | null
    bg_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    accent_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    target_screen?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority_order?: NullableIntFieldUpdateOperationsInput | number | null
    providers?: providersUpdateOneWithoutProvider_adsNestedInput
  }

  export type provider_adsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    badge_text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    action_text?: NullableStringFieldUpdateOperationsInput | string | null
    bg_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    accent_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    target_screen?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type provider_adsCreateManyInput = {
    id: string
    provider_id?: string | null
    badge_text?: string | null
    title?: string | null
    subtitle?: string | null
    image_url?: string | null
    action_text?: string | null
    bg_color_hex?: string | null
    accent_color_hex?: string | null
    target_screen?: string | null
    target_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    priority_order?: number | null
  }

  export type provider_adsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge_text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    action_text?: NullableStringFieldUpdateOperationsInput | string | null
    bg_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    accent_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    target_screen?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type provider_adsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    badge_text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    action_text?: NullableStringFieldUpdateOperationsInput | string | null
    bg_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    accent_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    target_screen?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type provider_bank_detailsCreateInput = {
    id: string
    bank_name?: string | null
    account_number?: string | null
    account_type?: string | null
    account_holder_name?: string | null
    holder_identification?: string | null
    is_verified?: boolean | null
    updated_at?: Date | string | null
    providers?: providersCreateNestedOneWithoutProvider_bank_detailsInput
  }

  export type provider_bank_detailsUncheckedCreateInput = {
    id: string
    provider_id?: string | null
    bank_name?: string | null
    account_number?: string | null
    account_type?: string | null
    account_holder_name?: string | null
    holder_identification?: string | null
    is_verified?: boolean | null
    updated_at?: Date | string | null
  }

  export type provider_bank_detailsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_holder_name?: NullableStringFieldUpdateOperationsInput | string | null
    holder_identification?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providers?: providersUpdateOneWithoutProvider_bank_detailsNestedInput
  }

  export type provider_bank_detailsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_holder_name?: NullableStringFieldUpdateOperationsInput | string | null
    holder_identification?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_bank_detailsCreateManyInput = {
    id: string
    provider_id?: string | null
    bank_name?: string | null
    account_number?: string | null
    account_type?: string | null
    account_holder_name?: string | null
    holder_identification?: string | null
    is_verified?: boolean | null
    updated_at?: Date | string | null
  }

  export type provider_bank_detailsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_holder_name?: NullableStringFieldUpdateOperationsInput | string | null
    holder_identification?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_bank_detailsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_holder_name?: NullableStringFieldUpdateOperationsInput | string | null
    holder_identification?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_branchesCreateInput = {
    id: string
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutProvider_branchesInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutProvider_branchesInput
    cities?: citiesCreateNestedOneWithoutProvider_branchesInput
    providers?: providersCreateNestedOneWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesUncheckedCreateInput = {
    id: string
    provider_id?: string | null
    city_id?: string | null
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvider_branchesInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesUncheckedCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutProvider_branchesNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutProvider_branchesNestedInput
    cities?: citiesUpdateOneWithoutProvider_branchesNestedInput
    providers?: providersUpdateOneWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUpdateManyWithoutProvider_branchesNestedInput
  }

  export type provider_branchesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvider_branchesNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutProvider_branchesNestedInput
  }

  export type provider_branchesCreateManyInput = {
    id: string
    provider_id?: string | null
    city_id?: string | null
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
  }

  export type provider_branchesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type provider_branchesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type provider_catalogCreateInput = {
    id: string
    type?: string | null
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    is_available?: boolean | null
    image_url?: string | null
    providers?: providersCreateNestedOneWithoutProvider_catalogInput
  }

  export type provider_catalogUncheckedCreateInput = {
    id: string
    provider_id?: string | null
    type?: string | null
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    is_available?: boolean | null
    image_url?: string | null
  }

  export type provider_catalogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    providers?: providersUpdateOneWithoutProvider_catalogNestedInput
  }

  export type provider_catalogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type provider_catalogCreateManyInput = {
    id: string
    provider_id?: string | null
    type?: string | null
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    is_available?: boolean | null
    image_url?: string | null
  }

  export type provider_catalogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type provider_catalogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type provider_schedulesCreateInput = {
    id: string
    day_of_week?: number | null
    start_time?: Date | string | null
    end_time?: Date | string | null
    provider_branches?: provider_branchesCreateNestedOneWithoutProvider_schedulesInput
  }

  export type provider_schedulesUncheckedCreateInput = {
    id: string
    branch_id?: string | null
    day_of_week?: number | null
    start_time?: Date | string | null
    end_time?: Date | string | null
  }

  export type provider_schedulesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_branches?: provider_branchesUpdateOneWithoutProvider_schedulesNestedInput
  }

  export type provider_schedulesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_schedulesCreateManyInput = {
    id: string
    branch_id?: string | null
    day_of_week?: number | null
    start_time?: Date | string | null
    end_time?: Date | string | null
  }

  export type provider_schedulesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_schedulesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type providersCreateInput = {
    id: string
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyCreateNestedManyWithoutProvidersInput
    payouts?: payoutsCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogCreateNestedManyWithoutProvidersInput
    service_categories?: service_categoriesCreateNestedOneWithoutProvidersInput
    users?: usersCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateInput = {
    id: string
    user_id?: string | null
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutProvidersInput
    payouts?: payoutsUncheckedCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsUncheckedCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsUncheckedCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesUncheckedCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUpdateManyWithoutProvidersNestedInput
    service_categories?: service_categoriesUpdateOneWithoutProvidersNestedInput
    users?: usersUpdateOneWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUncheckedUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type providersCreateManyInput = {
    id: string
    user_id?: string | null
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
  }

  export type providersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type providersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type reviewsCreateInput = {
    id: string
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
    appointments?: appointmentsCreateNestedOneWithoutReviewsInput
    provider_branches?: provider_branchesCreateNestedOneWithoutReviewsInput
    patients?: patientsCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    appointment_id?: string | null
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
  }

  export type reviewsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateOneWithoutReviewsNestedInput
    provider_branches?: provider_branchesUpdateOneWithoutReviewsNestedInput
    patients?: patientsUpdateOneWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsCreateManyInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    appointment_id?: string | null
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
  }

  export type reviewsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type service_categoriesCreateInput = {
    name: string
    slug: string
    default_color_hex?: string | null
    allows_booking?: boolean | null
    providers?: providersCreateNestedManyWithoutService_categoriesInput
  }

  export type service_categoriesUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    default_color_hex?: string | null
    allows_booking?: boolean | null
    providers?: providersUncheckedCreateNestedManyWithoutService_categoriesInput
  }

  export type service_categoriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    default_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    allows_booking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    providers?: providersUpdateManyWithoutService_categoriesNestedInput
  }

  export type service_categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    default_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    allows_booking?: NullableBoolFieldUpdateOperationsInput | boolean | null
    providers?: providersUncheckedUpdateManyWithoutService_categoriesNestedInput
  }

  export type service_categoriesCreateManyInput = {
    id?: number
    name: string
    slug: string
    default_color_hex?: string | null
    allows_booking?: boolean | null
  }

  export type service_categoriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    default_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    allows_booking?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type service_categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    default_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    allows_booking?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type sessionsCreateInput = {
    id: string
    token: string
    device_info?: string | null
    expires_at: Date | string
    created_at?: Date | string | null
    users?: usersCreateNestedOneWithoutSessionsInput
  }

  export type sessionsUncheckedCreateInput = {
    id: string
    user_id?: string | null
    token: string
    device_info?: string | null
    expires_at: Date | string
    created_at?: Date | string | null
  }

  export type sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneWithoutSessionsNestedInput
  }

  export type sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsCreateManyInput = {
    id: string
    user_id?: string | null
    token: string
    device_info?: string | null
    expires_at: Date | string
    created_at?: Date | string | null
  }

  export type sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    token?: StringFieldUpdateOperationsInput | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    id: string
    email: string
    password_hash: string
    role?: $Enums.enum_roles | null
    profile_picture_url?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    patients?: patientsCreateNestedManyWithoutUsersInput
    providers?: providersCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id: string
    email: string
    password_hash: string
    role?: $Enums.enum_roles | null
    profile_picture_url?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    providers?: providersUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumenum_rolesFieldUpdateOperationsInput | $Enums.enum_roles | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUpdateManyWithoutUsersNestedInput
    providers?: providersUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumenum_rolesFieldUpdateOperationsInput | $Enums.enum_roles | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    providers?: providersUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id: string
    email: string
    password_hash: string
    role?: $Enums.enum_roles | null
    profile_picture_url?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumenum_rolesFieldUpdateOperationsInput | $Enums.enum_roles | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumenum_rolesFieldUpdateOperationsInput | $Enums.enum_roles | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type Provider_branchesNullableScalarRelationFilter = {
    is?: provider_branchesWhereInput | null
    isNot?: provider_branchesWhereInput | null
  }

  export type PatientsNullableScalarRelationFilter = {
    is?: patientsWhereInput | null
    isNot?: patientsWhereInput | null
  }

  export type ProvidersNullableScalarRelationFilter = {
    is?: providersWhereInput | null
    isNot?: providersWhereInput | null
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type ReviewsListRelationFilter = {
    every?: reviewsWhereInput
    some?: reviewsWhereInput
    none?: reviewsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reviewsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type appointmentsCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    branch_id?: SortOrder
    provider_id?: SortOrder
    scheduled_for?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    is_paid?: SortOrder
  }

  export type appointmentsMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    branch_id?: SortOrder
    provider_id?: SortOrder
    scheduled_for?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    is_paid?: SortOrder
  }

  export type appointmentsMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    branch_id?: SortOrder
    provider_id?: SortOrder
    scheduled_for?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    is_paid?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type Provider_branchesListRelationFilter = {
    every?: provider_branchesWhereInput
    some?: provider_branchesWhereInput
    none?: provider_branchesWhereInput
  }

  export type provider_branchesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type citiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    country?: SortOrder
  }

  export type citiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    country?: SortOrder
  }

  export type citiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    state?: SortOrder
    country?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type medical_historyCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    provider_id?: SortOrder
    doctor_name_snapshot?: SortOrder
    specialty_snapshot?: SortOrder
    diagnosis?: SortOrder
    date?: SortOrder
    treatment?: SortOrder
    indications?: SortOrder
    observations?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type medical_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    provider_id?: SortOrder
    doctor_name_snapshot?: SortOrder
    specialty_snapshot?: SortOrder
    diagnosis?: SortOrder
    date?: SortOrder
    treatment?: SortOrder
    indications?: SortOrder
    observations?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type medical_historyMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    provider_id?: SortOrder
    doctor_name_snapshot?: SortOrder
    specialty_snapshot?: SortOrder
    diagnosis?: SortOrder
    date?: SortOrder
    treatment?: SortOrder
    indications?: SortOrder
    observations?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type Enumenum_notif_typesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_notif_types | Enumenum_notif_typesFieldRefInput<$PrismaModel>
    in?: $Enums.enum_notif_types[] | ListEnumenum_notif_typesFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_notif_types[] | ListEnumenum_notif_typesFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_notif_typesFilter<$PrismaModel> | $Enums.enum_notif_types
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PatientsScalarRelationFilter = {
    is?: patientsWhereInput
    isNot?: patientsWhereInput
  }

  export type notificationsCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    is_read?: SortOrder
    data?: SortOrder
    created_at?: SortOrder
  }

  export type notificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type notificationsMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    is_read?: SortOrder
    created_at?: SortOrder
  }

  export type Enumenum_notif_typesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_notif_types | Enumenum_notif_typesFieldRefInput<$PrismaModel>
    in?: $Enums.enum_notif_types[] | ListEnumenum_notif_typesFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_notif_types[] | ListEnumenum_notif_typesFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_notif_typesWithAggregatesFilter<$PrismaModel> | $Enums.enum_notif_types
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_notif_typesFilter<$PrismaModel>
    _max?: NestedEnumenum_notif_typesFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type patient_favoritesCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
  }

  export type patient_favoritesMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
  }

  export type patient_favoritesMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    branch_id?: SortOrder
    created_at?: SortOrder
  }

  export type AppointmentsListRelationFilter = {
    every?: appointmentsWhereInput
    some?: appointmentsWhereInput
    none?: appointmentsWhereInput
  }

  export type Medical_historyListRelationFilter = {
    every?: medical_historyWhereInput
    some?: medical_historyWhereInput
    none?: medical_historyWhereInput
  }

  export type NotificationsListRelationFilter = {
    every?: notificationsWhereInput
    some?: notificationsWhereInput
    none?: notificationsWhereInput
  }

  export type Patient_favoritesListRelationFilter = {
    every?: patient_favoritesWhereInput
    some?: patient_favoritesWhereInput
    none?: patient_favoritesWhereInput
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type appointmentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type medical_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type patient_favoritesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type patientsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    identification?: SortOrder
    phone?: SortOrder
    birth_date?: SortOrder
    address_text?: SortOrder
  }

  export type patientsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    identification?: SortOrder
    phone?: SortOrder
    birth_date?: SortOrder
    address_text?: SortOrder
  }

  export type patientsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    full_name?: SortOrder
    identification?: SortOrder
    phone?: SortOrder
    birth_date?: SortOrder
    address_text?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type AppointmentsNullableScalarRelationFilter = {
    is?: appointmentsWhereInput | null
    isNot?: appointmentsWhereInput | null
  }

  export type PayoutsNullableScalarRelationFilter = {
    is?: payoutsWhereInput | null
    isNot?: payoutsWhereInput | null
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    appointment_id?: SortOrder
    payout_id?: SortOrder
    stripe_payment_intent_id?: SortOrder
    amount_total?: SortOrder
    platform_fee?: SortOrder
    provider_amount?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    amount_total?: SortOrder
    platform_fee?: SortOrder
    provider_amount?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    appointment_id?: SortOrder
    payout_id?: SortOrder
    stripe_payment_intent_id?: SortOrder
    amount_total?: SortOrder
    platform_fee?: SortOrder
    provider_amount?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    appointment_id?: SortOrder
    payout_id?: SortOrder
    stripe_payment_intent_id?: SortOrder
    amount_total?: SortOrder
    platform_fee?: SortOrder
    provider_amount?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    amount_total?: SortOrder
    platform_fee?: SortOrder
    provider_amount?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type payoutsCountOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    total_amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    reference_number?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    created_at?: SortOrder
  }

  export type payoutsAvgOrderByAggregateInput = {
    total_amount?: SortOrder
  }

  export type payoutsMaxOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    total_amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    reference_number?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    created_at?: SortOrder
  }

  export type payoutsMinOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    total_amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    reference_number?: SortOrder
    period_start?: SortOrder
    period_end?: SortOrder
    created_at?: SortOrder
  }

  export type payoutsSumOrderByAggregateInput = {
    total_amount?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type provider_adsCountOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    badge_text?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    image_url?: SortOrder
    action_text?: SortOrder
    bg_color_hex?: SortOrder
    accent_color_hex?: SortOrder
    target_screen?: SortOrder
    target_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    priority_order?: SortOrder
  }

  export type provider_adsAvgOrderByAggregateInput = {
    priority_order?: SortOrder
  }

  export type provider_adsMaxOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    badge_text?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    image_url?: SortOrder
    action_text?: SortOrder
    bg_color_hex?: SortOrder
    accent_color_hex?: SortOrder
    target_screen?: SortOrder
    target_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    priority_order?: SortOrder
  }

  export type provider_adsMinOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    badge_text?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    image_url?: SortOrder
    action_text?: SortOrder
    bg_color_hex?: SortOrder
    accent_color_hex?: SortOrder
    target_screen?: SortOrder
    target_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    is_active?: SortOrder
    priority_order?: SortOrder
  }

  export type provider_adsSumOrderByAggregateInput = {
    priority_order?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type provider_bank_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    account_type?: SortOrder
    account_holder_name?: SortOrder
    holder_identification?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
  }

  export type provider_bank_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    account_type?: SortOrder
    account_holder_name?: SortOrder
    holder_identification?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
  }

  export type provider_bank_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    bank_name?: SortOrder
    account_number?: SortOrder
    account_type?: SortOrder
    account_holder_name?: SortOrder
    holder_identification?: SortOrder
    is_verified?: SortOrder
    updated_at?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CitiesNullableScalarRelationFilter = {
    is?: citiesWhereInput | null
    isNot?: citiesWhereInput | null
  }

  export type Provider_schedulesListRelationFilter = {
    every?: provider_schedulesWhereInput
    some?: provider_schedulesWhereInput
    none?: provider_schedulesWhereInput
  }

  export type provider_schedulesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type provider_branchesCountOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    city_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address_text?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone_contact?: SortOrder
    email_contact?: SortOrder
    image_url?: SortOrder
    opening_hours_text?: SortOrder
    is_24h?: SortOrder
    has_delivery?: SortOrder
    rating_cache?: SortOrder
    is_main?: SortOrder
    is_active?: SortOrder
  }

  export type provider_branchesAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    rating_cache?: SortOrder
  }

  export type provider_branchesMaxOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    city_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address_text?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone_contact?: SortOrder
    email_contact?: SortOrder
    image_url?: SortOrder
    opening_hours_text?: SortOrder
    is_24h?: SortOrder
    has_delivery?: SortOrder
    rating_cache?: SortOrder
    is_main?: SortOrder
    is_active?: SortOrder
  }

  export type provider_branchesMinOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    city_id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    address_text?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    phone_contact?: SortOrder
    email_contact?: SortOrder
    image_url?: SortOrder
    opening_hours_text?: SortOrder
    is_24h?: SortOrder
    has_delivery?: SortOrder
    rating_cache?: SortOrder
    is_main?: SortOrder
    is_active?: SortOrder
  }

  export type provider_branchesSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    rating_cache?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type provider_catalogCountOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    is_available?: SortOrder
    image_url?: SortOrder
  }

  export type provider_catalogAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type provider_catalogMaxOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    is_available?: SortOrder
    image_url?: SortOrder
  }

  export type provider_catalogMinOrderByAggregateInput = {
    id?: SortOrder
    provider_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    is_available?: SortOrder
    image_url?: SortOrder
  }

  export type provider_catalogSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type provider_schedulesCountOrderByAggregateInput = {
    id?: SortOrder
    branch_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type provider_schedulesAvgOrderByAggregateInput = {
    day_of_week?: SortOrder
  }

  export type provider_schedulesMaxOrderByAggregateInput = {
    id?: SortOrder
    branch_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type provider_schedulesMinOrderByAggregateInput = {
    id?: SortOrder
    branch_id?: SortOrder
    day_of_week?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type provider_schedulesSumOrderByAggregateInput = {
    day_of_week?: SortOrder
  }

  export type PayoutsListRelationFilter = {
    every?: payoutsWhereInput
    some?: payoutsWhereInput
    none?: payoutsWhereInput
  }

  export type Provider_adsListRelationFilter = {
    every?: provider_adsWhereInput
    some?: provider_adsWhereInput
    none?: provider_adsWhereInput
  }

  export type Provider_bank_detailsListRelationFilter = {
    every?: provider_bank_detailsWhereInput
    some?: provider_bank_detailsWhereInput
    none?: provider_bank_detailsWhereInput
  }

  export type Provider_catalogListRelationFilter = {
    every?: provider_catalogWhereInput
    some?: provider_catalogWhereInput
    none?: provider_catalogWhereInput
  }

  export type Service_categoriesNullableScalarRelationFilter = {
    is?: service_categoriesWhereInput | null
    isNot?: service_categoriesWhereInput | null
  }

  export type payoutsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type provider_adsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type provider_bank_detailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type provider_catalogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type providersCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    category_id?: SortOrder
    commercial_name?: SortOrder
    logo_url?: SortOrder
    description?: SortOrder
    verification_status?: SortOrder
    commission_percentage?: SortOrder
  }

  export type providersAvgOrderByAggregateInput = {
    category_id?: SortOrder
    commission_percentage?: SortOrder
  }

  export type providersMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    category_id?: SortOrder
    commercial_name?: SortOrder
    logo_url?: SortOrder
    description?: SortOrder
    verification_status?: SortOrder
    commission_percentage?: SortOrder
  }

  export type providersMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    category_id?: SortOrder
    commercial_name?: SortOrder
    logo_url?: SortOrder
    description?: SortOrder
    verification_status?: SortOrder
    commission_percentage?: SortOrder
  }

  export type providersSumOrderByAggregateInput = {
    category_id?: SortOrder
    commission_percentage?: SortOrder
  }

  export type reviewsCountOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    branch_id?: SortOrder
    appointment_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
  }

  export type reviewsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type reviewsMaxOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    branch_id?: SortOrder
    appointment_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
  }

  export type reviewsMinOrderByAggregateInput = {
    id?: SortOrder
    patient_id?: SortOrder
    branch_id?: SortOrder
    appointment_id?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
  }

  export type reviewsSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ProvidersListRelationFilter = {
    every?: providersWhereInput
    some?: providersWhereInput
    none?: providersWhereInput
  }

  export type providersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type service_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    default_color_hex?: SortOrder
    allows_booking?: SortOrder
  }

  export type service_categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type service_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    default_color_hex?: SortOrder
    allows_booking?: SortOrder
  }

  export type service_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    default_color_hex?: SortOrder
    allows_booking?: SortOrder
  }

  export type service_categoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    device_info?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    device_info?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    token?: SortOrder
    device_info?: SortOrder
    expires_at?: SortOrder
    created_at?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Enumenum_rolesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_roles | Enumenum_rolesFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_roles[] | ListEnumenum_rolesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_roles[] | ListEnumenum_rolesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_rolesNullableFilter<$PrismaModel> | $Enums.enum_roles | null
  }

  export type PatientsListRelationFilter = {
    every?: patientsWhereInput
    some?: patientsWhereInput
    none?: patientsWhereInput
  }

  export type SessionsListRelationFilter = {
    every?: sessionsWhereInput
    some?: sessionsWhereInput
    none?: sessionsWhereInput
  }

  export type patientsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    profile_picture_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    profile_picture_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    role?: SortOrder
    profile_picture_url?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
  }

  export type Enumenum_rolesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_roles | Enumenum_rolesFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_roles[] | ListEnumenum_rolesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_roles[] | ListEnumenum_rolesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_rolesNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_roles | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_rolesNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_rolesNullableFilter<$PrismaModel>
  }

  export type provider_branchesCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<provider_branchesCreateWithoutAppointmentsInput, provider_branchesUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: provider_branchesCreateOrConnectWithoutAppointmentsInput
    connect?: provider_branchesWhereUniqueInput
  }

  export type patientsCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<patientsCreateWithoutAppointmentsInput, patientsUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutAppointmentsInput
    connect?: patientsWhereUniqueInput
  }

  export type providersCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<providersCreateWithoutAppointmentsInput, providersUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: providersCreateOrConnectWithoutAppointmentsInput
    connect?: providersWhereUniqueInput
  }

  export type paymentsCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<paymentsCreateWithoutAppointmentsInput, paymentsUncheckedCreateWithoutAppointmentsInput> | paymentsCreateWithoutAppointmentsInput[] | paymentsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutAppointmentsInput | paymentsCreateOrConnectWithoutAppointmentsInput[]
    createMany?: paymentsCreateManyAppointmentsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type reviewsCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<reviewsCreateWithoutAppointmentsInput, reviewsUncheckedCreateWithoutAppointmentsInput> | reviewsCreateWithoutAppointmentsInput[] | reviewsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutAppointmentsInput | reviewsCreateOrConnectWithoutAppointmentsInput[]
    createMany?: reviewsCreateManyAppointmentsInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<paymentsCreateWithoutAppointmentsInput, paymentsUncheckedCreateWithoutAppointmentsInput> | paymentsCreateWithoutAppointmentsInput[] | paymentsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutAppointmentsInput | paymentsCreateOrConnectWithoutAppointmentsInput[]
    createMany?: paymentsCreateManyAppointmentsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutAppointmentsInput = {
    create?: XOR<reviewsCreateWithoutAppointmentsInput, reviewsUncheckedCreateWithoutAppointmentsInput> | reviewsCreateWithoutAppointmentsInput[] | reviewsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutAppointmentsInput | reviewsCreateOrConnectWithoutAppointmentsInput[]
    createMany?: reviewsCreateManyAppointmentsInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type provider_branchesUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<provider_branchesCreateWithoutAppointmentsInput, provider_branchesUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: provider_branchesCreateOrConnectWithoutAppointmentsInput
    upsert?: provider_branchesUpsertWithoutAppointmentsInput
    disconnect?: provider_branchesWhereInput | boolean
    delete?: provider_branchesWhereInput | boolean
    connect?: provider_branchesWhereUniqueInput
    update?: XOR<XOR<provider_branchesUpdateToOneWithWhereWithoutAppointmentsInput, provider_branchesUpdateWithoutAppointmentsInput>, provider_branchesUncheckedUpdateWithoutAppointmentsInput>
  }

  export type patientsUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<patientsCreateWithoutAppointmentsInput, patientsUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutAppointmentsInput
    upsert?: patientsUpsertWithoutAppointmentsInput
    disconnect?: patientsWhereInput | boolean
    delete?: patientsWhereInput | boolean
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutAppointmentsInput, patientsUpdateWithoutAppointmentsInput>, patientsUncheckedUpdateWithoutAppointmentsInput>
  }

  export type providersUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<providersCreateWithoutAppointmentsInput, providersUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: providersCreateOrConnectWithoutAppointmentsInput
    upsert?: providersUpsertWithoutAppointmentsInput
    disconnect?: providersWhereInput | boolean
    delete?: providersWhereInput | boolean
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutAppointmentsInput, providersUpdateWithoutAppointmentsInput>, providersUncheckedUpdateWithoutAppointmentsInput>
  }

  export type paymentsUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<paymentsCreateWithoutAppointmentsInput, paymentsUncheckedCreateWithoutAppointmentsInput> | paymentsCreateWithoutAppointmentsInput[] | paymentsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutAppointmentsInput | paymentsCreateOrConnectWithoutAppointmentsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutAppointmentsInput | paymentsUpsertWithWhereUniqueWithoutAppointmentsInput[]
    createMany?: paymentsCreateManyAppointmentsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutAppointmentsInput | paymentsUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutAppointmentsInput | paymentsUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type reviewsUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<reviewsCreateWithoutAppointmentsInput, reviewsUncheckedCreateWithoutAppointmentsInput> | reviewsCreateWithoutAppointmentsInput[] | reviewsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutAppointmentsInput | reviewsCreateOrConnectWithoutAppointmentsInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutAppointmentsInput | reviewsUpsertWithWhereUniqueWithoutAppointmentsInput[]
    createMany?: reviewsCreateManyAppointmentsInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutAppointmentsInput | reviewsUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutAppointmentsInput | reviewsUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<paymentsCreateWithoutAppointmentsInput, paymentsUncheckedCreateWithoutAppointmentsInput> | paymentsCreateWithoutAppointmentsInput[] | paymentsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutAppointmentsInput | paymentsCreateOrConnectWithoutAppointmentsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutAppointmentsInput | paymentsUpsertWithWhereUniqueWithoutAppointmentsInput[]
    createMany?: paymentsCreateManyAppointmentsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutAppointmentsInput | paymentsUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutAppointmentsInput | paymentsUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutAppointmentsNestedInput = {
    create?: XOR<reviewsCreateWithoutAppointmentsInput, reviewsUncheckedCreateWithoutAppointmentsInput> | reviewsCreateWithoutAppointmentsInput[] | reviewsUncheckedCreateWithoutAppointmentsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutAppointmentsInput | reviewsCreateOrConnectWithoutAppointmentsInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutAppointmentsInput | reviewsUpsertWithWhereUniqueWithoutAppointmentsInput[]
    createMany?: reviewsCreateManyAppointmentsInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutAppointmentsInput | reviewsUpdateWithWhereUniqueWithoutAppointmentsInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutAppointmentsInput | reviewsUpdateManyWithWhereWithoutAppointmentsInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type provider_branchesCreateNestedManyWithoutCitiesInput = {
    create?: XOR<provider_branchesCreateWithoutCitiesInput, provider_branchesUncheckedCreateWithoutCitiesInput> | provider_branchesCreateWithoutCitiesInput[] | provider_branchesUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: provider_branchesCreateOrConnectWithoutCitiesInput | provider_branchesCreateOrConnectWithoutCitiesInput[]
    createMany?: provider_branchesCreateManyCitiesInputEnvelope
    connect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
  }

  export type provider_branchesUncheckedCreateNestedManyWithoutCitiesInput = {
    create?: XOR<provider_branchesCreateWithoutCitiesInput, provider_branchesUncheckedCreateWithoutCitiesInput> | provider_branchesCreateWithoutCitiesInput[] | provider_branchesUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: provider_branchesCreateOrConnectWithoutCitiesInput | provider_branchesCreateOrConnectWithoutCitiesInput[]
    createMany?: provider_branchesCreateManyCitiesInputEnvelope
    connect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
  }

  export type provider_branchesUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<provider_branchesCreateWithoutCitiesInput, provider_branchesUncheckedCreateWithoutCitiesInput> | provider_branchesCreateWithoutCitiesInput[] | provider_branchesUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: provider_branchesCreateOrConnectWithoutCitiesInput | provider_branchesCreateOrConnectWithoutCitiesInput[]
    upsert?: provider_branchesUpsertWithWhereUniqueWithoutCitiesInput | provider_branchesUpsertWithWhereUniqueWithoutCitiesInput[]
    createMany?: provider_branchesCreateManyCitiesInputEnvelope
    set?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    disconnect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    delete?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    connect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    update?: provider_branchesUpdateWithWhereUniqueWithoutCitiesInput | provider_branchesUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: provider_branchesUpdateManyWithWhereWithoutCitiesInput | provider_branchesUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: provider_branchesScalarWhereInput | provider_branchesScalarWhereInput[]
  }

  export type provider_branchesUncheckedUpdateManyWithoutCitiesNestedInput = {
    create?: XOR<provider_branchesCreateWithoutCitiesInput, provider_branchesUncheckedCreateWithoutCitiesInput> | provider_branchesCreateWithoutCitiesInput[] | provider_branchesUncheckedCreateWithoutCitiesInput[]
    connectOrCreate?: provider_branchesCreateOrConnectWithoutCitiesInput | provider_branchesCreateOrConnectWithoutCitiesInput[]
    upsert?: provider_branchesUpsertWithWhereUniqueWithoutCitiesInput | provider_branchesUpsertWithWhereUniqueWithoutCitiesInput[]
    createMany?: provider_branchesCreateManyCitiesInputEnvelope
    set?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    disconnect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    delete?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    connect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    update?: provider_branchesUpdateWithWhereUniqueWithoutCitiesInput | provider_branchesUpdateWithWhereUniqueWithoutCitiesInput[]
    updateMany?: provider_branchesUpdateManyWithWhereWithoutCitiesInput | provider_branchesUpdateManyWithWhereWithoutCitiesInput[]
    deleteMany?: provider_branchesScalarWhereInput | provider_branchesScalarWhereInput[]
  }

  export type patientsCreateNestedOneWithoutMedical_historyInput = {
    create?: XOR<patientsCreateWithoutMedical_historyInput, patientsUncheckedCreateWithoutMedical_historyInput>
    connectOrCreate?: patientsCreateOrConnectWithoutMedical_historyInput
    connect?: patientsWhereUniqueInput
  }

  export type providersCreateNestedOneWithoutMedical_historyInput = {
    create?: XOR<providersCreateWithoutMedical_historyInput, providersUncheckedCreateWithoutMedical_historyInput>
    connectOrCreate?: providersCreateOrConnectWithoutMedical_historyInput
    connect?: providersWhereUniqueInput
  }

  export type patientsUpdateOneWithoutMedical_historyNestedInput = {
    create?: XOR<patientsCreateWithoutMedical_historyInput, patientsUncheckedCreateWithoutMedical_historyInput>
    connectOrCreate?: patientsCreateOrConnectWithoutMedical_historyInput
    upsert?: patientsUpsertWithoutMedical_historyInput
    disconnect?: patientsWhereInput | boolean
    delete?: patientsWhereInput | boolean
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutMedical_historyInput, patientsUpdateWithoutMedical_historyInput>, patientsUncheckedUpdateWithoutMedical_historyInput>
  }

  export type providersUpdateOneWithoutMedical_historyNestedInput = {
    create?: XOR<providersCreateWithoutMedical_historyInput, providersUncheckedCreateWithoutMedical_historyInput>
    connectOrCreate?: providersCreateOrConnectWithoutMedical_historyInput
    upsert?: providersUpsertWithoutMedical_historyInput
    disconnect?: providersWhereInput | boolean
    delete?: providersWhereInput | boolean
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutMedical_historyInput, providersUpdateWithoutMedical_historyInput>, providersUncheckedUpdateWithoutMedical_historyInput>
  }

  export type patientsCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<patientsCreateWithoutNotificationsInput, patientsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutNotificationsInput
    connect?: patientsWhereUniqueInput
  }

  export type Enumenum_notif_typesFieldUpdateOperationsInput = {
    set?: $Enums.enum_notif_types
  }

  export type patientsUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<patientsCreateWithoutNotificationsInput, patientsUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutNotificationsInput
    upsert?: patientsUpsertWithoutNotificationsInput
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutNotificationsInput, patientsUpdateWithoutNotificationsInput>, patientsUncheckedUpdateWithoutNotificationsInput>
  }

  export type provider_branchesCreateNestedOneWithoutPatient_favoritesInput = {
    create?: XOR<provider_branchesCreateWithoutPatient_favoritesInput, provider_branchesUncheckedCreateWithoutPatient_favoritesInput>
    connectOrCreate?: provider_branchesCreateOrConnectWithoutPatient_favoritesInput
    connect?: provider_branchesWhereUniqueInput
  }

  export type patientsCreateNestedOneWithoutPatient_favoritesInput = {
    create?: XOR<patientsCreateWithoutPatient_favoritesInput, patientsUncheckedCreateWithoutPatient_favoritesInput>
    connectOrCreate?: patientsCreateOrConnectWithoutPatient_favoritesInput
    connect?: patientsWhereUniqueInput
  }

  export type provider_branchesUpdateOneWithoutPatient_favoritesNestedInput = {
    create?: XOR<provider_branchesCreateWithoutPatient_favoritesInput, provider_branchesUncheckedCreateWithoutPatient_favoritesInput>
    connectOrCreate?: provider_branchesCreateOrConnectWithoutPatient_favoritesInput
    upsert?: provider_branchesUpsertWithoutPatient_favoritesInput
    disconnect?: provider_branchesWhereInput | boolean
    delete?: provider_branchesWhereInput | boolean
    connect?: provider_branchesWhereUniqueInput
    update?: XOR<XOR<provider_branchesUpdateToOneWithWhereWithoutPatient_favoritesInput, provider_branchesUpdateWithoutPatient_favoritesInput>, provider_branchesUncheckedUpdateWithoutPatient_favoritesInput>
  }

  export type patientsUpdateOneWithoutPatient_favoritesNestedInput = {
    create?: XOR<patientsCreateWithoutPatient_favoritesInput, patientsUncheckedCreateWithoutPatient_favoritesInput>
    connectOrCreate?: patientsCreateOrConnectWithoutPatient_favoritesInput
    upsert?: patientsUpsertWithoutPatient_favoritesInput
    disconnect?: patientsWhereInput | boolean
    delete?: patientsWhereInput | boolean
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutPatient_favoritesInput, patientsUpdateWithoutPatient_favoritesInput>, patientsUncheckedUpdateWithoutPatient_favoritesInput>
  }

  export type appointmentsCreateNestedManyWithoutPatientsInput = {
    create?: XOR<appointmentsCreateWithoutPatientsInput, appointmentsUncheckedCreateWithoutPatientsInput> | appointmentsCreateWithoutPatientsInput[] | appointmentsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutPatientsInput | appointmentsCreateOrConnectWithoutPatientsInput[]
    createMany?: appointmentsCreateManyPatientsInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type medical_historyCreateNestedManyWithoutPatientsInput = {
    create?: XOR<medical_historyCreateWithoutPatientsInput, medical_historyUncheckedCreateWithoutPatientsInput> | medical_historyCreateWithoutPatientsInput[] | medical_historyUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: medical_historyCreateOrConnectWithoutPatientsInput | medical_historyCreateOrConnectWithoutPatientsInput[]
    createMany?: medical_historyCreateManyPatientsInputEnvelope
    connect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
  }

  export type notificationsCreateNestedManyWithoutPatientsInput = {
    create?: XOR<notificationsCreateWithoutPatientsInput, notificationsUncheckedCreateWithoutPatientsInput> | notificationsCreateWithoutPatientsInput[] | notificationsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutPatientsInput | notificationsCreateOrConnectWithoutPatientsInput[]
    createMany?: notificationsCreateManyPatientsInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type patient_favoritesCreateNestedManyWithoutPatientsInput = {
    create?: XOR<patient_favoritesCreateWithoutPatientsInput, patient_favoritesUncheckedCreateWithoutPatientsInput> | patient_favoritesCreateWithoutPatientsInput[] | patient_favoritesUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_favoritesCreateOrConnectWithoutPatientsInput | patient_favoritesCreateOrConnectWithoutPatientsInput[]
    createMany?: patient_favoritesCreateManyPatientsInputEnvelope
    connect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
  }

  export type usersCreateNestedOneWithoutPatientsInput = {
    create?: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPatientsInput
    connect?: usersWhereUniqueInput
  }

  export type reviewsCreateNestedManyWithoutPatientsInput = {
    create?: XOR<reviewsCreateWithoutPatientsInput, reviewsUncheckedCreateWithoutPatientsInput> | reviewsCreateWithoutPatientsInput[] | reviewsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutPatientsInput | reviewsCreateOrConnectWithoutPatientsInput[]
    createMany?: reviewsCreateManyPatientsInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type appointmentsUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<appointmentsCreateWithoutPatientsInput, appointmentsUncheckedCreateWithoutPatientsInput> | appointmentsCreateWithoutPatientsInput[] | appointmentsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutPatientsInput | appointmentsCreateOrConnectWithoutPatientsInput[]
    createMany?: appointmentsCreateManyPatientsInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type medical_historyUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<medical_historyCreateWithoutPatientsInput, medical_historyUncheckedCreateWithoutPatientsInput> | medical_historyCreateWithoutPatientsInput[] | medical_historyUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: medical_historyCreateOrConnectWithoutPatientsInput | medical_historyCreateOrConnectWithoutPatientsInput[]
    createMany?: medical_historyCreateManyPatientsInputEnvelope
    connect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
  }

  export type notificationsUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<notificationsCreateWithoutPatientsInput, notificationsUncheckedCreateWithoutPatientsInput> | notificationsCreateWithoutPatientsInput[] | notificationsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutPatientsInput | notificationsCreateOrConnectWithoutPatientsInput[]
    createMany?: notificationsCreateManyPatientsInputEnvelope
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
  }

  export type patient_favoritesUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<patient_favoritesCreateWithoutPatientsInput, patient_favoritesUncheckedCreateWithoutPatientsInput> | patient_favoritesCreateWithoutPatientsInput[] | patient_favoritesUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_favoritesCreateOrConnectWithoutPatientsInput | patient_favoritesCreateOrConnectWithoutPatientsInput[]
    createMany?: patient_favoritesCreateManyPatientsInputEnvelope
    connect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutPatientsInput = {
    create?: XOR<reviewsCreateWithoutPatientsInput, reviewsUncheckedCreateWithoutPatientsInput> | reviewsCreateWithoutPatientsInput[] | reviewsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutPatientsInput | reviewsCreateOrConnectWithoutPatientsInput[]
    createMany?: reviewsCreateManyPatientsInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type appointmentsUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<appointmentsCreateWithoutPatientsInput, appointmentsUncheckedCreateWithoutPatientsInput> | appointmentsCreateWithoutPatientsInput[] | appointmentsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutPatientsInput | appointmentsCreateOrConnectWithoutPatientsInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutPatientsInput | appointmentsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: appointmentsCreateManyPatientsInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutPatientsInput | appointmentsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutPatientsInput | appointmentsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type medical_historyUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<medical_historyCreateWithoutPatientsInput, medical_historyUncheckedCreateWithoutPatientsInput> | medical_historyCreateWithoutPatientsInput[] | medical_historyUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: medical_historyCreateOrConnectWithoutPatientsInput | medical_historyCreateOrConnectWithoutPatientsInput[]
    upsert?: medical_historyUpsertWithWhereUniqueWithoutPatientsInput | medical_historyUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: medical_historyCreateManyPatientsInputEnvelope
    set?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    disconnect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    delete?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    connect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    update?: medical_historyUpdateWithWhereUniqueWithoutPatientsInput | medical_historyUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: medical_historyUpdateManyWithWhereWithoutPatientsInput | medical_historyUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: medical_historyScalarWhereInput | medical_historyScalarWhereInput[]
  }

  export type notificationsUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<notificationsCreateWithoutPatientsInput, notificationsUncheckedCreateWithoutPatientsInput> | notificationsCreateWithoutPatientsInput[] | notificationsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutPatientsInput | notificationsCreateOrConnectWithoutPatientsInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutPatientsInput | notificationsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: notificationsCreateManyPatientsInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutPatientsInput | notificationsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutPatientsInput | notificationsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type patient_favoritesUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<patient_favoritesCreateWithoutPatientsInput, patient_favoritesUncheckedCreateWithoutPatientsInput> | patient_favoritesCreateWithoutPatientsInput[] | patient_favoritesUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_favoritesCreateOrConnectWithoutPatientsInput | patient_favoritesCreateOrConnectWithoutPatientsInput[]
    upsert?: patient_favoritesUpsertWithWhereUniqueWithoutPatientsInput | patient_favoritesUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: patient_favoritesCreateManyPatientsInputEnvelope
    set?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    disconnect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    delete?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    connect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    update?: patient_favoritesUpdateWithWhereUniqueWithoutPatientsInput | patient_favoritesUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: patient_favoritesUpdateManyWithWhereWithoutPatientsInput | patient_favoritesUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: patient_favoritesScalarWhereInput | patient_favoritesScalarWhereInput[]
  }

  export type usersUpdateOneWithoutPatientsNestedInput = {
    create?: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPatientsInput
    upsert?: usersUpsertWithoutPatientsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPatientsInput, usersUpdateWithoutPatientsInput>, usersUncheckedUpdateWithoutPatientsInput>
  }

  export type reviewsUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<reviewsCreateWithoutPatientsInput, reviewsUncheckedCreateWithoutPatientsInput> | reviewsCreateWithoutPatientsInput[] | reviewsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutPatientsInput | reviewsCreateOrConnectWithoutPatientsInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutPatientsInput | reviewsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: reviewsCreateManyPatientsInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutPatientsInput | reviewsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutPatientsInput | reviewsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type appointmentsUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<appointmentsCreateWithoutPatientsInput, appointmentsUncheckedCreateWithoutPatientsInput> | appointmentsCreateWithoutPatientsInput[] | appointmentsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutPatientsInput | appointmentsCreateOrConnectWithoutPatientsInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutPatientsInput | appointmentsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: appointmentsCreateManyPatientsInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutPatientsInput | appointmentsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutPatientsInput | appointmentsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type medical_historyUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<medical_historyCreateWithoutPatientsInput, medical_historyUncheckedCreateWithoutPatientsInput> | medical_historyCreateWithoutPatientsInput[] | medical_historyUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: medical_historyCreateOrConnectWithoutPatientsInput | medical_historyCreateOrConnectWithoutPatientsInput[]
    upsert?: medical_historyUpsertWithWhereUniqueWithoutPatientsInput | medical_historyUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: medical_historyCreateManyPatientsInputEnvelope
    set?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    disconnect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    delete?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    connect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    update?: medical_historyUpdateWithWhereUniqueWithoutPatientsInput | medical_historyUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: medical_historyUpdateManyWithWhereWithoutPatientsInput | medical_historyUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: medical_historyScalarWhereInput | medical_historyScalarWhereInput[]
  }

  export type notificationsUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<notificationsCreateWithoutPatientsInput, notificationsUncheckedCreateWithoutPatientsInput> | notificationsCreateWithoutPatientsInput[] | notificationsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: notificationsCreateOrConnectWithoutPatientsInput | notificationsCreateOrConnectWithoutPatientsInput[]
    upsert?: notificationsUpsertWithWhereUniqueWithoutPatientsInput | notificationsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: notificationsCreateManyPatientsInputEnvelope
    set?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    disconnect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    delete?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    connect?: notificationsWhereUniqueInput | notificationsWhereUniqueInput[]
    update?: notificationsUpdateWithWhereUniqueWithoutPatientsInput | notificationsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: notificationsUpdateManyWithWhereWithoutPatientsInput | notificationsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
  }

  export type patient_favoritesUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<patient_favoritesCreateWithoutPatientsInput, patient_favoritesUncheckedCreateWithoutPatientsInput> | patient_favoritesCreateWithoutPatientsInput[] | patient_favoritesUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: patient_favoritesCreateOrConnectWithoutPatientsInput | patient_favoritesCreateOrConnectWithoutPatientsInput[]
    upsert?: patient_favoritesUpsertWithWhereUniqueWithoutPatientsInput | patient_favoritesUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: patient_favoritesCreateManyPatientsInputEnvelope
    set?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    disconnect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    delete?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    connect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    update?: patient_favoritesUpdateWithWhereUniqueWithoutPatientsInput | patient_favoritesUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: patient_favoritesUpdateManyWithWhereWithoutPatientsInput | patient_favoritesUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: patient_favoritesScalarWhereInput | patient_favoritesScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutPatientsNestedInput = {
    create?: XOR<reviewsCreateWithoutPatientsInput, reviewsUncheckedCreateWithoutPatientsInput> | reviewsCreateWithoutPatientsInput[] | reviewsUncheckedCreateWithoutPatientsInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutPatientsInput | reviewsCreateOrConnectWithoutPatientsInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutPatientsInput | reviewsUpsertWithWhereUniqueWithoutPatientsInput[]
    createMany?: reviewsCreateManyPatientsInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutPatientsInput | reviewsUpdateWithWhereUniqueWithoutPatientsInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutPatientsInput | reviewsUpdateManyWithWhereWithoutPatientsInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type appointmentsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<appointmentsCreateWithoutPaymentsInput, appointmentsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: appointmentsCreateOrConnectWithoutPaymentsInput
    connect?: appointmentsWhereUniqueInput
  }

  export type payoutsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<payoutsCreateWithoutPaymentsInput, payoutsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: payoutsCreateOrConnectWithoutPaymentsInput
    connect?: payoutsWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type appointmentsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<appointmentsCreateWithoutPaymentsInput, appointmentsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: appointmentsCreateOrConnectWithoutPaymentsInput
    upsert?: appointmentsUpsertWithoutPaymentsInput
    disconnect?: appointmentsWhereInput | boolean
    delete?: appointmentsWhereInput | boolean
    connect?: appointmentsWhereUniqueInput
    update?: XOR<XOR<appointmentsUpdateToOneWithWhereWithoutPaymentsInput, appointmentsUpdateWithoutPaymentsInput>, appointmentsUncheckedUpdateWithoutPaymentsInput>
  }

  export type payoutsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<payoutsCreateWithoutPaymentsInput, payoutsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: payoutsCreateOrConnectWithoutPaymentsInput
    upsert?: payoutsUpsertWithoutPaymentsInput
    disconnect?: payoutsWhereInput | boolean
    delete?: payoutsWhereInput | boolean
    connect?: payoutsWhereUniqueInput
    update?: XOR<XOR<payoutsUpdateToOneWithWhereWithoutPaymentsInput, payoutsUpdateWithoutPaymentsInput>, payoutsUncheckedUpdateWithoutPaymentsInput>
  }

  export type paymentsCreateNestedManyWithoutPayoutsInput = {
    create?: XOR<paymentsCreateWithoutPayoutsInput, paymentsUncheckedCreateWithoutPayoutsInput> | paymentsCreateWithoutPayoutsInput[] | paymentsUncheckedCreateWithoutPayoutsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayoutsInput | paymentsCreateOrConnectWithoutPayoutsInput[]
    createMany?: paymentsCreateManyPayoutsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type providersCreateNestedOneWithoutPayoutsInput = {
    create?: XOR<providersCreateWithoutPayoutsInput, providersUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: providersCreateOrConnectWithoutPayoutsInput
    connect?: providersWhereUniqueInput
  }

  export type paymentsUncheckedCreateNestedManyWithoutPayoutsInput = {
    create?: XOR<paymentsCreateWithoutPayoutsInput, paymentsUncheckedCreateWithoutPayoutsInput> | paymentsCreateWithoutPayoutsInput[] | paymentsUncheckedCreateWithoutPayoutsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayoutsInput | paymentsCreateOrConnectWithoutPayoutsInput[]
    createMany?: paymentsCreateManyPayoutsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type paymentsUpdateManyWithoutPayoutsNestedInput = {
    create?: XOR<paymentsCreateWithoutPayoutsInput, paymentsUncheckedCreateWithoutPayoutsInput> | paymentsCreateWithoutPayoutsInput[] | paymentsUncheckedCreateWithoutPayoutsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayoutsInput | paymentsCreateOrConnectWithoutPayoutsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutPayoutsInput | paymentsUpsertWithWhereUniqueWithoutPayoutsInput[]
    createMany?: paymentsCreateManyPayoutsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutPayoutsInput | paymentsUpdateWithWhereUniqueWithoutPayoutsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutPayoutsInput | paymentsUpdateManyWithWhereWithoutPayoutsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type providersUpdateOneWithoutPayoutsNestedInput = {
    create?: XOR<providersCreateWithoutPayoutsInput, providersUncheckedCreateWithoutPayoutsInput>
    connectOrCreate?: providersCreateOrConnectWithoutPayoutsInput
    upsert?: providersUpsertWithoutPayoutsInput
    disconnect?: providersWhereInput | boolean
    delete?: providersWhereInput | boolean
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutPayoutsInput, providersUpdateWithoutPayoutsInput>, providersUncheckedUpdateWithoutPayoutsInput>
  }

  export type paymentsUncheckedUpdateManyWithoutPayoutsNestedInput = {
    create?: XOR<paymentsCreateWithoutPayoutsInput, paymentsUncheckedCreateWithoutPayoutsInput> | paymentsCreateWithoutPayoutsInput[] | paymentsUncheckedCreateWithoutPayoutsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutPayoutsInput | paymentsCreateOrConnectWithoutPayoutsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutPayoutsInput | paymentsUpsertWithWhereUniqueWithoutPayoutsInput[]
    createMany?: paymentsCreateManyPayoutsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutPayoutsInput | paymentsUpdateWithWhereUniqueWithoutPayoutsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutPayoutsInput | paymentsUpdateManyWithWhereWithoutPayoutsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type providersCreateNestedOneWithoutProvider_adsInput = {
    create?: XOR<providersCreateWithoutProvider_adsInput, providersUncheckedCreateWithoutProvider_adsInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_adsInput
    connect?: providersWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type providersUpdateOneWithoutProvider_adsNestedInput = {
    create?: XOR<providersCreateWithoutProvider_adsInput, providersUncheckedCreateWithoutProvider_adsInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_adsInput
    upsert?: providersUpsertWithoutProvider_adsInput
    disconnect?: providersWhereInput | boolean
    delete?: providersWhereInput | boolean
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutProvider_adsInput, providersUpdateWithoutProvider_adsInput>, providersUncheckedUpdateWithoutProvider_adsInput>
  }

  export type providersCreateNestedOneWithoutProvider_bank_detailsInput = {
    create?: XOR<providersCreateWithoutProvider_bank_detailsInput, providersUncheckedCreateWithoutProvider_bank_detailsInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_bank_detailsInput
    connect?: providersWhereUniqueInput
  }

  export type providersUpdateOneWithoutProvider_bank_detailsNestedInput = {
    create?: XOR<providersCreateWithoutProvider_bank_detailsInput, providersUncheckedCreateWithoutProvider_bank_detailsInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_bank_detailsInput
    upsert?: providersUpsertWithoutProvider_bank_detailsInput
    disconnect?: providersWhereInput | boolean
    delete?: providersWhereInput | boolean
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutProvider_bank_detailsInput, providersUpdateWithoutProvider_bank_detailsInput>, providersUncheckedUpdateWithoutProvider_bank_detailsInput>
  }

  export type appointmentsCreateNestedManyWithoutProvider_branchesInput = {
    create?: XOR<appointmentsCreateWithoutProvider_branchesInput, appointmentsUncheckedCreateWithoutProvider_branchesInput> | appointmentsCreateWithoutProvider_branchesInput[] | appointmentsUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutProvider_branchesInput | appointmentsCreateOrConnectWithoutProvider_branchesInput[]
    createMany?: appointmentsCreateManyProvider_branchesInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type patient_favoritesCreateNestedManyWithoutProvider_branchesInput = {
    create?: XOR<patient_favoritesCreateWithoutProvider_branchesInput, patient_favoritesUncheckedCreateWithoutProvider_branchesInput> | patient_favoritesCreateWithoutProvider_branchesInput[] | patient_favoritesUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: patient_favoritesCreateOrConnectWithoutProvider_branchesInput | patient_favoritesCreateOrConnectWithoutProvider_branchesInput[]
    createMany?: patient_favoritesCreateManyProvider_branchesInputEnvelope
    connect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
  }

  export type citiesCreateNestedOneWithoutProvider_branchesInput = {
    create?: XOR<citiesCreateWithoutProvider_branchesInput, citiesUncheckedCreateWithoutProvider_branchesInput>
    connectOrCreate?: citiesCreateOrConnectWithoutProvider_branchesInput
    connect?: citiesWhereUniqueInput
  }

  export type providersCreateNestedOneWithoutProvider_branchesInput = {
    create?: XOR<providersCreateWithoutProvider_branchesInput, providersUncheckedCreateWithoutProvider_branchesInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_branchesInput
    connect?: providersWhereUniqueInput
  }

  export type provider_schedulesCreateNestedManyWithoutProvider_branchesInput = {
    create?: XOR<provider_schedulesCreateWithoutProvider_branchesInput, provider_schedulesUncheckedCreateWithoutProvider_branchesInput> | provider_schedulesCreateWithoutProvider_branchesInput[] | provider_schedulesUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: provider_schedulesCreateOrConnectWithoutProvider_branchesInput | provider_schedulesCreateOrConnectWithoutProvider_branchesInput[]
    createMany?: provider_schedulesCreateManyProvider_branchesInputEnvelope
    connect?: provider_schedulesWhereUniqueInput | provider_schedulesWhereUniqueInput[]
  }

  export type reviewsCreateNestedManyWithoutProvider_branchesInput = {
    create?: XOR<reviewsCreateWithoutProvider_branchesInput, reviewsUncheckedCreateWithoutProvider_branchesInput> | reviewsCreateWithoutProvider_branchesInput[] | reviewsUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutProvider_branchesInput | reviewsCreateOrConnectWithoutProvider_branchesInput[]
    createMany?: reviewsCreateManyProvider_branchesInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type appointmentsUncheckedCreateNestedManyWithoutProvider_branchesInput = {
    create?: XOR<appointmentsCreateWithoutProvider_branchesInput, appointmentsUncheckedCreateWithoutProvider_branchesInput> | appointmentsCreateWithoutProvider_branchesInput[] | appointmentsUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutProvider_branchesInput | appointmentsCreateOrConnectWithoutProvider_branchesInput[]
    createMany?: appointmentsCreateManyProvider_branchesInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type patient_favoritesUncheckedCreateNestedManyWithoutProvider_branchesInput = {
    create?: XOR<patient_favoritesCreateWithoutProvider_branchesInput, patient_favoritesUncheckedCreateWithoutProvider_branchesInput> | patient_favoritesCreateWithoutProvider_branchesInput[] | patient_favoritesUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: patient_favoritesCreateOrConnectWithoutProvider_branchesInput | patient_favoritesCreateOrConnectWithoutProvider_branchesInput[]
    createMany?: patient_favoritesCreateManyProvider_branchesInputEnvelope
    connect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
  }

  export type provider_schedulesUncheckedCreateNestedManyWithoutProvider_branchesInput = {
    create?: XOR<provider_schedulesCreateWithoutProvider_branchesInput, provider_schedulesUncheckedCreateWithoutProvider_branchesInput> | provider_schedulesCreateWithoutProvider_branchesInput[] | provider_schedulesUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: provider_schedulesCreateOrConnectWithoutProvider_branchesInput | provider_schedulesCreateOrConnectWithoutProvider_branchesInput[]
    createMany?: provider_schedulesCreateManyProvider_branchesInputEnvelope
    connect?: provider_schedulesWhereUniqueInput | provider_schedulesWhereUniqueInput[]
  }

  export type reviewsUncheckedCreateNestedManyWithoutProvider_branchesInput = {
    create?: XOR<reviewsCreateWithoutProvider_branchesInput, reviewsUncheckedCreateWithoutProvider_branchesInput> | reviewsCreateWithoutProvider_branchesInput[] | reviewsUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutProvider_branchesInput | reviewsCreateOrConnectWithoutProvider_branchesInput[]
    createMany?: reviewsCreateManyProvider_branchesInputEnvelope
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type appointmentsUpdateManyWithoutProvider_branchesNestedInput = {
    create?: XOR<appointmentsCreateWithoutProvider_branchesInput, appointmentsUncheckedCreateWithoutProvider_branchesInput> | appointmentsCreateWithoutProvider_branchesInput[] | appointmentsUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutProvider_branchesInput | appointmentsCreateOrConnectWithoutProvider_branchesInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutProvider_branchesInput | appointmentsUpsertWithWhereUniqueWithoutProvider_branchesInput[]
    createMany?: appointmentsCreateManyProvider_branchesInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutProvider_branchesInput | appointmentsUpdateWithWhereUniqueWithoutProvider_branchesInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutProvider_branchesInput | appointmentsUpdateManyWithWhereWithoutProvider_branchesInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type patient_favoritesUpdateManyWithoutProvider_branchesNestedInput = {
    create?: XOR<patient_favoritesCreateWithoutProvider_branchesInput, patient_favoritesUncheckedCreateWithoutProvider_branchesInput> | patient_favoritesCreateWithoutProvider_branchesInput[] | patient_favoritesUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: patient_favoritesCreateOrConnectWithoutProvider_branchesInput | patient_favoritesCreateOrConnectWithoutProvider_branchesInput[]
    upsert?: patient_favoritesUpsertWithWhereUniqueWithoutProvider_branchesInput | patient_favoritesUpsertWithWhereUniqueWithoutProvider_branchesInput[]
    createMany?: patient_favoritesCreateManyProvider_branchesInputEnvelope
    set?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    disconnect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    delete?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    connect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    update?: patient_favoritesUpdateWithWhereUniqueWithoutProvider_branchesInput | patient_favoritesUpdateWithWhereUniqueWithoutProvider_branchesInput[]
    updateMany?: patient_favoritesUpdateManyWithWhereWithoutProvider_branchesInput | patient_favoritesUpdateManyWithWhereWithoutProvider_branchesInput[]
    deleteMany?: patient_favoritesScalarWhereInput | patient_favoritesScalarWhereInput[]
  }

  export type citiesUpdateOneWithoutProvider_branchesNestedInput = {
    create?: XOR<citiesCreateWithoutProvider_branchesInput, citiesUncheckedCreateWithoutProvider_branchesInput>
    connectOrCreate?: citiesCreateOrConnectWithoutProvider_branchesInput
    upsert?: citiesUpsertWithoutProvider_branchesInput
    disconnect?: citiesWhereInput | boolean
    delete?: citiesWhereInput | boolean
    connect?: citiesWhereUniqueInput
    update?: XOR<XOR<citiesUpdateToOneWithWhereWithoutProvider_branchesInput, citiesUpdateWithoutProvider_branchesInput>, citiesUncheckedUpdateWithoutProvider_branchesInput>
  }

  export type providersUpdateOneWithoutProvider_branchesNestedInput = {
    create?: XOR<providersCreateWithoutProvider_branchesInput, providersUncheckedCreateWithoutProvider_branchesInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_branchesInput
    upsert?: providersUpsertWithoutProvider_branchesInput
    disconnect?: providersWhereInput | boolean
    delete?: providersWhereInput | boolean
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutProvider_branchesInput, providersUpdateWithoutProvider_branchesInput>, providersUncheckedUpdateWithoutProvider_branchesInput>
  }

  export type provider_schedulesUpdateManyWithoutProvider_branchesNestedInput = {
    create?: XOR<provider_schedulesCreateWithoutProvider_branchesInput, provider_schedulesUncheckedCreateWithoutProvider_branchesInput> | provider_schedulesCreateWithoutProvider_branchesInput[] | provider_schedulesUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: provider_schedulesCreateOrConnectWithoutProvider_branchesInput | provider_schedulesCreateOrConnectWithoutProvider_branchesInput[]
    upsert?: provider_schedulesUpsertWithWhereUniqueWithoutProvider_branchesInput | provider_schedulesUpsertWithWhereUniqueWithoutProvider_branchesInput[]
    createMany?: provider_schedulesCreateManyProvider_branchesInputEnvelope
    set?: provider_schedulesWhereUniqueInput | provider_schedulesWhereUniqueInput[]
    disconnect?: provider_schedulesWhereUniqueInput | provider_schedulesWhereUniqueInput[]
    delete?: provider_schedulesWhereUniqueInput | provider_schedulesWhereUniqueInput[]
    connect?: provider_schedulesWhereUniqueInput | provider_schedulesWhereUniqueInput[]
    update?: provider_schedulesUpdateWithWhereUniqueWithoutProvider_branchesInput | provider_schedulesUpdateWithWhereUniqueWithoutProvider_branchesInput[]
    updateMany?: provider_schedulesUpdateManyWithWhereWithoutProvider_branchesInput | provider_schedulesUpdateManyWithWhereWithoutProvider_branchesInput[]
    deleteMany?: provider_schedulesScalarWhereInput | provider_schedulesScalarWhereInput[]
  }

  export type reviewsUpdateManyWithoutProvider_branchesNestedInput = {
    create?: XOR<reviewsCreateWithoutProvider_branchesInput, reviewsUncheckedCreateWithoutProvider_branchesInput> | reviewsCreateWithoutProvider_branchesInput[] | reviewsUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutProvider_branchesInput | reviewsCreateOrConnectWithoutProvider_branchesInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutProvider_branchesInput | reviewsUpsertWithWhereUniqueWithoutProvider_branchesInput[]
    createMany?: reviewsCreateManyProvider_branchesInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutProvider_branchesInput | reviewsUpdateWithWhereUniqueWithoutProvider_branchesInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutProvider_branchesInput | reviewsUpdateManyWithWhereWithoutProvider_branchesInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type appointmentsUncheckedUpdateManyWithoutProvider_branchesNestedInput = {
    create?: XOR<appointmentsCreateWithoutProvider_branchesInput, appointmentsUncheckedCreateWithoutProvider_branchesInput> | appointmentsCreateWithoutProvider_branchesInput[] | appointmentsUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutProvider_branchesInput | appointmentsCreateOrConnectWithoutProvider_branchesInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutProvider_branchesInput | appointmentsUpsertWithWhereUniqueWithoutProvider_branchesInput[]
    createMany?: appointmentsCreateManyProvider_branchesInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutProvider_branchesInput | appointmentsUpdateWithWhereUniqueWithoutProvider_branchesInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutProvider_branchesInput | appointmentsUpdateManyWithWhereWithoutProvider_branchesInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type patient_favoritesUncheckedUpdateManyWithoutProvider_branchesNestedInput = {
    create?: XOR<patient_favoritesCreateWithoutProvider_branchesInput, patient_favoritesUncheckedCreateWithoutProvider_branchesInput> | patient_favoritesCreateWithoutProvider_branchesInput[] | patient_favoritesUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: patient_favoritesCreateOrConnectWithoutProvider_branchesInput | patient_favoritesCreateOrConnectWithoutProvider_branchesInput[]
    upsert?: patient_favoritesUpsertWithWhereUniqueWithoutProvider_branchesInput | patient_favoritesUpsertWithWhereUniqueWithoutProvider_branchesInput[]
    createMany?: patient_favoritesCreateManyProvider_branchesInputEnvelope
    set?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    disconnect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    delete?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    connect?: patient_favoritesWhereUniqueInput | patient_favoritesWhereUniqueInput[]
    update?: patient_favoritesUpdateWithWhereUniqueWithoutProvider_branchesInput | patient_favoritesUpdateWithWhereUniqueWithoutProvider_branchesInput[]
    updateMany?: patient_favoritesUpdateManyWithWhereWithoutProvider_branchesInput | patient_favoritesUpdateManyWithWhereWithoutProvider_branchesInput[]
    deleteMany?: patient_favoritesScalarWhereInput | patient_favoritesScalarWhereInput[]
  }

  export type provider_schedulesUncheckedUpdateManyWithoutProvider_branchesNestedInput = {
    create?: XOR<provider_schedulesCreateWithoutProvider_branchesInput, provider_schedulesUncheckedCreateWithoutProvider_branchesInput> | provider_schedulesCreateWithoutProvider_branchesInput[] | provider_schedulesUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: provider_schedulesCreateOrConnectWithoutProvider_branchesInput | provider_schedulesCreateOrConnectWithoutProvider_branchesInput[]
    upsert?: provider_schedulesUpsertWithWhereUniqueWithoutProvider_branchesInput | provider_schedulesUpsertWithWhereUniqueWithoutProvider_branchesInput[]
    createMany?: provider_schedulesCreateManyProvider_branchesInputEnvelope
    set?: provider_schedulesWhereUniqueInput | provider_schedulesWhereUniqueInput[]
    disconnect?: provider_schedulesWhereUniqueInput | provider_schedulesWhereUniqueInput[]
    delete?: provider_schedulesWhereUniqueInput | provider_schedulesWhereUniqueInput[]
    connect?: provider_schedulesWhereUniqueInput | provider_schedulesWhereUniqueInput[]
    update?: provider_schedulesUpdateWithWhereUniqueWithoutProvider_branchesInput | provider_schedulesUpdateWithWhereUniqueWithoutProvider_branchesInput[]
    updateMany?: provider_schedulesUpdateManyWithWhereWithoutProvider_branchesInput | provider_schedulesUpdateManyWithWhereWithoutProvider_branchesInput[]
    deleteMany?: provider_schedulesScalarWhereInput | provider_schedulesScalarWhereInput[]
  }

  export type reviewsUncheckedUpdateManyWithoutProvider_branchesNestedInput = {
    create?: XOR<reviewsCreateWithoutProvider_branchesInput, reviewsUncheckedCreateWithoutProvider_branchesInput> | reviewsCreateWithoutProvider_branchesInput[] | reviewsUncheckedCreateWithoutProvider_branchesInput[]
    connectOrCreate?: reviewsCreateOrConnectWithoutProvider_branchesInput | reviewsCreateOrConnectWithoutProvider_branchesInput[]
    upsert?: reviewsUpsertWithWhereUniqueWithoutProvider_branchesInput | reviewsUpsertWithWhereUniqueWithoutProvider_branchesInput[]
    createMany?: reviewsCreateManyProvider_branchesInputEnvelope
    set?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    disconnect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    delete?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    connect?: reviewsWhereUniqueInput | reviewsWhereUniqueInput[]
    update?: reviewsUpdateWithWhereUniqueWithoutProvider_branchesInput | reviewsUpdateWithWhereUniqueWithoutProvider_branchesInput[]
    updateMany?: reviewsUpdateManyWithWhereWithoutProvider_branchesInput | reviewsUpdateManyWithWhereWithoutProvider_branchesInput[]
    deleteMany?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
  }

  export type providersCreateNestedOneWithoutProvider_catalogInput = {
    create?: XOR<providersCreateWithoutProvider_catalogInput, providersUncheckedCreateWithoutProvider_catalogInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_catalogInput
    connect?: providersWhereUniqueInput
  }

  export type providersUpdateOneWithoutProvider_catalogNestedInput = {
    create?: XOR<providersCreateWithoutProvider_catalogInput, providersUncheckedCreateWithoutProvider_catalogInput>
    connectOrCreate?: providersCreateOrConnectWithoutProvider_catalogInput
    upsert?: providersUpsertWithoutProvider_catalogInput
    disconnect?: providersWhereInput | boolean
    delete?: providersWhereInput | boolean
    connect?: providersWhereUniqueInput
    update?: XOR<XOR<providersUpdateToOneWithWhereWithoutProvider_catalogInput, providersUpdateWithoutProvider_catalogInput>, providersUncheckedUpdateWithoutProvider_catalogInput>
  }

  export type provider_branchesCreateNestedOneWithoutProvider_schedulesInput = {
    create?: XOR<provider_branchesCreateWithoutProvider_schedulesInput, provider_branchesUncheckedCreateWithoutProvider_schedulesInput>
    connectOrCreate?: provider_branchesCreateOrConnectWithoutProvider_schedulesInput
    connect?: provider_branchesWhereUniqueInput
  }

  export type provider_branchesUpdateOneWithoutProvider_schedulesNestedInput = {
    create?: XOR<provider_branchesCreateWithoutProvider_schedulesInput, provider_branchesUncheckedCreateWithoutProvider_schedulesInput>
    connectOrCreate?: provider_branchesCreateOrConnectWithoutProvider_schedulesInput
    upsert?: provider_branchesUpsertWithoutProvider_schedulesInput
    disconnect?: provider_branchesWhereInput | boolean
    delete?: provider_branchesWhereInput | boolean
    connect?: provider_branchesWhereUniqueInput
    update?: XOR<XOR<provider_branchesUpdateToOneWithWhereWithoutProvider_schedulesInput, provider_branchesUpdateWithoutProvider_schedulesInput>, provider_branchesUncheckedUpdateWithoutProvider_schedulesInput>
  }

  export type appointmentsCreateNestedManyWithoutProvidersInput = {
    create?: XOR<appointmentsCreateWithoutProvidersInput, appointmentsUncheckedCreateWithoutProvidersInput> | appointmentsCreateWithoutProvidersInput[] | appointmentsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutProvidersInput | appointmentsCreateOrConnectWithoutProvidersInput[]
    createMany?: appointmentsCreateManyProvidersInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type medical_historyCreateNestedManyWithoutProvidersInput = {
    create?: XOR<medical_historyCreateWithoutProvidersInput, medical_historyUncheckedCreateWithoutProvidersInput> | medical_historyCreateWithoutProvidersInput[] | medical_historyUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: medical_historyCreateOrConnectWithoutProvidersInput | medical_historyCreateOrConnectWithoutProvidersInput[]
    createMany?: medical_historyCreateManyProvidersInputEnvelope
    connect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
  }

  export type payoutsCreateNestedManyWithoutProvidersInput = {
    create?: XOR<payoutsCreateWithoutProvidersInput, payoutsUncheckedCreateWithoutProvidersInput> | payoutsCreateWithoutProvidersInput[] | payoutsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: payoutsCreateOrConnectWithoutProvidersInput | payoutsCreateOrConnectWithoutProvidersInput[]
    createMany?: payoutsCreateManyProvidersInputEnvelope
    connect?: payoutsWhereUniqueInput | payoutsWhereUniqueInput[]
  }

  export type provider_adsCreateNestedManyWithoutProvidersInput = {
    create?: XOR<provider_adsCreateWithoutProvidersInput, provider_adsUncheckedCreateWithoutProvidersInput> | provider_adsCreateWithoutProvidersInput[] | provider_adsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_adsCreateOrConnectWithoutProvidersInput | provider_adsCreateOrConnectWithoutProvidersInput[]
    createMany?: provider_adsCreateManyProvidersInputEnvelope
    connect?: provider_adsWhereUniqueInput | provider_adsWhereUniqueInput[]
  }

  export type provider_bank_detailsCreateNestedManyWithoutProvidersInput = {
    create?: XOR<provider_bank_detailsCreateWithoutProvidersInput, provider_bank_detailsUncheckedCreateWithoutProvidersInput> | provider_bank_detailsCreateWithoutProvidersInput[] | provider_bank_detailsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_bank_detailsCreateOrConnectWithoutProvidersInput | provider_bank_detailsCreateOrConnectWithoutProvidersInput[]
    createMany?: provider_bank_detailsCreateManyProvidersInputEnvelope
    connect?: provider_bank_detailsWhereUniqueInput | provider_bank_detailsWhereUniqueInput[]
  }

  export type provider_branchesCreateNestedManyWithoutProvidersInput = {
    create?: XOR<provider_branchesCreateWithoutProvidersInput, provider_branchesUncheckedCreateWithoutProvidersInput> | provider_branchesCreateWithoutProvidersInput[] | provider_branchesUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_branchesCreateOrConnectWithoutProvidersInput | provider_branchesCreateOrConnectWithoutProvidersInput[]
    createMany?: provider_branchesCreateManyProvidersInputEnvelope
    connect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
  }

  export type provider_catalogCreateNestedManyWithoutProvidersInput = {
    create?: XOR<provider_catalogCreateWithoutProvidersInput, provider_catalogUncheckedCreateWithoutProvidersInput> | provider_catalogCreateWithoutProvidersInput[] | provider_catalogUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_catalogCreateOrConnectWithoutProvidersInput | provider_catalogCreateOrConnectWithoutProvidersInput[]
    createMany?: provider_catalogCreateManyProvidersInputEnvelope
    connect?: provider_catalogWhereUniqueInput | provider_catalogWhereUniqueInput[]
  }

  export type service_categoriesCreateNestedOneWithoutProvidersInput = {
    create?: XOR<service_categoriesCreateWithoutProvidersInput, service_categoriesUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: service_categoriesCreateOrConnectWithoutProvidersInput
    connect?: service_categoriesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutProvidersInput = {
    create?: XOR<usersCreateWithoutProvidersInput, usersUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: usersCreateOrConnectWithoutProvidersInput
    connect?: usersWhereUniqueInput
  }

  export type appointmentsUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<appointmentsCreateWithoutProvidersInput, appointmentsUncheckedCreateWithoutProvidersInput> | appointmentsCreateWithoutProvidersInput[] | appointmentsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutProvidersInput | appointmentsCreateOrConnectWithoutProvidersInput[]
    createMany?: appointmentsCreateManyProvidersInputEnvelope
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
  }

  export type medical_historyUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<medical_historyCreateWithoutProvidersInput, medical_historyUncheckedCreateWithoutProvidersInput> | medical_historyCreateWithoutProvidersInput[] | medical_historyUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: medical_historyCreateOrConnectWithoutProvidersInput | medical_historyCreateOrConnectWithoutProvidersInput[]
    createMany?: medical_historyCreateManyProvidersInputEnvelope
    connect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
  }

  export type payoutsUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<payoutsCreateWithoutProvidersInput, payoutsUncheckedCreateWithoutProvidersInput> | payoutsCreateWithoutProvidersInput[] | payoutsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: payoutsCreateOrConnectWithoutProvidersInput | payoutsCreateOrConnectWithoutProvidersInput[]
    createMany?: payoutsCreateManyProvidersInputEnvelope
    connect?: payoutsWhereUniqueInput | payoutsWhereUniqueInput[]
  }

  export type provider_adsUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<provider_adsCreateWithoutProvidersInput, provider_adsUncheckedCreateWithoutProvidersInput> | provider_adsCreateWithoutProvidersInput[] | provider_adsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_adsCreateOrConnectWithoutProvidersInput | provider_adsCreateOrConnectWithoutProvidersInput[]
    createMany?: provider_adsCreateManyProvidersInputEnvelope
    connect?: provider_adsWhereUniqueInput | provider_adsWhereUniqueInput[]
  }

  export type provider_bank_detailsUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<provider_bank_detailsCreateWithoutProvidersInput, provider_bank_detailsUncheckedCreateWithoutProvidersInput> | provider_bank_detailsCreateWithoutProvidersInput[] | provider_bank_detailsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_bank_detailsCreateOrConnectWithoutProvidersInput | provider_bank_detailsCreateOrConnectWithoutProvidersInput[]
    createMany?: provider_bank_detailsCreateManyProvidersInputEnvelope
    connect?: provider_bank_detailsWhereUniqueInput | provider_bank_detailsWhereUniqueInput[]
  }

  export type provider_branchesUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<provider_branchesCreateWithoutProvidersInput, provider_branchesUncheckedCreateWithoutProvidersInput> | provider_branchesCreateWithoutProvidersInput[] | provider_branchesUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_branchesCreateOrConnectWithoutProvidersInput | provider_branchesCreateOrConnectWithoutProvidersInput[]
    createMany?: provider_branchesCreateManyProvidersInputEnvelope
    connect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
  }

  export type provider_catalogUncheckedCreateNestedManyWithoutProvidersInput = {
    create?: XOR<provider_catalogCreateWithoutProvidersInput, provider_catalogUncheckedCreateWithoutProvidersInput> | provider_catalogCreateWithoutProvidersInput[] | provider_catalogUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_catalogCreateOrConnectWithoutProvidersInput | provider_catalogCreateOrConnectWithoutProvidersInput[]
    createMany?: provider_catalogCreateManyProvidersInputEnvelope
    connect?: provider_catalogWhereUniqueInput | provider_catalogWhereUniqueInput[]
  }

  export type appointmentsUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<appointmentsCreateWithoutProvidersInput, appointmentsUncheckedCreateWithoutProvidersInput> | appointmentsCreateWithoutProvidersInput[] | appointmentsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutProvidersInput | appointmentsCreateOrConnectWithoutProvidersInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutProvidersInput | appointmentsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: appointmentsCreateManyProvidersInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutProvidersInput | appointmentsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutProvidersInput | appointmentsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type medical_historyUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<medical_historyCreateWithoutProvidersInput, medical_historyUncheckedCreateWithoutProvidersInput> | medical_historyCreateWithoutProvidersInput[] | medical_historyUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: medical_historyCreateOrConnectWithoutProvidersInput | medical_historyCreateOrConnectWithoutProvidersInput[]
    upsert?: medical_historyUpsertWithWhereUniqueWithoutProvidersInput | medical_historyUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: medical_historyCreateManyProvidersInputEnvelope
    set?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    disconnect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    delete?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    connect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    update?: medical_historyUpdateWithWhereUniqueWithoutProvidersInput | medical_historyUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: medical_historyUpdateManyWithWhereWithoutProvidersInput | medical_historyUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: medical_historyScalarWhereInput | medical_historyScalarWhereInput[]
  }

  export type payoutsUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<payoutsCreateWithoutProvidersInput, payoutsUncheckedCreateWithoutProvidersInput> | payoutsCreateWithoutProvidersInput[] | payoutsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: payoutsCreateOrConnectWithoutProvidersInput | payoutsCreateOrConnectWithoutProvidersInput[]
    upsert?: payoutsUpsertWithWhereUniqueWithoutProvidersInput | payoutsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: payoutsCreateManyProvidersInputEnvelope
    set?: payoutsWhereUniqueInput | payoutsWhereUniqueInput[]
    disconnect?: payoutsWhereUniqueInput | payoutsWhereUniqueInput[]
    delete?: payoutsWhereUniqueInput | payoutsWhereUniqueInput[]
    connect?: payoutsWhereUniqueInput | payoutsWhereUniqueInput[]
    update?: payoutsUpdateWithWhereUniqueWithoutProvidersInput | payoutsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: payoutsUpdateManyWithWhereWithoutProvidersInput | payoutsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: payoutsScalarWhereInput | payoutsScalarWhereInput[]
  }

  export type provider_adsUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<provider_adsCreateWithoutProvidersInput, provider_adsUncheckedCreateWithoutProvidersInput> | provider_adsCreateWithoutProvidersInput[] | provider_adsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_adsCreateOrConnectWithoutProvidersInput | provider_adsCreateOrConnectWithoutProvidersInput[]
    upsert?: provider_adsUpsertWithWhereUniqueWithoutProvidersInput | provider_adsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: provider_adsCreateManyProvidersInputEnvelope
    set?: provider_adsWhereUniqueInput | provider_adsWhereUniqueInput[]
    disconnect?: provider_adsWhereUniqueInput | provider_adsWhereUniqueInput[]
    delete?: provider_adsWhereUniqueInput | provider_adsWhereUniqueInput[]
    connect?: provider_adsWhereUniqueInput | provider_adsWhereUniqueInput[]
    update?: provider_adsUpdateWithWhereUniqueWithoutProvidersInput | provider_adsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: provider_adsUpdateManyWithWhereWithoutProvidersInput | provider_adsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: provider_adsScalarWhereInput | provider_adsScalarWhereInput[]
  }

  export type provider_bank_detailsUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<provider_bank_detailsCreateWithoutProvidersInput, provider_bank_detailsUncheckedCreateWithoutProvidersInput> | provider_bank_detailsCreateWithoutProvidersInput[] | provider_bank_detailsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_bank_detailsCreateOrConnectWithoutProvidersInput | provider_bank_detailsCreateOrConnectWithoutProvidersInput[]
    upsert?: provider_bank_detailsUpsertWithWhereUniqueWithoutProvidersInput | provider_bank_detailsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: provider_bank_detailsCreateManyProvidersInputEnvelope
    set?: provider_bank_detailsWhereUniqueInput | provider_bank_detailsWhereUniqueInput[]
    disconnect?: provider_bank_detailsWhereUniqueInput | provider_bank_detailsWhereUniqueInput[]
    delete?: provider_bank_detailsWhereUniqueInput | provider_bank_detailsWhereUniqueInput[]
    connect?: provider_bank_detailsWhereUniqueInput | provider_bank_detailsWhereUniqueInput[]
    update?: provider_bank_detailsUpdateWithWhereUniqueWithoutProvidersInput | provider_bank_detailsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: provider_bank_detailsUpdateManyWithWhereWithoutProvidersInput | provider_bank_detailsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: provider_bank_detailsScalarWhereInput | provider_bank_detailsScalarWhereInput[]
  }

  export type provider_branchesUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<provider_branchesCreateWithoutProvidersInput, provider_branchesUncheckedCreateWithoutProvidersInput> | provider_branchesCreateWithoutProvidersInput[] | provider_branchesUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_branchesCreateOrConnectWithoutProvidersInput | provider_branchesCreateOrConnectWithoutProvidersInput[]
    upsert?: provider_branchesUpsertWithWhereUniqueWithoutProvidersInput | provider_branchesUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: provider_branchesCreateManyProvidersInputEnvelope
    set?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    disconnect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    delete?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    connect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    update?: provider_branchesUpdateWithWhereUniqueWithoutProvidersInput | provider_branchesUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: provider_branchesUpdateManyWithWhereWithoutProvidersInput | provider_branchesUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: provider_branchesScalarWhereInput | provider_branchesScalarWhereInput[]
  }

  export type provider_catalogUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<provider_catalogCreateWithoutProvidersInput, provider_catalogUncheckedCreateWithoutProvidersInput> | provider_catalogCreateWithoutProvidersInput[] | provider_catalogUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_catalogCreateOrConnectWithoutProvidersInput | provider_catalogCreateOrConnectWithoutProvidersInput[]
    upsert?: provider_catalogUpsertWithWhereUniqueWithoutProvidersInput | provider_catalogUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: provider_catalogCreateManyProvidersInputEnvelope
    set?: provider_catalogWhereUniqueInput | provider_catalogWhereUniqueInput[]
    disconnect?: provider_catalogWhereUniqueInput | provider_catalogWhereUniqueInput[]
    delete?: provider_catalogWhereUniqueInput | provider_catalogWhereUniqueInput[]
    connect?: provider_catalogWhereUniqueInput | provider_catalogWhereUniqueInput[]
    update?: provider_catalogUpdateWithWhereUniqueWithoutProvidersInput | provider_catalogUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: provider_catalogUpdateManyWithWhereWithoutProvidersInput | provider_catalogUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: provider_catalogScalarWhereInput | provider_catalogScalarWhereInput[]
  }

  export type service_categoriesUpdateOneWithoutProvidersNestedInput = {
    create?: XOR<service_categoriesCreateWithoutProvidersInput, service_categoriesUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: service_categoriesCreateOrConnectWithoutProvidersInput
    upsert?: service_categoriesUpsertWithoutProvidersInput
    disconnect?: service_categoriesWhereInput | boolean
    delete?: service_categoriesWhereInput | boolean
    connect?: service_categoriesWhereUniqueInput
    update?: XOR<XOR<service_categoriesUpdateToOneWithWhereWithoutProvidersInput, service_categoriesUpdateWithoutProvidersInput>, service_categoriesUncheckedUpdateWithoutProvidersInput>
  }

  export type usersUpdateOneWithoutProvidersNestedInput = {
    create?: XOR<usersCreateWithoutProvidersInput, usersUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: usersCreateOrConnectWithoutProvidersInput
    upsert?: usersUpsertWithoutProvidersInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutProvidersInput, usersUpdateWithoutProvidersInput>, usersUncheckedUpdateWithoutProvidersInput>
  }

  export type appointmentsUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<appointmentsCreateWithoutProvidersInput, appointmentsUncheckedCreateWithoutProvidersInput> | appointmentsCreateWithoutProvidersInput[] | appointmentsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: appointmentsCreateOrConnectWithoutProvidersInput | appointmentsCreateOrConnectWithoutProvidersInput[]
    upsert?: appointmentsUpsertWithWhereUniqueWithoutProvidersInput | appointmentsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: appointmentsCreateManyProvidersInputEnvelope
    set?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    disconnect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    delete?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    connect?: appointmentsWhereUniqueInput | appointmentsWhereUniqueInput[]
    update?: appointmentsUpdateWithWhereUniqueWithoutProvidersInput | appointmentsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: appointmentsUpdateManyWithWhereWithoutProvidersInput | appointmentsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
  }

  export type medical_historyUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<medical_historyCreateWithoutProvidersInput, medical_historyUncheckedCreateWithoutProvidersInput> | medical_historyCreateWithoutProvidersInput[] | medical_historyUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: medical_historyCreateOrConnectWithoutProvidersInput | medical_historyCreateOrConnectWithoutProvidersInput[]
    upsert?: medical_historyUpsertWithWhereUniqueWithoutProvidersInput | medical_historyUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: medical_historyCreateManyProvidersInputEnvelope
    set?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    disconnect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    delete?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    connect?: medical_historyWhereUniqueInput | medical_historyWhereUniqueInput[]
    update?: medical_historyUpdateWithWhereUniqueWithoutProvidersInput | medical_historyUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: medical_historyUpdateManyWithWhereWithoutProvidersInput | medical_historyUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: medical_historyScalarWhereInput | medical_historyScalarWhereInput[]
  }

  export type payoutsUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<payoutsCreateWithoutProvidersInput, payoutsUncheckedCreateWithoutProvidersInput> | payoutsCreateWithoutProvidersInput[] | payoutsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: payoutsCreateOrConnectWithoutProvidersInput | payoutsCreateOrConnectWithoutProvidersInput[]
    upsert?: payoutsUpsertWithWhereUniqueWithoutProvidersInput | payoutsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: payoutsCreateManyProvidersInputEnvelope
    set?: payoutsWhereUniqueInput | payoutsWhereUniqueInput[]
    disconnect?: payoutsWhereUniqueInput | payoutsWhereUniqueInput[]
    delete?: payoutsWhereUniqueInput | payoutsWhereUniqueInput[]
    connect?: payoutsWhereUniqueInput | payoutsWhereUniqueInput[]
    update?: payoutsUpdateWithWhereUniqueWithoutProvidersInput | payoutsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: payoutsUpdateManyWithWhereWithoutProvidersInput | payoutsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: payoutsScalarWhereInput | payoutsScalarWhereInput[]
  }

  export type provider_adsUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<provider_adsCreateWithoutProvidersInput, provider_adsUncheckedCreateWithoutProvidersInput> | provider_adsCreateWithoutProvidersInput[] | provider_adsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_adsCreateOrConnectWithoutProvidersInput | provider_adsCreateOrConnectWithoutProvidersInput[]
    upsert?: provider_adsUpsertWithWhereUniqueWithoutProvidersInput | provider_adsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: provider_adsCreateManyProvidersInputEnvelope
    set?: provider_adsWhereUniqueInput | provider_adsWhereUniqueInput[]
    disconnect?: provider_adsWhereUniqueInput | provider_adsWhereUniqueInput[]
    delete?: provider_adsWhereUniqueInput | provider_adsWhereUniqueInput[]
    connect?: provider_adsWhereUniqueInput | provider_adsWhereUniqueInput[]
    update?: provider_adsUpdateWithWhereUniqueWithoutProvidersInput | provider_adsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: provider_adsUpdateManyWithWhereWithoutProvidersInput | provider_adsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: provider_adsScalarWhereInput | provider_adsScalarWhereInput[]
  }

  export type provider_bank_detailsUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<provider_bank_detailsCreateWithoutProvidersInput, provider_bank_detailsUncheckedCreateWithoutProvidersInput> | provider_bank_detailsCreateWithoutProvidersInput[] | provider_bank_detailsUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_bank_detailsCreateOrConnectWithoutProvidersInput | provider_bank_detailsCreateOrConnectWithoutProvidersInput[]
    upsert?: provider_bank_detailsUpsertWithWhereUniqueWithoutProvidersInput | provider_bank_detailsUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: provider_bank_detailsCreateManyProvidersInputEnvelope
    set?: provider_bank_detailsWhereUniqueInput | provider_bank_detailsWhereUniqueInput[]
    disconnect?: provider_bank_detailsWhereUniqueInput | provider_bank_detailsWhereUniqueInput[]
    delete?: provider_bank_detailsWhereUniqueInput | provider_bank_detailsWhereUniqueInput[]
    connect?: provider_bank_detailsWhereUniqueInput | provider_bank_detailsWhereUniqueInput[]
    update?: provider_bank_detailsUpdateWithWhereUniqueWithoutProvidersInput | provider_bank_detailsUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: provider_bank_detailsUpdateManyWithWhereWithoutProvidersInput | provider_bank_detailsUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: provider_bank_detailsScalarWhereInput | provider_bank_detailsScalarWhereInput[]
  }

  export type provider_branchesUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<provider_branchesCreateWithoutProvidersInput, provider_branchesUncheckedCreateWithoutProvidersInput> | provider_branchesCreateWithoutProvidersInput[] | provider_branchesUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_branchesCreateOrConnectWithoutProvidersInput | provider_branchesCreateOrConnectWithoutProvidersInput[]
    upsert?: provider_branchesUpsertWithWhereUniqueWithoutProvidersInput | provider_branchesUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: provider_branchesCreateManyProvidersInputEnvelope
    set?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    disconnect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    delete?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    connect?: provider_branchesWhereUniqueInput | provider_branchesWhereUniqueInput[]
    update?: provider_branchesUpdateWithWhereUniqueWithoutProvidersInput | provider_branchesUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: provider_branchesUpdateManyWithWhereWithoutProvidersInput | provider_branchesUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: provider_branchesScalarWhereInput | provider_branchesScalarWhereInput[]
  }

  export type provider_catalogUncheckedUpdateManyWithoutProvidersNestedInput = {
    create?: XOR<provider_catalogCreateWithoutProvidersInput, provider_catalogUncheckedCreateWithoutProvidersInput> | provider_catalogCreateWithoutProvidersInput[] | provider_catalogUncheckedCreateWithoutProvidersInput[]
    connectOrCreate?: provider_catalogCreateOrConnectWithoutProvidersInput | provider_catalogCreateOrConnectWithoutProvidersInput[]
    upsert?: provider_catalogUpsertWithWhereUniqueWithoutProvidersInput | provider_catalogUpsertWithWhereUniqueWithoutProvidersInput[]
    createMany?: provider_catalogCreateManyProvidersInputEnvelope
    set?: provider_catalogWhereUniqueInput | provider_catalogWhereUniqueInput[]
    disconnect?: provider_catalogWhereUniqueInput | provider_catalogWhereUniqueInput[]
    delete?: provider_catalogWhereUniqueInput | provider_catalogWhereUniqueInput[]
    connect?: provider_catalogWhereUniqueInput | provider_catalogWhereUniqueInput[]
    update?: provider_catalogUpdateWithWhereUniqueWithoutProvidersInput | provider_catalogUpdateWithWhereUniqueWithoutProvidersInput[]
    updateMany?: provider_catalogUpdateManyWithWhereWithoutProvidersInput | provider_catalogUpdateManyWithWhereWithoutProvidersInput[]
    deleteMany?: provider_catalogScalarWhereInput | provider_catalogScalarWhereInput[]
  }

  export type appointmentsCreateNestedOneWithoutReviewsInput = {
    create?: XOR<appointmentsCreateWithoutReviewsInput, appointmentsUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: appointmentsCreateOrConnectWithoutReviewsInput
    connect?: appointmentsWhereUniqueInput
  }

  export type provider_branchesCreateNestedOneWithoutReviewsInput = {
    create?: XOR<provider_branchesCreateWithoutReviewsInput, provider_branchesUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: provider_branchesCreateOrConnectWithoutReviewsInput
    connect?: provider_branchesWhereUniqueInput
  }

  export type patientsCreateNestedOneWithoutReviewsInput = {
    create?: XOR<patientsCreateWithoutReviewsInput, patientsUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutReviewsInput
    connect?: patientsWhereUniqueInput
  }

  export type appointmentsUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<appointmentsCreateWithoutReviewsInput, appointmentsUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: appointmentsCreateOrConnectWithoutReviewsInput
    upsert?: appointmentsUpsertWithoutReviewsInput
    disconnect?: appointmentsWhereInput | boolean
    delete?: appointmentsWhereInput | boolean
    connect?: appointmentsWhereUniqueInput
    update?: XOR<XOR<appointmentsUpdateToOneWithWhereWithoutReviewsInput, appointmentsUpdateWithoutReviewsInput>, appointmentsUncheckedUpdateWithoutReviewsInput>
  }

  export type provider_branchesUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<provider_branchesCreateWithoutReviewsInput, provider_branchesUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: provider_branchesCreateOrConnectWithoutReviewsInput
    upsert?: provider_branchesUpsertWithoutReviewsInput
    disconnect?: provider_branchesWhereInput | boolean
    delete?: provider_branchesWhereInput | boolean
    connect?: provider_branchesWhereUniqueInput
    update?: XOR<XOR<provider_branchesUpdateToOneWithWhereWithoutReviewsInput, provider_branchesUpdateWithoutReviewsInput>, provider_branchesUncheckedUpdateWithoutReviewsInput>
  }

  export type patientsUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<patientsCreateWithoutReviewsInput, patientsUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: patientsCreateOrConnectWithoutReviewsInput
    upsert?: patientsUpsertWithoutReviewsInput
    disconnect?: patientsWhereInput | boolean
    delete?: patientsWhereInput | boolean
    connect?: patientsWhereUniqueInput
    update?: XOR<XOR<patientsUpdateToOneWithWhereWithoutReviewsInput, patientsUpdateWithoutReviewsInput>, patientsUncheckedUpdateWithoutReviewsInput>
  }

  export type providersCreateNestedManyWithoutService_categoriesInput = {
    create?: XOR<providersCreateWithoutService_categoriesInput, providersUncheckedCreateWithoutService_categoriesInput> | providersCreateWithoutService_categoriesInput[] | providersUncheckedCreateWithoutService_categoriesInput[]
    connectOrCreate?: providersCreateOrConnectWithoutService_categoriesInput | providersCreateOrConnectWithoutService_categoriesInput[]
    createMany?: providersCreateManyService_categoriesInputEnvelope
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
  }

  export type providersUncheckedCreateNestedManyWithoutService_categoriesInput = {
    create?: XOR<providersCreateWithoutService_categoriesInput, providersUncheckedCreateWithoutService_categoriesInput> | providersCreateWithoutService_categoriesInput[] | providersUncheckedCreateWithoutService_categoriesInput[]
    connectOrCreate?: providersCreateOrConnectWithoutService_categoriesInput | providersCreateOrConnectWithoutService_categoriesInput[]
    createMany?: providersCreateManyService_categoriesInputEnvelope
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
  }

  export type providersUpdateManyWithoutService_categoriesNestedInput = {
    create?: XOR<providersCreateWithoutService_categoriesInput, providersUncheckedCreateWithoutService_categoriesInput> | providersCreateWithoutService_categoriesInput[] | providersUncheckedCreateWithoutService_categoriesInput[]
    connectOrCreate?: providersCreateOrConnectWithoutService_categoriesInput | providersCreateOrConnectWithoutService_categoriesInput[]
    upsert?: providersUpsertWithWhereUniqueWithoutService_categoriesInput | providersUpsertWithWhereUniqueWithoutService_categoriesInput[]
    createMany?: providersCreateManyService_categoriesInputEnvelope
    set?: providersWhereUniqueInput | providersWhereUniqueInput[]
    disconnect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    delete?: providersWhereUniqueInput | providersWhereUniqueInput[]
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    update?: providersUpdateWithWhereUniqueWithoutService_categoriesInput | providersUpdateWithWhereUniqueWithoutService_categoriesInput[]
    updateMany?: providersUpdateManyWithWhereWithoutService_categoriesInput | providersUpdateManyWithWhereWithoutService_categoriesInput[]
    deleteMany?: providersScalarWhereInput | providersScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type providersUncheckedUpdateManyWithoutService_categoriesNestedInput = {
    create?: XOR<providersCreateWithoutService_categoriesInput, providersUncheckedCreateWithoutService_categoriesInput> | providersCreateWithoutService_categoriesInput[] | providersUncheckedCreateWithoutService_categoriesInput[]
    connectOrCreate?: providersCreateOrConnectWithoutService_categoriesInput | providersCreateOrConnectWithoutService_categoriesInput[]
    upsert?: providersUpsertWithWhereUniqueWithoutService_categoriesInput | providersUpsertWithWhereUniqueWithoutService_categoriesInput[]
    createMany?: providersCreateManyService_categoriesInputEnvelope
    set?: providersWhereUniqueInput | providersWhereUniqueInput[]
    disconnect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    delete?: providersWhereUniqueInput | providersWhereUniqueInput[]
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    update?: providersUpdateWithWhereUniqueWithoutService_categoriesInput | providersUpdateWithWhereUniqueWithoutService_categoriesInput[]
    updateMany?: providersUpdateManyWithWhereWithoutService_categoriesInput | providersUpdateManyWithWhereWithoutService_categoriesInput[]
    deleteMany?: providersScalarWhereInput | providersScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutSessionsInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    connect?: usersWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type usersUpdateOneWithoutSessionsNestedInput = {
    create?: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSessionsInput
    upsert?: usersUpsertWithoutSessionsInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSessionsInput, usersUpdateWithoutSessionsInput>, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type patientsCreateNestedManyWithoutUsersInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
  }

  export type providersCreateNestedManyWithoutUsersInput = {
    create?: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput> | providersCreateWithoutUsersInput[] | providersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: providersCreateOrConnectWithoutUsersInput | providersCreateOrConnectWithoutUsersInput[]
    createMany?: providersCreateManyUsersInputEnvelope
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
  }

  export type sessionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type patientsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
  }

  export type providersUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput> | providersCreateWithoutUsersInput[] | providersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: providersCreateOrConnectWithoutUsersInput | providersCreateOrConnectWithoutUsersInput[]
    createMany?: providersCreateManyUsersInputEnvelope
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
  }

  export type sessionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
  }

  export type NullableEnumenum_rolesFieldUpdateOperationsInput = {
    set?: $Enums.enum_roles | null
  }

  export type patientsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    upsert?: patientsUpsertWithWhereUniqueWithoutUsersInput | patientsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    set?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    disconnect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    delete?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    update?: patientsUpdateWithWhereUniqueWithoutUsersInput | patientsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: patientsUpdateManyWithWhereWithoutUsersInput | patientsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: patientsScalarWhereInput | patientsScalarWhereInput[]
  }

  export type providersUpdateManyWithoutUsersNestedInput = {
    create?: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput> | providersCreateWithoutUsersInput[] | providersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: providersCreateOrConnectWithoutUsersInput | providersCreateOrConnectWithoutUsersInput[]
    upsert?: providersUpsertWithWhereUniqueWithoutUsersInput | providersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: providersCreateManyUsersInputEnvelope
    set?: providersWhereUniqueInput | providersWhereUniqueInput[]
    disconnect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    delete?: providersWhereUniqueInput | providersWhereUniqueInput[]
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    update?: providersUpdateWithWhereUniqueWithoutUsersInput | providersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: providersUpdateManyWithWhereWithoutUsersInput | providersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: providersScalarWhereInput | providersScalarWhereInput[]
  }

  export type sessionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutUsersInput | sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutUsersInput | sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutUsersInput | sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type patientsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput> | patientsCreateWithoutUsersInput[] | patientsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: patientsCreateOrConnectWithoutUsersInput | patientsCreateOrConnectWithoutUsersInput[]
    upsert?: patientsUpsertWithWhereUniqueWithoutUsersInput | patientsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: patientsCreateManyUsersInputEnvelope
    set?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    disconnect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    delete?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    connect?: patientsWhereUniqueInput | patientsWhereUniqueInput[]
    update?: patientsUpdateWithWhereUniqueWithoutUsersInput | patientsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: patientsUpdateManyWithWhereWithoutUsersInput | patientsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: patientsScalarWhereInput | patientsScalarWhereInput[]
  }

  export type providersUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput> | providersCreateWithoutUsersInput[] | providersUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: providersCreateOrConnectWithoutUsersInput | providersCreateOrConnectWithoutUsersInput[]
    upsert?: providersUpsertWithWhereUniqueWithoutUsersInput | providersUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: providersCreateManyUsersInputEnvelope
    set?: providersWhereUniqueInput | providersWhereUniqueInput[]
    disconnect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    delete?: providersWhereUniqueInput | providersWhereUniqueInput[]
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    update?: providersUpdateWithWhereUniqueWithoutUsersInput | providersUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: providersUpdateManyWithWhereWithoutUsersInput | providersUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: providersScalarWhereInput | providersScalarWhereInput[]
  }

  export type sessionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput> | sessionsCreateWithoutUsersInput[] | sessionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: sessionsCreateOrConnectWithoutUsersInput | sessionsCreateOrConnectWithoutUsersInput[]
    upsert?: sessionsUpsertWithWhereUniqueWithoutUsersInput | sessionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: sessionsCreateManyUsersInputEnvelope
    set?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    disconnect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    delete?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    connect?: sessionsWhereUniqueInput | sessionsWhereUniqueInput[]
    update?: sessionsUpdateWithWhereUniqueWithoutUsersInput | sessionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: sessionsUpdateManyWithWhereWithoutUsersInput | sessionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumenum_notif_typesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_notif_types | Enumenum_notif_typesFieldRefInput<$PrismaModel>
    in?: $Enums.enum_notif_types[] | ListEnumenum_notif_typesFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_notif_types[] | ListEnumenum_notif_typesFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_notif_typesFilter<$PrismaModel> | $Enums.enum_notif_types
  }

  export type NestedEnumenum_notif_typesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_notif_types | Enumenum_notif_typesFieldRefInput<$PrismaModel>
    in?: $Enums.enum_notif_types[] | ListEnumenum_notif_typesFieldRefInput<$PrismaModel>
    notIn?: $Enums.enum_notif_types[] | ListEnumenum_notif_typesFieldRefInput<$PrismaModel>
    not?: NestedEnumenum_notif_typesWithAggregatesFilter<$PrismaModel> | $Enums.enum_notif_types
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumenum_notif_typesFilter<$PrismaModel>
    _max?: NestedEnumenum_notif_typesFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumenum_rolesNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_roles | Enumenum_rolesFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_roles[] | ListEnumenum_rolesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_roles[] | ListEnumenum_rolesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_rolesNullableFilter<$PrismaModel> | $Enums.enum_roles | null
  }

  export type NestedEnumenum_rolesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.enum_roles | Enumenum_rolesFieldRefInput<$PrismaModel> | null
    in?: $Enums.enum_roles[] | ListEnumenum_rolesFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.enum_roles[] | ListEnumenum_rolesFieldRefInput<$PrismaModel> | null
    not?: NestedEnumenum_rolesNullableWithAggregatesFilter<$PrismaModel> | $Enums.enum_roles | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumenum_rolesNullableFilter<$PrismaModel>
    _max?: NestedEnumenum_rolesNullableFilter<$PrismaModel>
  }

  export type provider_branchesCreateWithoutAppointmentsInput = {
    id: string
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    patient_favorites?: patient_favoritesCreateNestedManyWithoutProvider_branchesInput
    cities?: citiesCreateNestedOneWithoutProvider_branchesInput
    providers?: providersCreateNestedOneWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesUncheckedCreateWithoutAppointmentsInput = {
    id: string
    provider_id?: string | null
    city_id?: string | null
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesUncheckedCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesCreateOrConnectWithoutAppointmentsInput = {
    where: provider_branchesWhereUniqueInput
    create: XOR<provider_branchesCreateWithoutAppointmentsInput, provider_branchesUncheckedCreateWithoutAppointmentsInput>
  }

  export type patientsCreateWithoutAppointmentsInput = {
    id: string
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    medical_history?: medical_historyCreateNestedManyWithoutPatientsInput
    notifications?: notificationsCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutPatientsInput
    users?: usersCreateNestedOneWithoutPatientsInput
    reviews?: reviewsCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutAppointmentsInput = {
    id: string
    user_id?: string | null
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutPatientsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutPatientsInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutAppointmentsInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutAppointmentsInput, patientsUncheckedCreateWithoutAppointmentsInput>
  }

  export type providersCreateWithoutAppointmentsInput = {
    id: string
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    medical_history?: medical_historyCreateNestedManyWithoutProvidersInput
    payouts?: payoutsCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogCreateNestedManyWithoutProvidersInput
    service_categories?: service_categoriesCreateNestedOneWithoutProvidersInput
    users?: usersCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutAppointmentsInput = {
    id: string
    user_id?: string | null
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutProvidersInput
    payouts?: payoutsUncheckedCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsUncheckedCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsUncheckedCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesUncheckedCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutAppointmentsInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutAppointmentsInput, providersUncheckedCreateWithoutAppointmentsInput>
  }

  export type paymentsCreateWithoutAppointmentsInput = {
    id: string
    stripe_payment_intent_id?: string | null
    amount_total?: Decimal | DecimalJsLike | number | string | null
    platform_fee?: Decimal | DecimalJsLike | number | string | null
    provider_amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
    payouts?: payoutsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutAppointmentsInput = {
    id: string
    payout_id?: string | null
    stripe_payment_intent_id?: string | null
    amount_total?: Decimal | DecimalJsLike | number | string | null
    platform_fee?: Decimal | DecimalJsLike | number | string | null
    provider_amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type paymentsCreateOrConnectWithoutAppointmentsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutAppointmentsInput, paymentsUncheckedCreateWithoutAppointmentsInput>
  }

  export type paymentsCreateManyAppointmentsInputEnvelope = {
    data: paymentsCreateManyAppointmentsInput | paymentsCreateManyAppointmentsInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCreateWithoutAppointmentsInput = {
    id: string
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
    provider_branches?: provider_branchesCreateNestedOneWithoutReviewsInput
    patients?: patientsCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutAppointmentsInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
  }

  export type reviewsCreateOrConnectWithoutAppointmentsInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutAppointmentsInput, reviewsUncheckedCreateWithoutAppointmentsInput>
  }

  export type reviewsCreateManyAppointmentsInputEnvelope = {
    data: reviewsCreateManyAppointmentsInput | reviewsCreateManyAppointmentsInput[]
    skipDuplicates?: boolean
  }

  export type provider_branchesUpsertWithoutAppointmentsInput = {
    update: XOR<provider_branchesUpdateWithoutAppointmentsInput, provider_branchesUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<provider_branchesCreateWithoutAppointmentsInput, provider_branchesUncheckedCreateWithoutAppointmentsInput>
    where?: provider_branchesWhereInput
  }

  export type provider_branchesUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: provider_branchesWhereInput
    data: XOR<provider_branchesUpdateWithoutAppointmentsInput, provider_branchesUncheckedUpdateWithoutAppointmentsInput>
  }

  export type provider_branchesUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    patient_favorites?: patient_favoritesUpdateManyWithoutProvider_branchesNestedInput
    cities?: citiesUpdateOneWithoutProvider_branchesNestedInput
    providers?: providersUpdateOneWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUpdateManyWithoutProvider_branchesNestedInput
  }

  export type provider_branchesUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutProvider_branchesNestedInput
  }

  export type patientsUpsertWithoutAppointmentsInput = {
    update: XOR<patientsUpdateWithoutAppointmentsInput, patientsUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<patientsCreateWithoutAppointmentsInput, patientsUncheckedCreateWithoutAppointmentsInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutAppointmentsInput, patientsUncheckedUpdateWithoutAppointmentsInput>
  }

  export type patientsUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: medical_historyUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneWithoutPatientsNestedInput
    reviews?: reviewsUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    medical_history?: medical_historyUncheckedUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutPatientsNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type providersUpsertWithoutAppointmentsInput = {
    update: XOR<providersUpdateWithoutAppointmentsInput, providersUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<providersCreateWithoutAppointmentsInput, providersUncheckedCreateWithoutAppointmentsInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutAppointmentsInput, providersUncheckedUpdateWithoutAppointmentsInput>
  }

  export type providersUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    medical_history?: medical_historyUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUpdateManyWithoutProvidersNestedInput
    service_categories?: service_categoriesUpdateOneWithoutProvidersNestedInput
    users?: usersUpdateOneWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    medical_history?: medical_historyUncheckedUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUncheckedUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type paymentsUpsertWithWhereUniqueWithoutAppointmentsInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutAppointmentsInput, paymentsUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<paymentsCreateWithoutAppointmentsInput, paymentsUncheckedCreateWithoutAppointmentsInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutAppointmentsInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutAppointmentsInput, paymentsUncheckedUpdateWithoutAppointmentsInput>
  }

  export type paymentsUpdateManyWithWhereWithoutAppointmentsInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutAppointmentsInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: UuidFilter<"payments"> | string
    appointment_id?: UuidNullableFilter<"payments"> | string | null
    payout_id?: UuidNullableFilter<"payments"> | string | null
    stripe_payment_intent_id?: StringNullableFilter<"payments"> | string | null
    amount_total?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    platform_fee?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    provider_amount?: DecimalNullableFilter<"payments"> | Decimal | DecimalJsLike | number | string | null
    status?: StringNullableFilter<"payments"> | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
  }

  export type reviewsUpsertWithWhereUniqueWithoutAppointmentsInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutAppointmentsInput, reviewsUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<reviewsCreateWithoutAppointmentsInput, reviewsUncheckedCreateWithoutAppointmentsInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutAppointmentsInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutAppointmentsInput, reviewsUncheckedUpdateWithoutAppointmentsInput>
  }

  export type reviewsUpdateManyWithWhereWithoutAppointmentsInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutAppointmentsInput>
  }

  export type reviewsScalarWhereInput = {
    AND?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
    OR?: reviewsScalarWhereInput[]
    NOT?: reviewsScalarWhereInput | reviewsScalarWhereInput[]
    id?: UuidFilter<"reviews"> | string
    patient_id?: UuidNullableFilter<"reviews"> | string | null
    branch_id?: UuidNullableFilter<"reviews"> | string | null
    appointment_id?: UuidNullableFilter<"reviews"> | string | null
    rating?: IntNullableFilter<"reviews"> | number | null
    comment?: StringNullableFilter<"reviews"> | string | null
    created_at?: DateTimeNullableFilter<"reviews"> | Date | string | null
  }

  export type provider_branchesCreateWithoutCitiesInput = {
    id: string
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutProvider_branchesInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutProvider_branchesInput
    providers?: providersCreateNestedOneWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesUncheckedCreateWithoutCitiesInput = {
    id: string
    provider_id?: string | null
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvider_branchesInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesUncheckedCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesCreateOrConnectWithoutCitiesInput = {
    where: provider_branchesWhereUniqueInput
    create: XOR<provider_branchesCreateWithoutCitiesInput, provider_branchesUncheckedCreateWithoutCitiesInput>
  }

  export type provider_branchesCreateManyCitiesInputEnvelope = {
    data: provider_branchesCreateManyCitiesInput | provider_branchesCreateManyCitiesInput[]
    skipDuplicates?: boolean
  }

  export type provider_branchesUpsertWithWhereUniqueWithoutCitiesInput = {
    where: provider_branchesWhereUniqueInput
    update: XOR<provider_branchesUpdateWithoutCitiesInput, provider_branchesUncheckedUpdateWithoutCitiesInput>
    create: XOR<provider_branchesCreateWithoutCitiesInput, provider_branchesUncheckedCreateWithoutCitiesInput>
  }

  export type provider_branchesUpdateWithWhereUniqueWithoutCitiesInput = {
    where: provider_branchesWhereUniqueInput
    data: XOR<provider_branchesUpdateWithoutCitiesInput, provider_branchesUncheckedUpdateWithoutCitiesInput>
  }

  export type provider_branchesUpdateManyWithWhereWithoutCitiesInput = {
    where: provider_branchesScalarWhereInput
    data: XOR<provider_branchesUpdateManyMutationInput, provider_branchesUncheckedUpdateManyWithoutCitiesInput>
  }

  export type provider_branchesScalarWhereInput = {
    AND?: provider_branchesScalarWhereInput | provider_branchesScalarWhereInput[]
    OR?: provider_branchesScalarWhereInput[]
    NOT?: provider_branchesScalarWhereInput | provider_branchesScalarWhereInput[]
    id?: UuidFilter<"provider_branches"> | string
    provider_id?: UuidNullableFilter<"provider_branches"> | string | null
    city_id?: UuidNullableFilter<"provider_branches"> | string | null
    name?: StringNullableFilter<"provider_branches"> | string | null
    description?: StringNullableFilter<"provider_branches"> | string | null
    address_text?: StringNullableFilter<"provider_branches"> | string | null
    latitude?: FloatNullableFilter<"provider_branches"> | number | null
    longitude?: FloatNullableFilter<"provider_branches"> | number | null
    phone_contact?: StringNullableFilter<"provider_branches"> | string | null
    email_contact?: StringNullableFilter<"provider_branches"> | string | null
    image_url?: StringNullableFilter<"provider_branches"> | string | null
    opening_hours_text?: StringNullableFilter<"provider_branches"> | string | null
    is_24h?: BoolNullableFilter<"provider_branches"> | boolean | null
    has_delivery?: BoolNullableFilter<"provider_branches"> | boolean | null
    rating_cache?: FloatNullableFilter<"provider_branches"> | number | null
    is_main?: BoolNullableFilter<"provider_branches"> | boolean | null
    is_active?: BoolNullableFilter<"provider_branches"> | boolean | null
  }

  export type patientsCreateWithoutMedical_historyInput = {
    id: string
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsCreateNestedManyWithoutPatientsInput
    notifications?: notificationsCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutPatientsInput
    users?: usersCreateNestedOneWithoutPatientsInput
    reviews?: reviewsCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutMedical_historyInput = {
    id: string
    user_id?: string | null
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutPatientsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutPatientsInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutMedical_historyInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutMedical_historyInput, patientsUncheckedCreateWithoutMedical_historyInput>
  }

  export type providersCreateWithoutMedical_historyInput = {
    id: string
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsCreateNestedManyWithoutProvidersInput
    payouts?: payoutsCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogCreateNestedManyWithoutProvidersInput
    service_categories?: service_categoriesCreateNestedOneWithoutProvidersInput
    users?: usersCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutMedical_historyInput = {
    id: string
    user_id?: string | null
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvidersInput
    payouts?: payoutsUncheckedCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsUncheckedCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsUncheckedCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesUncheckedCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutMedical_historyInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutMedical_historyInput, providersUncheckedCreateWithoutMedical_historyInput>
  }

  export type patientsUpsertWithoutMedical_historyInput = {
    update: XOR<patientsUpdateWithoutMedical_historyInput, patientsUncheckedUpdateWithoutMedical_historyInput>
    create: XOR<patientsCreateWithoutMedical_historyInput, patientsUncheckedCreateWithoutMedical_historyInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutMedical_historyInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutMedical_historyInput, patientsUncheckedUpdateWithoutMedical_historyInput>
  }

  export type patientsUpdateWithoutMedical_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneWithoutPatientsNestedInput
    reviews?: reviewsUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutMedical_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutPatientsNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type providersUpsertWithoutMedical_historyInput = {
    update: XOR<providersUpdateWithoutMedical_historyInput, providersUncheckedUpdateWithoutMedical_historyInput>
    create: XOR<providersCreateWithoutMedical_historyInput, providersUncheckedCreateWithoutMedical_historyInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutMedical_historyInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutMedical_historyInput, providersUncheckedUpdateWithoutMedical_historyInput>
  }

  export type providersUpdateWithoutMedical_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUpdateManyWithoutProvidersNestedInput
    service_categories?: service_categoriesUpdateOneWithoutProvidersNestedInput
    users?: usersUpdateOneWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutMedical_historyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUncheckedUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type patientsCreateWithoutNotificationsInput = {
    id: string
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsCreateNestedManyWithoutPatientsInput
    medical_history?: medical_historyCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutPatientsInput
    users?: usersCreateNestedOneWithoutPatientsInput
    reviews?: reviewsCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutNotificationsInput = {
    id: string
    user_id?: string | null
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutPatientsInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutPatientsInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutNotificationsInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutNotificationsInput, patientsUncheckedCreateWithoutNotificationsInput>
  }

  export type patientsUpsertWithoutNotificationsInput = {
    update: XOR<patientsUpdateWithoutNotificationsInput, patientsUncheckedUpdateWithoutNotificationsInput>
    create: XOR<patientsCreateWithoutNotificationsInput, patientsUncheckedCreateWithoutNotificationsInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutNotificationsInput, patientsUncheckedUpdateWithoutNotificationsInput>
  }

  export type patientsUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutPatientsNestedInput
    medical_history?: medical_historyUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneWithoutPatientsNestedInput
    reviews?: reviewsUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutPatientsNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutPatientsNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type provider_branchesCreateWithoutPatient_favoritesInput = {
    id: string
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutProvider_branchesInput
    cities?: citiesCreateNestedOneWithoutProvider_branchesInput
    providers?: providersCreateNestedOneWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesUncheckedCreateWithoutPatient_favoritesInput = {
    id: string
    provider_id?: string | null
    city_id?: string | null
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesUncheckedCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesCreateOrConnectWithoutPatient_favoritesInput = {
    where: provider_branchesWhereUniqueInput
    create: XOR<provider_branchesCreateWithoutPatient_favoritesInput, provider_branchesUncheckedCreateWithoutPatient_favoritesInput>
  }

  export type patientsCreateWithoutPatient_favoritesInput = {
    id: string
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsCreateNestedManyWithoutPatientsInput
    medical_history?: medical_historyCreateNestedManyWithoutPatientsInput
    notifications?: notificationsCreateNestedManyWithoutPatientsInput
    users?: usersCreateNestedOneWithoutPatientsInput
    reviews?: reviewsCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutPatient_favoritesInput = {
    id: string
    user_id?: string | null
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutPatientsInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutPatientsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutPatientsInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutPatient_favoritesInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutPatient_favoritesInput, patientsUncheckedCreateWithoutPatient_favoritesInput>
  }

  export type provider_branchesUpsertWithoutPatient_favoritesInput = {
    update: XOR<provider_branchesUpdateWithoutPatient_favoritesInput, provider_branchesUncheckedUpdateWithoutPatient_favoritesInput>
    create: XOR<provider_branchesCreateWithoutPatient_favoritesInput, provider_branchesUncheckedCreateWithoutPatient_favoritesInput>
    where?: provider_branchesWhereInput
  }

  export type provider_branchesUpdateToOneWithWhereWithoutPatient_favoritesInput = {
    where?: provider_branchesWhereInput
    data: XOR<provider_branchesUpdateWithoutPatient_favoritesInput, provider_branchesUncheckedUpdateWithoutPatient_favoritesInput>
  }

  export type provider_branchesUpdateWithoutPatient_favoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutProvider_branchesNestedInput
    cities?: citiesUpdateOneWithoutProvider_branchesNestedInput
    providers?: providersUpdateOneWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUpdateManyWithoutProvider_branchesNestedInput
  }

  export type provider_branchesUncheckedUpdateWithoutPatient_favoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutProvider_branchesNestedInput
  }

  export type patientsUpsertWithoutPatient_favoritesInput = {
    update: XOR<patientsUpdateWithoutPatient_favoritesInput, patientsUncheckedUpdateWithoutPatient_favoritesInput>
    create: XOR<patientsCreateWithoutPatient_favoritesInput, patientsUncheckedCreateWithoutPatient_favoritesInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutPatient_favoritesInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutPatient_favoritesInput, patientsUncheckedUpdateWithoutPatient_favoritesInput>
  }

  export type patientsUpdateWithoutPatient_favoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutPatientsNestedInput
    medical_history?: medical_historyUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneWithoutPatientsNestedInput
    reviews?: reviewsUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutPatient_favoritesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutPatientsNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutPatientsNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type appointmentsCreateWithoutPatientsInput = {
    id: string
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    provider_branches?: provider_branchesCreateNestedOneWithoutAppointmentsInput
    providers?: providersCreateNestedOneWithoutAppointmentsInput
    payments?: paymentsCreateNestedManyWithoutAppointmentsInput
    reviews?: reviewsCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutPatientsInput = {
    id: string
    branch_id?: string | null
    provider_id?: string | null
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    payments?: paymentsUncheckedCreateNestedManyWithoutAppointmentsInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutPatientsInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutPatientsInput, appointmentsUncheckedCreateWithoutPatientsInput>
  }

  export type appointmentsCreateManyPatientsInputEnvelope = {
    data: appointmentsCreateManyPatientsInput | appointmentsCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type medical_historyCreateWithoutPatientsInput = {
    id: string
    doctor_name_snapshot?: string | null
    specialty_snapshot?: string | null
    diagnosis?: string | null
    date?: Date | string | null
    treatment?: string | null
    indications?: string | null
    observations?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    providers?: providersCreateNestedOneWithoutMedical_historyInput
  }

  export type medical_historyUncheckedCreateWithoutPatientsInput = {
    id: string
    provider_id?: string | null
    doctor_name_snapshot?: string | null
    specialty_snapshot?: string | null
    diagnosis?: string | null
    date?: Date | string | null
    treatment?: string | null
    indications?: string | null
    observations?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type medical_historyCreateOrConnectWithoutPatientsInput = {
    where: medical_historyWhereUniqueInput
    create: XOR<medical_historyCreateWithoutPatientsInput, medical_historyUncheckedCreateWithoutPatientsInput>
  }

  export type medical_historyCreateManyPatientsInputEnvelope = {
    data: medical_historyCreateManyPatientsInput | medical_historyCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type notificationsCreateWithoutPatientsInput = {
    id: string
    type: $Enums.enum_notif_types
    title: string
    body: string
    is_read?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type notificationsUncheckedCreateWithoutPatientsInput = {
    id: string
    type: $Enums.enum_notif_types
    title: string
    body: string
    is_read?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type notificationsCreateOrConnectWithoutPatientsInput = {
    where: notificationsWhereUniqueInput
    create: XOR<notificationsCreateWithoutPatientsInput, notificationsUncheckedCreateWithoutPatientsInput>
  }

  export type notificationsCreateManyPatientsInputEnvelope = {
    data: notificationsCreateManyPatientsInput | notificationsCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type patient_favoritesCreateWithoutPatientsInput = {
    id: string
    created_at?: Date | string | null
    provider_branches?: provider_branchesCreateNestedOneWithoutPatient_favoritesInput
  }

  export type patient_favoritesUncheckedCreateWithoutPatientsInput = {
    id: string
    branch_id?: string | null
    created_at?: Date | string | null
  }

  export type patient_favoritesCreateOrConnectWithoutPatientsInput = {
    where: patient_favoritesWhereUniqueInput
    create: XOR<patient_favoritesCreateWithoutPatientsInput, patient_favoritesUncheckedCreateWithoutPatientsInput>
  }

  export type patient_favoritesCreateManyPatientsInputEnvelope = {
    data: patient_favoritesCreateManyPatientsInput | patient_favoritesCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutPatientsInput = {
    id: string
    email: string
    password_hash: string
    role?: $Enums.enum_roles | null
    profile_picture_url?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    providers?: providersCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPatientsInput = {
    id: string
    email: string
    password_hash: string
    role?: $Enums.enum_roles | null
    profile_picture_url?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    providers?: providersUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPatientsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
  }

  export type reviewsCreateWithoutPatientsInput = {
    id: string
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
    appointments?: appointmentsCreateNestedOneWithoutReviewsInput
    provider_branches?: provider_branchesCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutPatientsInput = {
    id: string
    branch_id?: string | null
    appointment_id?: string | null
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
  }

  export type reviewsCreateOrConnectWithoutPatientsInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutPatientsInput, reviewsUncheckedCreateWithoutPatientsInput>
  }

  export type reviewsCreateManyPatientsInputEnvelope = {
    data: reviewsCreateManyPatientsInput | reviewsCreateManyPatientsInput[]
    skipDuplicates?: boolean
  }

  export type appointmentsUpsertWithWhereUniqueWithoutPatientsInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutPatientsInput, appointmentsUncheckedUpdateWithoutPatientsInput>
    create: XOR<appointmentsCreateWithoutPatientsInput, appointmentsUncheckedCreateWithoutPatientsInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutPatientsInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutPatientsInput, appointmentsUncheckedUpdateWithoutPatientsInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutPatientsInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutPatientsInput>
  }

  export type appointmentsScalarWhereInput = {
    AND?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
    OR?: appointmentsScalarWhereInput[]
    NOT?: appointmentsScalarWhereInput | appointmentsScalarWhereInput[]
    id?: UuidFilter<"appointments"> | string
    patient_id?: UuidNullableFilter<"appointments"> | string | null
    branch_id?: UuidNullableFilter<"appointments"> | string | null
    provider_id?: UuidNullableFilter<"appointments"> | string | null
    scheduled_for?: DateTimeNullableFilter<"appointments"> | Date | string | null
    status?: StringNullableFilter<"appointments"> | string | null
    reason?: StringNullableFilter<"appointments"> | string | null
    is_paid?: BoolNullableFilter<"appointments"> | boolean | null
  }

  export type medical_historyUpsertWithWhereUniqueWithoutPatientsInput = {
    where: medical_historyWhereUniqueInput
    update: XOR<medical_historyUpdateWithoutPatientsInput, medical_historyUncheckedUpdateWithoutPatientsInput>
    create: XOR<medical_historyCreateWithoutPatientsInput, medical_historyUncheckedCreateWithoutPatientsInput>
  }

  export type medical_historyUpdateWithWhereUniqueWithoutPatientsInput = {
    where: medical_historyWhereUniqueInput
    data: XOR<medical_historyUpdateWithoutPatientsInput, medical_historyUncheckedUpdateWithoutPatientsInput>
  }

  export type medical_historyUpdateManyWithWhereWithoutPatientsInput = {
    where: medical_historyScalarWhereInput
    data: XOR<medical_historyUpdateManyMutationInput, medical_historyUncheckedUpdateManyWithoutPatientsInput>
  }

  export type medical_historyScalarWhereInput = {
    AND?: medical_historyScalarWhereInput | medical_historyScalarWhereInput[]
    OR?: medical_historyScalarWhereInput[]
    NOT?: medical_historyScalarWhereInput | medical_historyScalarWhereInput[]
    id?: UuidFilter<"medical_history"> | string
    patient_id?: UuidNullableFilter<"medical_history"> | string | null
    provider_id?: UuidNullableFilter<"medical_history"> | string | null
    doctor_name_snapshot?: StringNullableFilter<"medical_history"> | string | null
    specialty_snapshot?: StringNullableFilter<"medical_history"> | string | null
    diagnosis?: StringNullableFilter<"medical_history"> | string | null
    date?: DateTimeNullableFilter<"medical_history"> | Date | string | null
    treatment?: StringNullableFilter<"medical_history"> | string | null
    indications?: StringNullableFilter<"medical_history"> | string | null
    observations?: StringNullableFilter<"medical_history"> | string | null
    created_at?: DateTimeNullableFilter<"medical_history"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"medical_history"> | Date | string | null
  }

  export type notificationsUpsertWithWhereUniqueWithoutPatientsInput = {
    where: notificationsWhereUniqueInput
    update: XOR<notificationsUpdateWithoutPatientsInput, notificationsUncheckedUpdateWithoutPatientsInput>
    create: XOR<notificationsCreateWithoutPatientsInput, notificationsUncheckedCreateWithoutPatientsInput>
  }

  export type notificationsUpdateWithWhereUniqueWithoutPatientsInput = {
    where: notificationsWhereUniqueInput
    data: XOR<notificationsUpdateWithoutPatientsInput, notificationsUncheckedUpdateWithoutPatientsInput>
  }

  export type notificationsUpdateManyWithWhereWithoutPatientsInput = {
    where: notificationsScalarWhereInput
    data: XOR<notificationsUpdateManyMutationInput, notificationsUncheckedUpdateManyWithoutPatientsInput>
  }

  export type notificationsScalarWhereInput = {
    AND?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    OR?: notificationsScalarWhereInput[]
    NOT?: notificationsScalarWhereInput | notificationsScalarWhereInput[]
    id?: UuidFilter<"notifications"> | string
    patient_id?: UuidFilter<"notifications"> | string
    type?: Enumenum_notif_typesFilter<"notifications"> | $Enums.enum_notif_types
    title?: StringFilter<"notifications"> | string
    body?: StringFilter<"notifications"> | string
    is_read?: BoolNullableFilter<"notifications"> | boolean | null
    data?: JsonNullableFilter<"notifications">
    created_at?: DateTimeNullableFilter<"notifications"> | Date | string | null
  }

  export type patient_favoritesUpsertWithWhereUniqueWithoutPatientsInput = {
    where: patient_favoritesWhereUniqueInput
    update: XOR<patient_favoritesUpdateWithoutPatientsInput, patient_favoritesUncheckedUpdateWithoutPatientsInput>
    create: XOR<patient_favoritesCreateWithoutPatientsInput, patient_favoritesUncheckedCreateWithoutPatientsInput>
  }

  export type patient_favoritesUpdateWithWhereUniqueWithoutPatientsInput = {
    where: patient_favoritesWhereUniqueInput
    data: XOR<patient_favoritesUpdateWithoutPatientsInput, patient_favoritesUncheckedUpdateWithoutPatientsInput>
  }

  export type patient_favoritesUpdateManyWithWhereWithoutPatientsInput = {
    where: patient_favoritesScalarWhereInput
    data: XOR<patient_favoritesUpdateManyMutationInput, patient_favoritesUncheckedUpdateManyWithoutPatientsInput>
  }

  export type patient_favoritesScalarWhereInput = {
    AND?: patient_favoritesScalarWhereInput | patient_favoritesScalarWhereInput[]
    OR?: patient_favoritesScalarWhereInput[]
    NOT?: patient_favoritesScalarWhereInput | patient_favoritesScalarWhereInput[]
    id?: UuidFilter<"patient_favorites"> | string
    patient_id?: UuidNullableFilter<"patient_favorites"> | string | null
    branch_id?: UuidNullableFilter<"patient_favorites"> | string | null
    created_at?: DateTimeNullableFilter<"patient_favorites"> | Date | string | null
  }

  export type usersUpsertWithoutPatientsInput = {
    update: XOR<usersUpdateWithoutPatientsInput, usersUncheckedUpdateWithoutPatientsInput>
    create: XOR<usersCreateWithoutPatientsInput, usersUncheckedCreateWithoutPatientsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPatientsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPatientsInput, usersUncheckedUpdateWithoutPatientsInput>
  }

  export type usersUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumenum_rolesFieldUpdateOperationsInput | $Enums.enum_roles | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providers?: providersUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumenum_rolesFieldUpdateOperationsInput | $Enums.enum_roles | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providers?: providersUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type reviewsUpsertWithWhereUniqueWithoutPatientsInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutPatientsInput, reviewsUncheckedUpdateWithoutPatientsInput>
    create: XOR<reviewsCreateWithoutPatientsInput, reviewsUncheckedCreateWithoutPatientsInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutPatientsInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutPatientsInput, reviewsUncheckedUpdateWithoutPatientsInput>
  }

  export type reviewsUpdateManyWithWhereWithoutPatientsInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutPatientsInput>
  }

  export type appointmentsCreateWithoutPaymentsInput = {
    id: string
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    provider_branches?: provider_branchesCreateNestedOneWithoutAppointmentsInput
    patients?: patientsCreateNestedOneWithoutAppointmentsInput
    providers?: providersCreateNestedOneWithoutAppointmentsInput
    reviews?: reviewsCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutPaymentsInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    provider_id?: string | null
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    reviews?: reviewsUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutPaymentsInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutPaymentsInput, appointmentsUncheckedCreateWithoutPaymentsInput>
  }

  export type payoutsCreateWithoutPaymentsInput = {
    id: string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    reference_number?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    created_at?: Date | string | null
    providers?: providersCreateNestedOneWithoutPayoutsInput
  }

  export type payoutsUncheckedCreateWithoutPaymentsInput = {
    id: string
    provider_id?: string | null
    total_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    reference_number?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    created_at?: Date | string | null
  }

  export type payoutsCreateOrConnectWithoutPaymentsInput = {
    where: payoutsWhereUniqueInput
    create: XOR<payoutsCreateWithoutPaymentsInput, payoutsUncheckedCreateWithoutPaymentsInput>
  }

  export type appointmentsUpsertWithoutPaymentsInput = {
    update: XOR<appointmentsUpdateWithoutPaymentsInput, appointmentsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<appointmentsCreateWithoutPaymentsInput, appointmentsUncheckedCreateWithoutPaymentsInput>
    where?: appointmentsWhereInput
  }

  export type appointmentsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: appointmentsWhereInput
    data: XOR<appointmentsUpdateWithoutPaymentsInput, appointmentsUncheckedUpdateWithoutPaymentsInput>
  }

  export type appointmentsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_branches?: provider_branchesUpdateOneWithoutAppointmentsNestedInput
    patients?: patientsUpdateOneWithoutAppointmentsNestedInput
    providers?: providersUpdateOneWithoutAppointmentsNestedInput
    reviews?: reviewsUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    reviews?: reviewsUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type payoutsUpsertWithoutPaymentsInput = {
    update: XOR<payoutsUpdateWithoutPaymentsInput, payoutsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<payoutsCreateWithoutPaymentsInput, payoutsUncheckedCreateWithoutPaymentsInput>
    where?: payoutsWhereInput
  }

  export type payoutsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: payoutsWhereInput
    data: XOR<payoutsUpdateWithoutPaymentsInput, payoutsUncheckedUpdateWithoutPaymentsInput>
  }

  export type payoutsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providers?: providersUpdateOneWithoutPayoutsNestedInput
  }

  export type payoutsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateWithoutPayoutsInput = {
    id: string
    stripe_payment_intent_id?: string | null
    amount_total?: Decimal | DecimalJsLike | number | string | null
    platform_fee?: Decimal | DecimalJsLike | number | string | null
    provider_amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
    appointments?: appointmentsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutPayoutsInput = {
    id: string
    appointment_id?: string | null
    stripe_payment_intent_id?: string | null
    amount_total?: Decimal | DecimalJsLike | number | string | null
    platform_fee?: Decimal | DecimalJsLike | number | string | null
    provider_amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type paymentsCreateOrConnectWithoutPayoutsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutPayoutsInput, paymentsUncheckedCreateWithoutPayoutsInput>
  }

  export type paymentsCreateManyPayoutsInputEnvelope = {
    data: paymentsCreateManyPayoutsInput | paymentsCreateManyPayoutsInput[]
    skipDuplicates?: boolean
  }

  export type providersCreateWithoutPayoutsInput = {
    id: string
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogCreateNestedManyWithoutProvidersInput
    service_categories?: service_categoriesCreateNestedOneWithoutProvidersInput
    users?: usersCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutPayoutsInput = {
    id: string
    user_id?: string | null
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsUncheckedCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsUncheckedCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesUncheckedCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutPayoutsInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutPayoutsInput, providersUncheckedCreateWithoutPayoutsInput>
  }

  export type paymentsUpsertWithWhereUniqueWithoutPayoutsInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutPayoutsInput, paymentsUncheckedUpdateWithoutPayoutsInput>
    create: XOR<paymentsCreateWithoutPayoutsInput, paymentsUncheckedCreateWithoutPayoutsInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutPayoutsInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutPayoutsInput, paymentsUncheckedUpdateWithoutPayoutsInput>
  }

  export type paymentsUpdateManyWithWhereWithoutPayoutsInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutPayoutsInput>
  }

  export type providersUpsertWithoutPayoutsInput = {
    update: XOR<providersUpdateWithoutPayoutsInput, providersUncheckedUpdateWithoutPayoutsInput>
    create: XOR<providersCreateWithoutPayoutsInput, providersUncheckedCreateWithoutPayoutsInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutPayoutsInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutPayoutsInput, providersUncheckedUpdateWithoutPayoutsInput>
  }

  export type providersUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUpdateManyWithoutProvidersNestedInput
    service_categories?: service_categoriesUpdateOneWithoutProvidersNestedInput
    users?: usersUpdateOneWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUncheckedUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type providersCreateWithoutProvider_adsInput = {
    id: string
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyCreateNestedManyWithoutProvidersInput
    payouts?: payoutsCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogCreateNestedManyWithoutProvidersInput
    service_categories?: service_categoriesCreateNestedOneWithoutProvidersInput
    users?: usersCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutProvider_adsInput = {
    id: string
    user_id?: string | null
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutProvidersInput
    payouts?: payoutsUncheckedCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsUncheckedCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesUncheckedCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutProvider_adsInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutProvider_adsInput, providersUncheckedCreateWithoutProvider_adsInput>
  }

  export type providersUpsertWithoutProvider_adsInput = {
    update: XOR<providersUpdateWithoutProvider_adsInput, providersUncheckedUpdateWithoutProvider_adsInput>
    create: XOR<providersCreateWithoutProvider_adsInput, providersUncheckedCreateWithoutProvider_adsInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutProvider_adsInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutProvider_adsInput, providersUncheckedUpdateWithoutProvider_adsInput>
  }

  export type providersUpdateWithoutProvider_adsInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUpdateManyWithoutProvidersNestedInput
    service_categories?: service_categoriesUpdateOneWithoutProvidersNestedInput
    users?: usersUpdateOneWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutProvider_adsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUncheckedUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type providersCreateWithoutProvider_bank_detailsInput = {
    id: string
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyCreateNestedManyWithoutProvidersInput
    payouts?: payoutsCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogCreateNestedManyWithoutProvidersInput
    service_categories?: service_categoriesCreateNestedOneWithoutProvidersInput
    users?: usersCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutProvider_bank_detailsInput = {
    id: string
    user_id?: string | null
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutProvidersInput
    payouts?: payoutsUncheckedCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsUncheckedCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesUncheckedCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutProvider_bank_detailsInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutProvider_bank_detailsInput, providersUncheckedCreateWithoutProvider_bank_detailsInput>
  }

  export type providersUpsertWithoutProvider_bank_detailsInput = {
    update: XOR<providersUpdateWithoutProvider_bank_detailsInput, providersUncheckedUpdateWithoutProvider_bank_detailsInput>
    create: XOR<providersCreateWithoutProvider_bank_detailsInput, providersUncheckedCreateWithoutProvider_bank_detailsInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutProvider_bank_detailsInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutProvider_bank_detailsInput, providersUncheckedUpdateWithoutProvider_bank_detailsInput>
  }

  export type providersUpdateWithoutProvider_bank_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUpdateManyWithoutProvidersNestedInput
    service_categories?: service_categoriesUpdateOneWithoutProvidersNestedInput
    users?: usersUpdateOneWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutProvider_bank_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUncheckedUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type appointmentsCreateWithoutProvider_branchesInput = {
    id: string
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    patients?: patientsCreateNestedOneWithoutAppointmentsInput
    providers?: providersCreateNestedOneWithoutAppointmentsInput
    payments?: paymentsCreateNestedManyWithoutAppointmentsInput
    reviews?: reviewsCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutProvider_branchesInput = {
    id: string
    patient_id?: string | null
    provider_id?: string | null
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    payments?: paymentsUncheckedCreateNestedManyWithoutAppointmentsInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutProvider_branchesInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutProvider_branchesInput, appointmentsUncheckedCreateWithoutProvider_branchesInput>
  }

  export type appointmentsCreateManyProvider_branchesInputEnvelope = {
    data: appointmentsCreateManyProvider_branchesInput | appointmentsCreateManyProvider_branchesInput[]
    skipDuplicates?: boolean
  }

  export type patient_favoritesCreateWithoutProvider_branchesInput = {
    id: string
    created_at?: Date | string | null
    patients?: patientsCreateNestedOneWithoutPatient_favoritesInput
  }

  export type patient_favoritesUncheckedCreateWithoutProvider_branchesInput = {
    id: string
    patient_id?: string | null
    created_at?: Date | string | null
  }

  export type patient_favoritesCreateOrConnectWithoutProvider_branchesInput = {
    where: patient_favoritesWhereUniqueInput
    create: XOR<patient_favoritesCreateWithoutProvider_branchesInput, patient_favoritesUncheckedCreateWithoutProvider_branchesInput>
  }

  export type patient_favoritesCreateManyProvider_branchesInputEnvelope = {
    data: patient_favoritesCreateManyProvider_branchesInput | patient_favoritesCreateManyProvider_branchesInput[]
    skipDuplicates?: boolean
  }

  export type citiesCreateWithoutProvider_branchesInput = {
    id: string
    name: string
    state?: string | null
    country?: string | null
  }

  export type citiesUncheckedCreateWithoutProvider_branchesInput = {
    id: string
    name: string
    state?: string | null
    country?: string | null
  }

  export type citiesCreateOrConnectWithoutProvider_branchesInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutProvider_branchesInput, citiesUncheckedCreateWithoutProvider_branchesInput>
  }

  export type providersCreateWithoutProvider_branchesInput = {
    id: string
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyCreateNestedManyWithoutProvidersInput
    payouts?: payoutsCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogCreateNestedManyWithoutProvidersInput
    service_categories?: service_categoriesCreateNestedOneWithoutProvidersInput
    users?: usersCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutProvider_branchesInput = {
    id: string
    user_id?: string | null
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutProvidersInput
    payouts?: payoutsUncheckedCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsUncheckedCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsUncheckedCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutProvider_branchesInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutProvider_branchesInput, providersUncheckedCreateWithoutProvider_branchesInput>
  }

  export type provider_schedulesCreateWithoutProvider_branchesInput = {
    id: string
    day_of_week?: number | null
    start_time?: Date | string | null
    end_time?: Date | string | null
  }

  export type provider_schedulesUncheckedCreateWithoutProvider_branchesInput = {
    id: string
    day_of_week?: number | null
    start_time?: Date | string | null
    end_time?: Date | string | null
  }

  export type provider_schedulesCreateOrConnectWithoutProvider_branchesInput = {
    where: provider_schedulesWhereUniqueInput
    create: XOR<provider_schedulesCreateWithoutProvider_branchesInput, provider_schedulesUncheckedCreateWithoutProvider_branchesInput>
  }

  export type provider_schedulesCreateManyProvider_branchesInputEnvelope = {
    data: provider_schedulesCreateManyProvider_branchesInput | provider_schedulesCreateManyProvider_branchesInput[]
    skipDuplicates?: boolean
  }

  export type reviewsCreateWithoutProvider_branchesInput = {
    id: string
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
    appointments?: appointmentsCreateNestedOneWithoutReviewsInput
    patients?: patientsCreateNestedOneWithoutReviewsInput
  }

  export type reviewsUncheckedCreateWithoutProvider_branchesInput = {
    id: string
    patient_id?: string | null
    appointment_id?: string | null
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
  }

  export type reviewsCreateOrConnectWithoutProvider_branchesInput = {
    where: reviewsWhereUniqueInput
    create: XOR<reviewsCreateWithoutProvider_branchesInput, reviewsUncheckedCreateWithoutProvider_branchesInput>
  }

  export type reviewsCreateManyProvider_branchesInputEnvelope = {
    data: reviewsCreateManyProvider_branchesInput | reviewsCreateManyProvider_branchesInput[]
    skipDuplicates?: boolean
  }

  export type appointmentsUpsertWithWhereUniqueWithoutProvider_branchesInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutProvider_branchesInput, appointmentsUncheckedUpdateWithoutProvider_branchesInput>
    create: XOR<appointmentsCreateWithoutProvider_branchesInput, appointmentsUncheckedCreateWithoutProvider_branchesInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutProvider_branchesInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutProvider_branchesInput, appointmentsUncheckedUpdateWithoutProvider_branchesInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutProvider_branchesInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutProvider_branchesInput>
  }

  export type patient_favoritesUpsertWithWhereUniqueWithoutProvider_branchesInput = {
    where: patient_favoritesWhereUniqueInput
    update: XOR<patient_favoritesUpdateWithoutProvider_branchesInput, patient_favoritesUncheckedUpdateWithoutProvider_branchesInput>
    create: XOR<patient_favoritesCreateWithoutProvider_branchesInput, patient_favoritesUncheckedCreateWithoutProvider_branchesInput>
  }

  export type patient_favoritesUpdateWithWhereUniqueWithoutProvider_branchesInput = {
    where: patient_favoritesWhereUniqueInput
    data: XOR<patient_favoritesUpdateWithoutProvider_branchesInput, patient_favoritesUncheckedUpdateWithoutProvider_branchesInput>
  }

  export type patient_favoritesUpdateManyWithWhereWithoutProvider_branchesInput = {
    where: patient_favoritesScalarWhereInput
    data: XOR<patient_favoritesUpdateManyMutationInput, patient_favoritesUncheckedUpdateManyWithoutProvider_branchesInput>
  }

  export type citiesUpsertWithoutProvider_branchesInput = {
    update: XOR<citiesUpdateWithoutProvider_branchesInput, citiesUncheckedUpdateWithoutProvider_branchesInput>
    create: XOR<citiesCreateWithoutProvider_branchesInput, citiesUncheckedCreateWithoutProvider_branchesInput>
    where?: citiesWhereInput
  }

  export type citiesUpdateToOneWithWhereWithoutProvider_branchesInput = {
    where?: citiesWhereInput
    data: XOR<citiesUpdateWithoutProvider_branchesInput, citiesUncheckedUpdateWithoutProvider_branchesInput>
  }

  export type citiesUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type citiesUncheckedUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type providersUpsertWithoutProvider_branchesInput = {
    update: XOR<providersUpdateWithoutProvider_branchesInput, providersUncheckedUpdateWithoutProvider_branchesInput>
    create: XOR<providersCreateWithoutProvider_branchesInput, providersUncheckedCreateWithoutProvider_branchesInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutProvider_branchesInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutProvider_branchesInput, providersUncheckedUpdateWithoutProvider_branchesInput>
  }

  export type providersUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUpdateManyWithoutProvidersNestedInput
    service_categories?: service_categoriesUpdateOneWithoutProvidersNestedInput
    users?: usersUpdateOneWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type provider_schedulesUpsertWithWhereUniqueWithoutProvider_branchesInput = {
    where: provider_schedulesWhereUniqueInput
    update: XOR<provider_schedulesUpdateWithoutProvider_branchesInput, provider_schedulesUncheckedUpdateWithoutProvider_branchesInput>
    create: XOR<provider_schedulesCreateWithoutProvider_branchesInput, provider_schedulesUncheckedCreateWithoutProvider_branchesInput>
  }

  export type provider_schedulesUpdateWithWhereUniqueWithoutProvider_branchesInput = {
    where: provider_schedulesWhereUniqueInput
    data: XOR<provider_schedulesUpdateWithoutProvider_branchesInput, provider_schedulesUncheckedUpdateWithoutProvider_branchesInput>
  }

  export type provider_schedulesUpdateManyWithWhereWithoutProvider_branchesInput = {
    where: provider_schedulesScalarWhereInput
    data: XOR<provider_schedulesUpdateManyMutationInput, provider_schedulesUncheckedUpdateManyWithoutProvider_branchesInput>
  }

  export type provider_schedulesScalarWhereInput = {
    AND?: provider_schedulesScalarWhereInput | provider_schedulesScalarWhereInput[]
    OR?: provider_schedulesScalarWhereInput[]
    NOT?: provider_schedulesScalarWhereInput | provider_schedulesScalarWhereInput[]
    id?: UuidFilter<"provider_schedules"> | string
    branch_id?: UuidNullableFilter<"provider_schedules"> | string | null
    day_of_week?: IntNullableFilter<"provider_schedules"> | number | null
    start_time?: DateTimeNullableFilter<"provider_schedules"> | Date | string | null
    end_time?: DateTimeNullableFilter<"provider_schedules"> | Date | string | null
  }

  export type reviewsUpsertWithWhereUniqueWithoutProvider_branchesInput = {
    where: reviewsWhereUniqueInput
    update: XOR<reviewsUpdateWithoutProvider_branchesInput, reviewsUncheckedUpdateWithoutProvider_branchesInput>
    create: XOR<reviewsCreateWithoutProvider_branchesInput, reviewsUncheckedCreateWithoutProvider_branchesInput>
  }

  export type reviewsUpdateWithWhereUniqueWithoutProvider_branchesInput = {
    where: reviewsWhereUniqueInput
    data: XOR<reviewsUpdateWithoutProvider_branchesInput, reviewsUncheckedUpdateWithoutProvider_branchesInput>
  }

  export type reviewsUpdateManyWithWhereWithoutProvider_branchesInput = {
    where: reviewsScalarWhereInput
    data: XOR<reviewsUpdateManyMutationInput, reviewsUncheckedUpdateManyWithoutProvider_branchesInput>
  }

  export type providersCreateWithoutProvider_catalogInput = {
    id: string
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyCreateNestedManyWithoutProvidersInput
    payouts?: payoutsCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesCreateNestedManyWithoutProvidersInput
    service_categories?: service_categoriesCreateNestedOneWithoutProvidersInput
    users?: usersCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutProvider_catalogInput = {
    id: string
    user_id?: string | null
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutProvidersInput
    payouts?: payoutsUncheckedCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsUncheckedCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsUncheckedCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutProvider_catalogInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutProvider_catalogInput, providersUncheckedCreateWithoutProvider_catalogInput>
  }

  export type providersUpsertWithoutProvider_catalogInput = {
    update: XOR<providersUpdateWithoutProvider_catalogInput, providersUncheckedUpdateWithoutProvider_catalogInput>
    create: XOR<providersCreateWithoutProvider_catalogInput, providersUncheckedCreateWithoutProvider_catalogInput>
    where?: providersWhereInput
  }

  export type providersUpdateToOneWithWhereWithoutProvider_catalogInput = {
    where?: providersWhereInput
    data: XOR<providersUpdateWithoutProvider_catalogInput, providersUncheckedUpdateWithoutProvider_catalogInput>
  }

  export type providersUpdateWithoutProvider_catalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUpdateManyWithoutProvidersNestedInput
    service_categories?: service_categoriesUpdateOneWithoutProvidersNestedInput
    users?: usersUpdateOneWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutProvider_catalogInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type provider_branchesCreateWithoutProvider_schedulesInput = {
    id: string
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutProvider_branchesInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutProvider_branchesInput
    cities?: citiesCreateNestedOneWithoutProvider_branchesInput
    providers?: providersCreateNestedOneWithoutProvider_branchesInput
    reviews?: reviewsCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesUncheckedCreateWithoutProvider_schedulesInput = {
    id: string
    provider_id?: string | null
    city_id?: string | null
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvider_branchesInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesCreateOrConnectWithoutProvider_schedulesInput = {
    where: provider_branchesWhereUniqueInput
    create: XOR<provider_branchesCreateWithoutProvider_schedulesInput, provider_branchesUncheckedCreateWithoutProvider_schedulesInput>
  }

  export type provider_branchesUpsertWithoutProvider_schedulesInput = {
    update: XOR<provider_branchesUpdateWithoutProvider_schedulesInput, provider_branchesUncheckedUpdateWithoutProvider_schedulesInput>
    create: XOR<provider_branchesCreateWithoutProvider_schedulesInput, provider_branchesUncheckedCreateWithoutProvider_schedulesInput>
    where?: provider_branchesWhereInput
  }

  export type provider_branchesUpdateToOneWithWhereWithoutProvider_schedulesInput = {
    where?: provider_branchesWhereInput
    data: XOR<provider_branchesUpdateWithoutProvider_schedulesInput, provider_branchesUncheckedUpdateWithoutProvider_schedulesInput>
  }

  export type provider_branchesUpdateWithoutProvider_schedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutProvider_branchesNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutProvider_branchesNestedInput
    cities?: citiesUpdateOneWithoutProvider_branchesNestedInput
    providers?: providersUpdateOneWithoutProvider_branchesNestedInput
    reviews?: reviewsUpdateManyWithoutProvider_branchesNestedInput
  }

  export type provider_branchesUncheckedUpdateWithoutProvider_schedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvider_branchesNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutProvider_branchesNestedInput
  }

  export type appointmentsCreateWithoutProvidersInput = {
    id: string
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    provider_branches?: provider_branchesCreateNestedOneWithoutAppointmentsInput
    patients?: patientsCreateNestedOneWithoutAppointmentsInput
    payments?: paymentsCreateNestedManyWithoutAppointmentsInput
    reviews?: reviewsCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutProvidersInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    payments?: paymentsUncheckedCreateNestedManyWithoutAppointmentsInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutProvidersInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutProvidersInput, appointmentsUncheckedCreateWithoutProvidersInput>
  }

  export type appointmentsCreateManyProvidersInputEnvelope = {
    data: appointmentsCreateManyProvidersInput | appointmentsCreateManyProvidersInput[]
    skipDuplicates?: boolean
  }

  export type medical_historyCreateWithoutProvidersInput = {
    id: string
    doctor_name_snapshot?: string | null
    specialty_snapshot?: string | null
    diagnosis?: string | null
    date?: Date | string | null
    treatment?: string | null
    indications?: string | null
    observations?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    patients?: patientsCreateNestedOneWithoutMedical_historyInput
  }

  export type medical_historyUncheckedCreateWithoutProvidersInput = {
    id: string
    patient_id?: string | null
    doctor_name_snapshot?: string | null
    specialty_snapshot?: string | null
    diagnosis?: string | null
    date?: Date | string | null
    treatment?: string | null
    indications?: string | null
    observations?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type medical_historyCreateOrConnectWithoutProvidersInput = {
    where: medical_historyWhereUniqueInput
    create: XOR<medical_historyCreateWithoutProvidersInput, medical_historyUncheckedCreateWithoutProvidersInput>
  }

  export type medical_historyCreateManyProvidersInputEnvelope = {
    data: medical_historyCreateManyProvidersInput | medical_historyCreateManyProvidersInput[]
    skipDuplicates?: boolean
  }

  export type payoutsCreateWithoutProvidersInput = {
    id: string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    reference_number?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    created_at?: Date | string | null
    payments?: paymentsCreateNestedManyWithoutPayoutsInput
  }

  export type payoutsUncheckedCreateWithoutProvidersInput = {
    id: string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    reference_number?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    created_at?: Date | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutPayoutsInput
  }

  export type payoutsCreateOrConnectWithoutProvidersInput = {
    where: payoutsWhereUniqueInput
    create: XOR<payoutsCreateWithoutProvidersInput, payoutsUncheckedCreateWithoutProvidersInput>
  }

  export type payoutsCreateManyProvidersInputEnvelope = {
    data: payoutsCreateManyProvidersInput | payoutsCreateManyProvidersInput[]
    skipDuplicates?: boolean
  }

  export type provider_adsCreateWithoutProvidersInput = {
    id: string
    badge_text?: string | null
    title?: string | null
    subtitle?: string | null
    image_url?: string | null
    action_text?: string | null
    bg_color_hex?: string | null
    accent_color_hex?: string | null
    target_screen?: string | null
    target_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    priority_order?: number | null
  }

  export type provider_adsUncheckedCreateWithoutProvidersInput = {
    id: string
    badge_text?: string | null
    title?: string | null
    subtitle?: string | null
    image_url?: string | null
    action_text?: string | null
    bg_color_hex?: string | null
    accent_color_hex?: string | null
    target_screen?: string | null
    target_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    priority_order?: number | null
  }

  export type provider_adsCreateOrConnectWithoutProvidersInput = {
    where: provider_adsWhereUniqueInput
    create: XOR<provider_adsCreateWithoutProvidersInput, provider_adsUncheckedCreateWithoutProvidersInput>
  }

  export type provider_adsCreateManyProvidersInputEnvelope = {
    data: provider_adsCreateManyProvidersInput | provider_adsCreateManyProvidersInput[]
    skipDuplicates?: boolean
  }

  export type provider_bank_detailsCreateWithoutProvidersInput = {
    id: string
    bank_name?: string | null
    account_number?: string | null
    account_type?: string | null
    account_holder_name?: string | null
    holder_identification?: string | null
    is_verified?: boolean | null
    updated_at?: Date | string | null
  }

  export type provider_bank_detailsUncheckedCreateWithoutProvidersInput = {
    id: string
    bank_name?: string | null
    account_number?: string | null
    account_type?: string | null
    account_holder_name?: string | null
    holder_identification?: string | null
    is_verified?: boolean | null
    updated_at?: Date | string | null
  }

  export type provider_bank_detailsCreateOrConnectWithoutProvidersInput = {
    where: provider_bank_detailsWhereUniqueInput
    create: XOR<provider_bank_detailsCreateWithoutProvidersInput, provider_bank_detailsUncheckedCreateWithoutProvidersInput>
  }

  export type provider_bank_detailsCreateManyProvidersInputEnvelope = {
    data: provider_bank_detailsCreateManyProvidersInput | provider_bank_detailsCreateManyProvidersInput[]
    skipDuplicates?: boolean
  }

  export type provider_branchesCreateWithoutProvidersInput = {
    id: string
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutProvider_branchesInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutProvider_branchesInput
    cities?: citiesCreateNestedOneWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesUncheckedCreateWithoutProvidersInput = {
    id: string
    city_id?: string | null
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvider_branchesInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesUncheckedCreateNestedManyWithoutProvider_branchesInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesCreateOrConnectWithoutProvidersInput = {
    where: provider_branchesWhereUniqueInput
    create: XOR<provider_branchesCreateWithoutProvidersInput, provider_branchesUncheckedCreateWithoutProvidersInput>
  }

  export type provider_branchesCreateManyProvidersInputEnvelope = {
    data: provider_branchesCreateManyProvidersInput | provider_branchesCreateManyProvidersInput[]
    skipDuplicates?: boolean
  }

  export type provider_catalogCreateWithoutProvidersInput = {
    id: string
    type?: string | null
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    is_available?: boolean | null
    image_url?: string | null
  }

  export type provider_catalogUncheckedCreateWithoutProvidersInput = {
    id: string
    type?: string | null
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    is_available?: boolean | null
    image_url?: string | null
  }

  export type provider_catalogCreateOrConnectWithoutProvidersInput = {
    where: provider_catalogWhereUniqueInput
    create: XOR<provider_catalogCreateWithoutProvidersInput, provider_catalogUncheckedCreateWithoutProvidersInput>
  }

  export type provider_catalogCreateManyProvidersInputEnvelope = {
    data: provider_catalogCreateManyProvidersInput | provider_catalogCreateManyProvidersInput[]
    skipDuplicates?: boolean
  }

  export type service_categoriesCreateWithoutProvidersInput = {
    name: string
    slug: string
    default_color_hex?: string | null
    allows_booking?: boolean | null
  }

  export type service_categoriesUncheckedCreateWithoutProvidersInput = {
    id?: number
    name: string
    slug: string
    default_color_hex?: string | null
    allows_booking?: boolean | null
  }

  export type service_categoriesCreateOrConnectWithoutProvidersInput = {
    where: service_categoriesWhereUniqueInput
    create: XOR<service_categoriesCreateWithoutProvidersInput, service_categoriesUncheckedCreateWithoutProvidersInput>
  }

  export type usersCreateWithoutProvidersInput = {
    id: string
    email: string
    password_hash: string
    role?: $Enums.enum_roles | null
    profile_picture_url?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    patients?: patientsCreateNestedManyWithoutUsersInput
    sessions?: sessionsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutProvidersInput = {
    id: string
    email: string
    password_hash: string
    role?: $Enums.enum_roles | null
    profile_picture_url?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    sessions?: sessionsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutProvidersInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutProvidersInput, usersUncheckedCreateWithoutProvidersInput>
  }

  export type appointmentsUpsertWithWhereUniqueWithoutProvidersInput = {
    where: appointmentsWhereUniqueInput
    update: XOR<appointmentsUpdateWithoutProvidersInput, appointmentsUncheckedUpdateWithoutProvidersInput>
    create: XOR<appointmentsCreateWithoutProvidersInput, appointmentsUncheckedCreateWithoutProvidersInput>
  }

  export type appointmentsUpdateWithWhereUniqueWithoutProvidersInput = {
    where: appointmentsWhereUniqueInput
    data: XOR<appointmentsUpdateWithoutProvidersInput, appointmentsUncheckedUpdateWithoutProvidersInput>
  }

  export type appointmentsUpdateManyWithWhereWithoutProvidersInput = {
    where: appointmentsScalarWhereInput
    data: XOR<appointmentsUpdateManyMutationInput, appointmentsUncheckedUpdateManyWithoutProvidersInput>
  }

  export type medical_historyUpsertWithWhereUniqueWithoutProvidersInput = {
    where: medical_historyWhereUniqueInput
    update: XOR<medical_historyUpdateWithoutProvidersInput, medical_historyUncheckedUpdateWithoutProvidersInput>
    create: XOR<medical_historyCreateWithoutProvidersInput, medical_historyUncheckedCreateWithoutProvidersInput>
  }

  export type medical_historyUpdateWithWhereUniqueWithoutProvidersInput = {
    where: medical_historyWhereUniqueInput
    data: XOR<medical_historyUpdateWithoutProvidersInput, medical_historyUncheckedUpdateWithoutProvidersInput>
  }

  export type medical_historyUpdateManyWithWhereWithoutProvidersInput = {
    where: medical_historyScalarWhereInput
    data: XOR<medical_historyUpdateManyMutationInput, medical_historyUncheckedUpdateManyWithoutProvidersInput>
  }

  export type payoutsUpsertWithWhereUniqueWithoutProvidersInput = {
    where: payoutsWhereUniqueInput
    update: XOR<payoutsUpdateWithoutProvidersInput, payoutsUncheckedUpdateWithoutProvidersInput>
    create: XOR<payoutsCreateWithoutProvidersInput, payoutsUncheckedCreateWithoutProvidersInput>
  }

  export type payoutsUpdateWithWhereUniqueWithoutProvidersInput = {
    where: payoutsWhereUniqueInput
    data: XOR<payoutsUpdateWithoutProvidersInput, payoutsUncheckedUpdateWithoutProvidersInput>
  }

  export type payoutsUpdateManyWithWhereWithoutProvidersInput = {
    where: payoutsScalarWhereInput
    data: XOR<payoutsUpdateManyMutationInput, payoutsUncheckedUpdateManyWithoutProvidersInput>
  }

  export type payoutsScalarWhereInput = {
    AND?: payoutsScalarWhereInput | payoutsScalarWhereInput[]
    OR?: payoutsScalarWhereInput[]
    NOT?: payoutsScalarWhereInput | payoutsScalarWhereInput[]
    id?: UuidFilter<"payouts"> | string
    provider_id?: UuidNullableFilter<"payouts"> | string | null
    total_amount?: DecimalNullableFilter<"payouts"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringNullableFilter<"payouts"> | string | null
    status?: StringNullableFilter<"payouts"> | string | null
    reference_number?: StringNullableFilter<"payouts"> | string | null
    period_start?: DateTimeNullableFilter<"payouts"> | Date | string | null
    period_end?: DateTimeNullableFilter<"payouts"> | Date | string | null
    created_at?: DateTimeNullableFilter<"payouts"> | Date | string | null
  }

  export type provider_adsUpsertWithWhereUniqueWithoutProvidersInput = {
    where: provider_adsWhereUniqueInput
    update: XOR<provider_adsUpdateWithoutProvidersInput, provider_adsUncheckedUpdateWithoutProvidersInput>
    create: XOR<provider_adsCreateWithoutProvidersInput, provider_adsUncheckedCreateWithoutProvidersInput>
  }

  export type provider_adsUpdateWithWhereUniqueWithoutProvidersInput = {
    where: provider_adsWhereUniqueInput
    data: XOR<provider_adsUpdateWithoutProvidersInput, provider_adsUncheckedUpdateWithoutProvidersInput>
  }

  export type provider_adsUpdateManyWithWhereWithoutProvidersInput = {
    where: provider_adsScalarWhereInput
    data: XOR<provider_adsUpdateManyMutationInput, provider_adsUncheckedUpdateManyWithoutProvidersInput>
  }

  export type provider_adsScalarWhereInput = {
    AND?: provider_adsScalarWhereInput | provider_adsScalarWhereInput[]
    OR?: provider_adsScalarWhereInput[]
    NOT?: provider_adsScalarWhereInput | provider_adsScalarWhereInput[]
    id?: UuidFilter<"provider_ads"> | string
    provider_id?: UuidNullableFilter<"provider_ads"> | string | null
    badge_text?: StringNullableFilter<"provider_ads"> | string | null
    title?: StringNullableFilter<"provider_ads"> | string | null
    subtitle?: StringNullableFilter<"provider_ads"> | string | null
    image_url?: StringNullableFilter<"provider_ads"> | string | null
    action_text?: StringNullableFilter<"provider_ads"> | string | null
    bg_color_hex?: StringNullableFilter<"provider_ads"> | string | null
    accent_color_hex?: StringNullableFilter<"provider_ads"> | string | null
    target_screen?: StringNullableFilter<"provider_ads"> | string | null
    target_id?: StringNullableFilter<"provider_ads"> | string | null
    start_date?: DateTimeNullableFilter<"provider_ads"> | Date | string | null
    end_date?: DateTimeNullableFilter<"provider_ads"> | Date | string | null
    is_active?: BoolNullableFilter<"provider_ads"> | boolean | null
    priority_order?: IntNullableFilter<"provider_ads"> | number | null
  }

  export type provider_bank_detailsUpsertWithWhereUniqueWithoutProvidersInput = {
    where: provider_bank_detailsWhereUniqueInput
    update: XOR<provider_bank_detailsUpdateWithoutProvidersInput, provider_bank_detailsUncheckedUpdateWithoutProvidersInput>
    create: XOR<provider_bank_detailsCreateWithoutProvidersInput, provider_bank_detailsUncheckedCreateWithoutProvidersInput>
  }

  export type provider_bank_detailsUpdateWithWhereUniqueWithoutProvidersInput = {
    where: provider_bank_detailsWhereUniqueInput
    data: XOR<provider_bank_detailsUpdateWithoutProvidersInput, provider_bank_detailsUncheckedUpdateWithoutProvidersInput>
  }

  export type provider_bank_detailsUpdateManyWithWhereWithoutProvidersInput = {
    where: provider_bank_detailsScalarWhereInput
    data: XOR<provider_bank_detailsUpdateManyMutationInput, provider_bank_detailsUncheckedUpdateManyWithoutProvidersInput>
  }

  export type provider_bank_detailsScalarWhereInput = {
    AND?: provider_bank_detailsScalarWhereInput | provider_bank_detailsScalarWhereInput[]
    OR?: provider_bank_detailsScalarWhereInput[]
    NOT?: provider_bank_detailsScalarWhereInput | provider_bank_detailsScalarWhereInput[]
    id?: UuidFilter<"provider_bank_details"> | string
    provider_id?: UuidNullableFilter<"provider_bank_details"> | string | null
    bank_name?: StringNullableFilter<"provider_bank_details"> | string | null
    account_number?: StringNullableFilter<"provider_bank_details"> | string | null
    account_type?: StringNullableFilter<"provider_bank_details"> | string | null
    account_holder_name?: StringNullableFilter<"provider_bank_details"> | string | null
    holder_identification?: StringNullableFilter<"provider_bank_details"> | string | null
    is_verified?: BoolNullableFilter<"provider_bank_details"> | boolean | null
    updated_at?: DateTimeNullableFilter<"provider_bank_details"> | Date | string | null
  }

  export type provider_branchesUpsertWithWhereUniqueWithoutProvidersInput = {
    where: provider_branchesWhereUniqueInput
    update: XOR<provider_branchesUpdateWithoutProvidersInput, provider_branchesUncheckedUpdateWithoutProvidersInput>
    create: XOR<provider_branchesCreateWithoutProvidersInput, provider_branchesUncheckedCreateWithoutProvidersInput>
  }

  export type provider_branchesUpdateWithWhereUniqueWithoutProvidersInput = {
    where: provider_branchesWhereUniqueInput
    data: XOR<provider_branchesUpdateWithoutProvidersInput, provider_branchesUncheckedUpdateWithoutProvidersInput>
  }

  export type provider_branchesUpdateManyWithWhereWithoutProvidersInput = {
    where: provider_branchesScalarWhereInput
    data: XOR<provider_branchesUpdateManyMutationInput, provider_branchesUncheckedUpdateManyWithoutProvidersInput>
  }

  export type provider_catalogUpsertWithWhereUniqueWithoutProvidersInput = {
    where: provider_catalogWhereUniqueInput
    update: XOR<provider_catalogUpdateWithoutProvidersInput, provider_catalogUncheckedUpdateWithoutProvidersInput>
    create: XOR<provider_catalogCreateWithoutProvidersInput, provider_catalogUncheckedCreateWithoutProvidersInput>
  }

  export type provider_catalogUpdateWithWhereUniqueWithoutProvidersInput = {
    where: provider_catalogWhereUniqueInput
    data: XOR<provider_catalogUpdateWithoutProvidersInput, provider_catalogUncheckedUpdateWithoutProvidersInput>
  }

  export type provider_catalogUpdateManyWithWhereWithoutProvidersInput = {
    where: provider_catalogScalarWhereInput
    data: XOR<provider_catalogUpdateManyMutationInput, provider_catalogUncheckedUpdateManyWithoutProvidersInput>
  }

  export type provider_catalogScalarWhereInput = {
    AND?: provider_catalogScalarWhereInput | provider_catalogScalarWhereInput[]
    OR?: provider_catalogScalarWhereInput[]
    NOT?: provider_catalogScalarWhereInput | provider_catalogScalarWhereInput[]
    id?: UuidFilter<"provider_catalog"> | string
    provider_id?: UuidNullableFilter<"provider_catalog"> | string | null
    type?: StringNullableFilter<"provider_catalog"> | string | null
    name?: StringNullableFilter<"provider_catalog"> | string | null
    description?: StringNullableFilter<"provider_catalog"> | string | null
    price?: DecimalNullableFilter<"provider_catalog"> | Decimal | DecimalJsLike | number | string | null
    is_available?: BoolNullableFilter<"provider_catalog"> | boolean | null
    image_url?: StringNullableFilter<"provider_catalog"> | string | null
  }

  export type service_categoriesUpsertWithoutProvidersInput = {
    update: XOR<service_categoriesUpdateWithoutProvidersInput, service_categoriesUncheckedUpdateWithoutProvidersInput>
    create: XOR<service_categoriesCreateWithoutProvidersInput, service_categoriesUncheckedCreateWithoutProvidersInput>
    where?: service_categoriesWhereInput
  }

  export type service_categoriesUpdateToOneWithWhereWithoutProvidersInput = {
    where?: service_categoriesWhereInput
    data: XOR<service_categoriesUpdateWithoutProvidersInput, service_categoriesUncheckedUpdateWithoutProvidersInput>
  }

  export type service_categoriesUpdateWithoutProvidersInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    default_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    allows_booking?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type service_categoriesUncheckedUpdateWithoutProvidersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    default_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    allows_booking?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUpsertWithoutProvidersInput = {
    update: XOR<usersUpdateWithoutProvidersInput, usersUncheckedUpdateWithoutProvidersInput>
    create: XOR<usersCreateWithoutProvidersInput, usersUncheckedCreateWithoutProvidersInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutProvidersInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutProvidersInput, usersUncheckedUpdateWithoutProvidersInput>
  }

  export type usersUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumenum_rolesFieldUpdateOperationsInput | $Enums.enum_roles | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumenum_rolesFieldUpdateOperationsInput | $Enums.enum_roles | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    sessions?: sessionsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type appointmentsCreateWithoutReviewsInput = {
    id: string
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    provider_branches?: provider_branchesCreateNestedOneWithoutAppointmentsInput
    patients?: patientsCreateNestedOneWithoutAppointmentsInput
    providers?: providersCreateNestedOneWithoutAppointmentsInput
    payments?: paymentsCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsUncheckedCreateWithoutReviewsInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    provider_id?: string | null
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
    payments?: paymentsUncheckedCreateNestedManyWithoutAppointmentsInput
  }

  export type appointmentsCreateOrConnectWithoutReviewsInput = {
    where: appointmentsWhereUniqueInput
    create: XOR<appointmentsCreateWithoutReviewsInput, appointmentsUncheckedCreateWithoutReviewsInput>
  }

  export type provider_branchesCreateWithoutReviewsInput = {
    id: string
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsCreateNestedManyWithoutProvider_branchesInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutProvider_branchesInput
    cities?: citiesCreateNestedOneWithoutProvider_branchesInput
    providers?: providersCreateNestedOneWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesUncheckedCreateWithoutReviewsInput = {
    id: string
    provider_id?: string | null
    city_id?: string | null
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvider_branchesInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutProvider_branchesInput
    provider_schedules?: provider_schedulesUncheckedCreateNestedManyWithoutProvider_branchesInput
  }

  export type provider_branchesCreateOrConnectWithoutReviewsInput = {
    where: provider_branchesWhereUniqueInput
    create: XOR<provider_branchesCreateWithoutReviewsInput, provider_branchesUncheckedCreateWithoutReviewsInput>
  }

  export type patientsCreateWithoutReviewsInput = {
    id: string
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsCreateNestedManyWithoutPatientsInput
    medical_history?: medical_historyCreateNestedManyWithoutPatientsInput
    notifications?: notificationsCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutPatientsInput
    users?: usersCreateNestedOneWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutReviewsInput = {
    id: string
    user_id?: string | null
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutPatientsInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutPatientsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutReviewsInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutReviewsInput, patientsUncheckedCreateWithoutReviewsInput>
  }

  export type appointmentsUpsertWithoutReviewsInput = {
    update: XOR<appointmentsUpdateWithoutReviewsInput, appointmentsUncheckedUpdateWithoutReviewsInput>
    create: XOR<appointmentsCreateWithoutReviewsInput, appointmentsUncheckedCreateWithoutReviewsInput>
    where?: appointmentsWhereInput
  }

  export type appointmentsUpdateToOneWithWhereWithoutReviewsInput = {
    where?: appointmentsWhereInput
    data: XOR<appointmentsUpdateWithoutReviewsInput, appointmentsUncheckedUpdateWithoutReviewsInput>
  }

  export type appointmentsUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_branches?: provider_branchesUpdateOneWithoutAppointmentsNestedInput
    patients?: patientsUpdateOneWithoutAppointmentsNestedInput
    providers?: providersUpdateOneWithoutAppointmentsNestedInput
    payments?: paymentsUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payments?: paymentsUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type provider_branchesUpsertWithoutReviewsInput = {
    update: XOR<provider_branchesUpdateWithoutReviewsInput, provider_branchesUncheckedUpdateWithoutReviewsInput>
    create: XOR<provider_branchesCreateWithoutReviewsInput, provider_branchesUncheckedCreateWithoutReviewsInput>
    where?: provider_branchesWhereInput
  }

  export type provider_branchesUpdateToOneWithWhereWithoutReviewsInput = {
    where?: provider_branchesWhereInput
    data: XOR<provider_branchesUpdateWithoutReviewsInput, provider_branchesUncheckedUpdateWithoutReviewsInput>
  }

  export type provider_branchesUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutProvider_branchesNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutProvider_branchesNestedInput
    cities?: citiesUpdateOneWithoutProvider_branchesNestedInput
    providers?: providersUpdateOneWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUpdateManyWithoutProvider_branchesNestedInput
  }

  export type provider_branchesUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvider_branchesNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUncheckedUpdateManyWithoutProvider_branchesNestedInput
  }

  export type patientsUpsertWithoutReviewsInput = {
    update: XOR<patientsUpdateWithoutReviewsInput, patientsUncheckedUpdateWithoutReviewsInput>
    create: XOR<patientsCreateWithoutReviewsInput, patientsUncheckedCreateWithoutReviewsInput>
    where?: patientsWhereInput
  }

  export type patientsUpdateToOneWithWhereWithoutReviewsInput = {
    where?: patientsWhereInput
    data: XOR<patientsUpdateWithoutReviewsInput, patientsUncheckedUpdateWithoutReviewsInput>
  }

  export type patientsUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutPatientsNestedInput
    medical_history?: medical_historyUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutPatientsNestedInput
    users?: usersUpdateOneWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutPatientsNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type providersCreateWithoutService_categoriesInput = {
    id: string
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyCreateNestedManyWithoutProvidersInput
    payouts?: payoutsCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogCreateNestedManyWithoutProvidersInput
    users?: usersCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutService_categoriesInput = {
    id: string
    user_id?: string | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutProvidersInput
    payouts?: payoutsUncheckedCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsUncheckedCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsUncheckedCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesUncheckedCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutService_categoriesInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutService_categoriesInput, providersUncheckedCreateWithoutService_categoriesInput>
  }

  export type providersCreateManyService_categoriesInputEnvelope = {
    data: providersCreateManyService_categoriesInput | providersCreateManyService_categoriesInput[]
    skipDuplicates?: boolean
  }

  export type providersUpsertWithWhereUniqueWithoutService_categoriesInput = {
    where: providersWhereUniqueInput
    update: XOR<providersUpdateWithoutService_categoriesInput, providersUncheckedUpdateWithoutService_categoriesInput>
    create: XOR<providersCreateWithoutService_categoriesInput, providersUncheckedCreateWithoutService_categoriesInput>
  }

  export type providersUpdateWithWhereUniqueWithoutService_categoriesInput = {
    where: providersWhereUniqueInput
    data: XOR<providersUpdateWithoutService_categoriesInput, providersUncheckedUpdateWithoutService_categoriesInput>
  }

  export type providersUpdateManyWithWhereWithoutService_categoriesInput = {
    where: providersScalarWhereInput
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyWithoutService_categoriesInput>
  }

  export type providersScalarWhereInput = {
    AND?: providersScalarWhereInput | providersScalarWhereInput[]
    OR?: providersScalarWhereInput[]
    NOT?: providersScalarWhereInput | providersScalarWhereInput[]
    id?: UuidFilter<"providers"> | string
    user_id?: UuidNullableFilter<"providers"> | string | null
    category_id?: IntNullableFilter<"providers"> | number | null
    commercial_name?: StringNullableFilter<"providers"> | string | null
    logo_url?: StringNullableFilter<"providers"> | string | null
    description?: StringNullableFilter<"providers"> | string | null
    verification_status?: StringNullableFilter<"providers"> | string | null
    commission_percentage?: DecimalNullableFilter<"providers"> | Decimal | DecimalJsLike | number | string | null
  }

  export type usersCreateWithoutSessionsInput = {
    id: string
    email: string
    password_hash: string
    role?: $Enums.enum_roles | null
    profile_picture_url?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    patients?: patientsCreateNestedManyWithoutUsersInput
    providers?: providersCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSessionsInput = {
    id: string
    email: string
    password_hash: string
    role?: $Enums.enum_roles | null
    profile_picture_url?: string | null
    is_active?: boolean | null
    created_at?: Date | string | null
    patients?: patientsUncheckedCreateNestedManyWithoutUsersInput
    providers?: providersUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSessionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
  }

  export type usersUpsertWithoutSessionsInput = {
    update: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
    create: XOR<usersCreateWithoutSessionsInput, usersUncheckedCreateWithoutSessionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSessionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSessionsInput, usersUncheckedUpdateWithoutSessionsInput>
  }

  export type usersUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumenum_rolesFieldUpdateOperationsInput | $Enums.enum_roles | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUpdateManyWithoutUsersNestedInput
    providers?: providersUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    role?: NullableEnumenum_rolesFieldUpdateOperationsInput | $Enums.enum_roles | null
    profile_picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUncheckedUpdateManyWithoutUsersNestedInput
    providers?: providersUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type patientsCreateWithoutUsersInput = {
    id: string
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsCreateNestedManyWithoutPatientsInput
    medical_history?: medical_historyCreateNestedManyWithoutPatientsInput
    notifications?: notificationsCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesCreateNestedManyWithoutPatientsInput
    reviews?: reviewsCreateNestedManyWithoutPatientsInput
  }

  export type patientsUncheckedCreateWithoutUsersInput = {
    id: string
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutPatientsInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutPatientsInput
    notifications?: notificationsUncheckedCreateNestedManyWithoutPatientsInput
    patient_favorites?: patient_favoritesUncheckedCreateNestedManyWithoutPatientsInput
    reviews?: reviewsUncheckedCreateNestedManyWithoutPatientsInput
  }

  export type patientsCreateOrConnectWithoutUsersInput = {
    where: patientsWhereUniqueInput
    create: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput>
  }

  export type patientsCreateManyUsersInputEnvelope = {
    data: patientsCreateManyUsersInput | patientsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type providersCreateWithoutUsersInput = {
    id: string
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyCreateNestedManyWithoutProvidersInput
    payouts?: payoutsCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogCreateNestedManyWithoutProvidersInput
    service_categories?: service_categoriesCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutUsersInput = {
    id: string
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedCreateNestedManyWithoutProvidersInput
    medical_history?: medical_historyUncheckedCreateNestedManyWithoutProvidersInput
    payouts?: payoutsUncheckedCreateNestedManyWithoutProvidersInput
    provider_ads?: provider_adsUncheckedCreateNestedManyWithoutProvidersInput
    provider_bank_details?: provider_bank_detailsUncheckedCreateNestedManyWithoutProvidersInput
    provider_branches?: provider_branchesUncheckedCreateNestedManyWithoutProvidersInput
    provider_catalog?: provider_catalogUncheckedCreateNestedManyWithoutProvidersInput
  }

  export type providersCreateOrConnectWithoutUsersInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput>
  }

  export type providersCreateManyUsersInputEnvelope = {
    data: providersCreateManyUsersInput | providersCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type sessionsCreateWithoutUsersInput = {
    id: string
    token: string
    device_info?: string | null
    expires_at: Date | string
    created_at?: Date | string | null
  }

  export type sessionsUncheckedCreateWithoutUsersInput = {
    id: string
    token: string
    device_info?: string | null
    expires_at: Date | string
    created_at?: Date | string | null
  }

  export type sessionsCreateOrConnectWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    create: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput>
  }

  export type sessionsCreateManyUsersInputEnvelope = {
    data: sessionsCreateManyUsersInput | sessionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type patientsUpsertWithWhereUniqueWithoutUsersInput = {
    where: patientsWhereUniqueInput
    update: XOR<patientsUpdateWithoutUsersInput, patientsUncheckedUpdateWithoutUsersInput>
    create: XOR<patientsCreateWithoutUsersInput, patientsUncheckedCreateWithoutUsersInput>
  }

  export type patientsUpdateWithWhereUniqueWithoutUsersInput = {
    where: patientsWhereUniqueInput
    data: XOR<patientsUpdateWithoutUsersInput, patientsUncheckedUpdateWithoutUsersInput>
  }

  export type patientsUpdateManyWithWhereWithoutUsersInput = {
    where: patientsScalarWhereInput
    data: XOR<patientsUpdateManyMutationInput, patientsUncheckedUpdateManyWithoutUsersInput>
  }

  export type patientsScalarWhereInput = {
    AND?: patientsScalarWhereInput | patientsScalarWhereInput[]
    OR?: patientsScalarWhereInput[]
    NOT?: patientsScalarWhereInput | patientsScalarWhereInput[]
    id?: UuidFilter<"patients"> | string
    user_id?: UuidNullableFilter<"patients"> | string | null
    full_name?: StringFilter<"patients"> | string
    identification?: StringNullableFilter<"patients"> | string | null
    phone?: StringNullableFilter<"patients"> | string | null
    birth_date?: DateTimeNullableFilter<"patients"> | Date | string | null
    address_text?: StringNullableFilter<"patients"> | string | null
  }

  export type providersUpsertWithWhereUniqueWithoutUsersInput = {
    where: providersWhereUniqueInput
    update: XOR<providersUpdateWithoutUsersInput, providersUncheckedUpdateWithoutUsersInput>
    create: XOR<providersCreateWithoutUsersInput, providersUncheckedCreateWithoutUsersInput>
  }

  export type providersUpdateWithWhereUniqueWithoutUsersInput = {
    where: providersWhereUniqueInput
    data: XOR<providersUpdateWithoutUsersInput, providersUncheckedUpdateWithoutUsersInput>
  }

  export type providersUpdateManyWithWhereWithoutUsersInput = {
    where: providersScalarWhereInput
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyWithoutUsersInput>
  }

  export type sessionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    update: XOR<sessionsUpdateWithoutUsersInput, sessionsUncheckedUpdateWithoutUsersInput>
    create: XOR<sessionsCreateWithoutUsersInput, sessionsUncheckedCreateWithoutUsersInput>
  }

  export type sessionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: sessionsWhereUniqueInput
    data: XOR<sessionsUpdateWithoutUsersInput, sessionsUncheckedUpdateWithoutUsersInput>
  }

  export type sessionsUpdateManyWithWhereWithoutUsersInput = {
    where: sessionsScalarWhereInput
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type sessionsScalarWhereInput = {
    AND?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    OR?: sessionsScalarWhereInput[]
    NOT?: sessionsScalarWhereInput | sessionsScalarWhereInput[]
    id?: UuidFilter<"sessions"> | string
    user_id?: UuidNullableFilter<"sessions"> | string | null
    token?: StringFilter<"sessions"> | string
    device_info?: StringNullableFilter<"sessions"> | string | null
    expires_at?: DateTimeFilter<"sessions"> | Date | string
    created_at?: DateTimeNullableFilter<"sessions"> | Date | string | null
  }

  export type paymentsCreateManyAppointmentsInput = {
    id: string
    payout_id?: string | null
    stripe_payment_intent_id?: string | null
    amount_total?: Decimal | DecimalJsLike | number | string | null
    platform_fee?: Decimal | DecimalJsLike | number | string | null
    provider_amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type reviewsCreateManyAppointmentsInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
  }

  export type paymentsUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    provider_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payouts?: payoutsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    payout_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    provider_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    payout_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    provider_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_branches?: provider_branchesUpdateOneWithoutReviewsNestedInput
    patients?: patientsUpdateOneWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsUncheckedUpdateManyWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_branchesCreateManyCitiesInput = {
    id: string
    provider_id?: string | null
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
  }

  export type provider_branchesUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutProvider_branchesNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutProvider_branchesNestedInput
    providers?: providersUpdateOneWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUpdateManyWithoutProvider_branchesNestedInput
  }

  export type provider_branchesUncheckedUpdateWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvider_branchesNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutProvider_branchesNestedInput
  }

  export type provider_branchesUncheckedUpdateManyWithoutCitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type appointmentsCreateManyPatientsInput = {
    id: string
    branch_id?: string | null
    provider_id?: string | null
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
  }

  export type medical_historyCreateManyPatientsInput = {
    id: string
    provider_id?: string | null
    doctor_name_snapshot?: string | null
    specialty_snapshot?: string | null
    diagnosis?: string | null
    date?: Date | string | null
    treatment?: string | null
    indications?: string | null
    observations?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type notificationsCreateManyPatientsInput = {
    id: string
    type: $Enums.enum_notif_types
    title: string
    body: string
    is_read?: boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
  }

  export type patient_favoritesCreateManyPatientsInput = {
    id: string
    branch_id?: string | null
    created_at?: Date | string | null
  }

  export type reviewsCreateManyPatientsInput = {
    id: string
    branch_id?: string | null
    appointment_id?: string | null
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
  }

  export type appointmentsUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_branches?: provider_branchesUpdateOneWithoutAppointmentsNestedInput
    providers?: providersUpdateOneWithoutAppointmentsNestedInput
    payments?: paymentsUpdateManyWithoutAppointmentsNestedInput
    reviews?: reviewsUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payments?: paymentsUncheckedUpdateManyWithoutAppointmentsNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateManyWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type medical_historyUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctor_name_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    specialty_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    indications?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providers?: providersUpdateOneWithoutMedical_historyNestedInput
  }

  export type medical_historyUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_name_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    specialty_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    indications?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medical_historyUncheckedUpdateManyWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_name_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    specialty_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    indications?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_notif_typesFieldUpdateOperationsInput | $Enums.enum_notif_types
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_notif_typesFieldUpdateOperationsInput | $Enums.enum_notif_types
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type notificationsUncheckedUpdateManyWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: Enumenum_notif_typesFieldUpdateOperationsInput | $Enums.enum_notif_types
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    is_read?: NullableBoolFieldUpdateOperationsInput | boolean | null
    data?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_favoritesUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider_branches?: provider_branchesUpdateOneWithoutPatient_favoritesNestedInput
  }

  export type patient_favoritesUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_favoritesUncheckedUpdateManyWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateOneWithoutReviewsNestedInput
    provider_branches?: provider_branchesUpdateOneWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsUncheckedUpdateManyWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateManyPayoutsInput = {
    id: string
    appointment_id?: string | null
    stripe_payment_intent_id?: string | null
    amount_total?: Decimal | DecimalJsLike | number | string | null
    platform_fee?: Decimal | DecimalJsLike | number | string | null
    provider_amount?: Decimal | DecimalJsLike | number | string | null
    status?: string | null
    created_at?: Date | string | null
  }

  export type paymentsUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    provider_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointment_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    provider_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutPayoutsInput = {
    id?: StringFieldUpdateOperationsInput | string
    appointment_id?: NullableStringFieldUpdateOperationsInput | string | null
    stripe_payment_intent_id?: NullableStringFieldUpdateOperationsInput | string | null
    amount_total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    platform_fee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    provider_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type appointmentsCreateManyProvider_branchesInput = {
    id: string
    patient_id?: string | null
    provider_id?: string | null
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
  }

  export type patient_favoritesCreateManyProvider_branchesInput = {
    id: string
    patient_id?: string | null
    created_at?: Date | string | null
  }

  export type provider_schedulesCreateManyProvider_branchesInput = {
    id: string
    day_of_week?: number | null
    start_time?: Date | string | null
    end_time?: Date | string | null
  }

  export type reviewsCreateManyProvider_branchesInput = {
    id: string
    patient_id?: string | null
    appointment_id?: string | null
    rating?: number | null
    comment?: string | null
    created_at?: Date | string | null
  }

  export type appointmentsUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    patients?: patientsUpdateOneWithoutAppointmentsNestedInput
    providers?: providersUpdateOneWithoutAppointmentsNestedInput
    payments?: paymentsUpdateManyWithoutAppointmentsNestedInput
    reviews?: reviewsUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payments?: paymentsUncheckedUpdateManyWithoutAppointmentsNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateManyWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    provider_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type patient_favoritesUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUpdateOneWithoutPatient_favoritesNestedInput
  }

  export type patient_favoritesUncheckedUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type patient_favoritesUncheckedUpdateManyWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_schedulesUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_schedulesUncheckedUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_schedulesUncheckedUpdateManyWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    day_of_week?: NullableIntFieldUpdateOperationsInput | number | null
    start_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appointments?: appointmentsUpdateOneWithoutReviewsNestedInput
    patients?: patientsUpdateOneWithoutReviewsNestedInput
  }

  export type reviewsUncheckedUpdateWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type reviewsUncheckedUpdateManyWithoutProvider_branchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    appointment_id?: NullableStringFieldUpdateOperationsInput | string | null
    rating?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type appointmentsCreateManyProvidersInput = {
    id: string
    patient_id?: string | null
    branch_id?: string | null
    scheduled_for?: Date | string | null
    status?: string | null
    reason?: string | null
    is_paid?: boolean | null
  }

  export type medical_historyCreateManyProvidersInput = {
    id: string
    patient_id?: string | null
    doctor_name_snapshot?: string | null
    specialty_snapshot?: string | null
    diagnosis?: string | null
    date?: Date | string | null
    treatment?: string | null
    indications?: string | null
    observations?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type payoutsCreateManyProvidersInput = {
    id: string
    total_amount?: Decimal | DecimalJsLike | number | string | null
    currency?: string | null
    status?: string | null
    reference_number?: string | null
    period_start?: Date | string | null
    period_end?: Date | string | null
    created_at?: Date | string | null
  }

  export type provider_adsCreateManyProvidersInput = {
    id: string
    badge_text?: string | null
    title?: string | null
    subtitle?: string | null
    image_url?: string | null
    action_text?: string | null
    bg_color_hex?: string | null
    accent_color_hex?: string | null
    target_screen?: string | null
    target_id?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    is_active?: boolean | null
    priority_order?: number | null
  }

  export type provider_bank_detailsCreateManyProvidersInput = {
    id: string
    bank_name?: string | null
    account_number?: string | null
    account_type?: string | null
    account_holder_name?: string | null
    holder_identification?: string | null
    is_verified?: boolean | null
    updated_at?: Date | string | null
  }

  export type provider_branchesCreateManyProvidersInput = {
    id: string
    city_id?: string | null
    name?: string | null
    description?: string | null
    address_text?: string | null
    latitude?: number | null
    longitude?: number | null
    phone_contact?: string | null
    email_contact?: string | null
    image_url?: string | null
    opening_hours_text?: string | null
    is_24h?: boolean | null
    has_delivery?: boolean | null
    rating_cache?: number | null
    is_main?: boolean | null
    is_active?: boolean | null
  }

  export type provider_catalogCreateManyProvidersInput = {
    id: string
    type?: string | null
    name?: string | null
    description?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    is_available?: boolean | null
    image_url?: string | null
  }

  export type appointmentsUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    provider_branches?: provider_branchesUpdateOneWithoutAppointmentsNestedInput
    patients?: patientsUpdateOneWithoutAppointmentsNestedInput
    payments?: paymentsUpdateManyWithoutAppointmentsNestedInput
    reviews?: reviewsUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
    payments?: paymentsUncheckedUpdateManyWithoutAppointmentsNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutAppointmentsNestedInput
  }

  export type appointmentsUncheckedUpdateManyWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableStringFieldUpdateOperationsInput | string | null
    scheduled_for?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    is_paid?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type medical_historyUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    doctor_name_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    specialty_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    indications?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    patients?: patientsUpdateOneWithoutMedical_historyNestedInput
  }

  export type medical_historyUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_name_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    specialty_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    indications?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type medical_historyUncheckedUpdateManyWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    patient_id?: NullableStringFieldUpdateOperationsInput | string | null
    doctor_name_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    specialty_snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    treatment?: NullableStringFieldUpdateOperationsInput | string | null
    indications?: NullableStringFieldUpdateOperationsInput | string | null
    observations?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type payoutsUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: paymentsUpdateManyWithoutPayoutsNestedInput
  }

  export type payoutsUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: paymentsUncheckedUpdateManyWithoutPayoutsNestedInput
  }

  export type payoutsUncheckedUpdateManyWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    total_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    period_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    period_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_adsUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge_text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    action_text?: NullableStringFieldUpdateOperationsInput | string | null
    bg_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    accent_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    target_screen?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type provider_adsUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge_text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    action_text?: NullableStringFieldUpdateOperationsInput | string | null
    bg_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    accent_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    target_screen?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type provider_adsUncheckedUpdateManyWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    badge_text?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    action_text?: NullableStringFieldUpdateOperationsInput | string | null
    bg_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    accent_color_hex?: NullableStringFieldUpdateOperationsInput | string | null
    target_screen?: NullableStringFieldUpdateOperationsInput | string | null
    target_id?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    priority_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type provider_bank_detailsUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_holder_name?: NullableStringFieldUpdateOperationsInput | string | null
    holder_identification?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_bank_detailsUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_holder_name?: NullableStringFieldUpdateOperationsInput | string | null
    holder_identification?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_bank_detailsUncheckedUpdateManyWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    account_type?: NullableStringFieldUpdateOperationsInput | string | null
    account_holder_name?: NullableStringFieldUpdateOperationsInput | string | null
    holder_identification?: NullableStringFieldUpdateOperationsInput | string | null
    is_verified?: NullableBoolFieldUpdateOperationsInput | boolean | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type provider_branchesUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUpdateManyWithoutProvider_branchesNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutProvider_branchesNestedInput
    cities?: citiesUpdateOneWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUpdateManyWithoutProvider_branchesNestedInput
  }

  export type provider_branchesUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvider_branchesNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    provider_schedules?: provider_schedulesUncheckedUpdateManyWithoutProvider_branchesNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutProvider_branchesNestedInput
  }

  export type provider_branchesUncheckedUpdateManyWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    city_id?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    phone_contact?: NullableStringFieldUpdateOperationsInput | string | null
    email_contact?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    opening_hours_text?: NullableStringFieldUpdateOperationsInput | string | null
    is_24h?: NullableBoolFieldUpdateOperationsInput | boolean | null
    has_delivery?: NullableBoolFieldUpdateOperationsInput | boolean | null
    rating_cache?: NullableFloatFieldUpdateOperationsInput | number | null
    is_main?: NullableBoolFieldUpdateOperationsInput | boolean | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type provider_catalogUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type provider_catalogUncheckedUpdateWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type provider_catalogUncheckedUpdateManyWithoutProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    is_available?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type providersCreateManyService_categoriesInput = {
    id: string
    user_id?: string | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
  }

  export type providersUpdateWithoutService_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUpdateManyWithoutProvidersNestedInput
    users?: usersUpdateOneWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutService_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUncheckedUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateManyWithoutService_categoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type patientsCreateManyUsersInput = {
    id: string
    full_name: string
    identification?: string | null
    phone?: string | null
    birth_date?: Date | string | null
    address_text?: string | null
  }

  export type providersCreateManyUsersInput = {
    id: string
    category_id?: number | null
    commercial_name?: string | null
    logo_url?: string | null
    description?: string | null
    verification_status?: string | null
    commission_percentage?: Decimal | DecimalJsLike | number | string | null
  }

  export type sessionsCreateManyUsersInput = {
    id: string
    token: string
    device_info?: string | null
    expires_at: Date | string
    created_at?: Date | string | null
  }

  export type patientsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUpdateManyWithoutPatientsNestedInput
    medical_history?: medical_historyUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUpdateManyWithoutPatientsNestedInput
    reviews?: reviewsUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutPatientsNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutPatientsNestedInput
    notifications?: notificationsUncheckedUpdateManyWithoutPatientsNestedInput
    patient_favorites?: patient_favoritesUncheckedUpdateManyWithoutPatientsNestedInput
    reviews?: reviewsUncheckedUpdateManyWithoutPatientsNestedInput
  }

  export type patientsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    full_name?: StringFieldUpdateOperationsInput | string
    identification?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birth_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    address_text?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type providersUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUpdateManyWithoutProvidersNestedInput
    service_categories?: service_categoriesUpdateOneWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    appointments?: appointmentsUncheckedUpdateManyWithoutProvidersNestedInput
    medical_history?: medical_historyUncheckedUpdateManyWithoutProvidersNestedInput
    payouts?: payoutsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_ads?: provider_adsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_bank_details?: provider_bank_detailsUncheckedUpdateManyWithoutProvidersNestedInput
    provider_branches?: provider_branchesUncheckedUpdateManyWithoutProvidersNestedInput
    provider_catalog?: provider_catalogUncheckedUpdateManyWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    commercial_name?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    verification_status?: NullableStringFieldUpdateOperationsInput | string | null
    commission_percentage?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type sessionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type sessionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    device_info?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}